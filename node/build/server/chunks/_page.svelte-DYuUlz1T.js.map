{"version":3,"file":"_page.svelte-DYuUlz1T.js","sources":["../../../node_modules/mitt/dist/mitt.mjs","../../../node_modules/camera-controls/dist/camera-controls.module.js","../../../node_modules/three-viewport-gizmo/dist/three-viewport-gizmo.js","../../../node_modules/three-mesh-bvh/src/gpu/glsl/common_functions.glsl.js","../../../node_modules/three-mesh-bvh/src/gpu/glsl/bvh_ray_functions.glsl.js","../../../node_modules/three-mesh-bvh/src/gpu/glsl/bvh_struct_definitions.glsl.js","../../../node_modules/three-mesh-bvh/src/index.js","../../../node_modules/@threejs-kit/instanced-sprite-mesh/dist/index.js","../../../.svelte-kit/adapter-node/entries/pages/models/configure/_page.svelte.js"],"sourcesContent":["export default function(n){return{all:n=n||new Map,on:function(t,e){var i=n.get(t);i?i.push(e):n.set(t,[e])},off:function(t,e){var i=n.get(t);i&&(e?i.splice(i.indexOf(e)>>>0,1):n.set(t,[]))},emit:function(t,e){var i=n.get(t);i&&i.slice().map(function(n){n(e)}),(i=n.get(\"*\"))&&i.slice().map(function(n){n(t,e)})}}}\n//# sourceMappingURL=mitt.mjs.map\n","/*!\n * camera-controls\n * https://github.com/yomotsu/camera-controls\n * (c) 2017 @yomotsu\n * Released under the MIT License.\n */\n// see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#value\nconst MOUSE_BUTTON = {\n    LEFT: 1,\n    RIGHT: 2,\n    MIDDLE: 4,\n};\nconst ACTION = Object.freeze({\n    NONE: 0b0,\n    ROTATE: 0b1,\n    TRUCK: 0b10,\n    SCREEN_PAN: 0b100,\n    OFFSET: 0b1000,\n    DOLLY: 0b10000,\n    ZOOM: 0b100000,\n    TOUCH_ROTATE: 0b1000000,\n    TOUCH_TRUCK: 0b10000000,\n    TOUCH_SCREEN_PAN: 0b100000000,\n    TOUCH_OFFSET: 0b1000000000,\n    TOUCH_DOLLY: 0b10000000000,\n    TOUCH_ZOOM: 0b100000000000,\n    TOUCH_DOLLY_TRUCK: 0b1000000000000,\n    TOUCH_DOLLY_SCREEN_PAN: 0b10000000000000,\n    TOUCH_DOLLY_OFFSET: 0b100000000000000,\n    TOUCH_DOLLY_ROTATE: 0b1000000000000000,\n    TOUCH_ZOOM_TRUCK: 0b10000000000000000,\n    TOUCH_ZOOM_OFFSET: 0b100000000000000000,\n    TOUCH_ZOOM_SCREEN_PAN: 0b1000000000000000000,\n    TOUCH_ZOOM_ROTATE: 0b10000000000000000000,\n});\nconst DOLLY_DIRECTION = {\n    NONE: 0,\n    IN: 1,\n    OUT: -1,\n};\nfunction isPerspectiveCamera(camera) {\n    return camera.isPerspectiveCamera;\n}\nfunction isOrthographicCamera(camera) {\n    return camera.isOrthographicCamera;\n}\n\nconst PI_2 = Math.PI * 2;\nconst PI_HALF = Math.PI / 2;\n\nconst EPSILON = 1e-5;\nconst DEG2RAD = Math.PI / 180;\nfunction clamp(value, min, max) {\n    return Math.max(min, Math.min(max, value));\n}\nfunction approxZero(number, error = EPSILON) {\n    return Math.abs(number) < error;\n}\nfunction approxEquals(a, b, error = EPSILON) {\n    return approxZero(a - b, error);\n}\nfunction roundToStep(value, step) {\n    return Math.round(value / step) * step;\n}\nfunction infinityToMaxNumber(value) {\n    if (isFinite(value))\n        return value;\n    if (value < 0)\n        return -Number.MAX_VALUE;\n    return Number.MAX_VALUE;\n}\nfunction maxNumberToInfinity(value) {\n    if (Math.abs(value) < Number.MAX_VALUE)\n        return value;\n    return value * Infinity;\n}\n// https://docs.unity3d.com/ScriptReference/Mathf.SmoothDamp.html\n// https://github.com/Unity-Technologies/UnityCsReference/blob/a2bdfe9b3c4cd4476f44bf52f848063bfaf7b6b9/Runtime/Export/Math/Mathf.cs#L308\nfunction smoothDamp(current, target, currentVelocityRef, smoothTime, maxSpeed = Infinity, deltaTime) {\n    // Based on Game Programming Gems 4 Chapter 1.10\n    smoothTime = Math.max(0.0001, smoothTime);\n    const omega = 2 / smoothTime;\n    const x = omega * deltaTime;\n    const exp = 1 / (1 + x + 0.48 * x * x + 0.235 * x * x * x);\n    let change = current - target;\n    const originalTo = target;\n    // Clamp maximum speed\n    const maxChange = maxSpeed * smoothTime;\n    change = clamp(change, -maxChange, maxChange);\n    target = current - change;\n    const temp = (currentVelocityRef.value + omega * change) * deltaTime;\n    currentVelocityRef.value = (currentVelocityRef.value - omega * temp) * exp;\n    let output = target + (change + temp) * exp;\n    // Prevent overshooting\n    if (originalTo - current > 0.0 === output > originalTo) {\n        output = originalTo;\n        currentVelocityRef.value = (output - originalTo) / deltaTime;\n    }\n    return output;\n}\n// https://docs.unity3d.com/ScriptReference/Vector3.SmoothDamp.html\n// https://github.com/Unity-Technologies/UnityCsReference/blob/a2bdfe9b3c4cd4476f44bf52f848063bfaf7b6b9/Runtime/Export/Math/Vector3.cs#L97\nfunction smoothDampVec3(current, target, currentVelocityRef, smoothTime, maxSpeed = Infinity, deltaTime, out) {\n    // Based on Game Programming Gems 4 Chapter 1.10\n    smoothTime = Math.max(0.0001, smoothTime);\n    const omega = 2 / smoothTime;\n    const x = omega * deltaTime;\n    const exp = 1 / (1 + x + 0.48 * x * x + 0.235 * x * x * x);\n    let targetX = target.x;\n    let targetY = target.y;\n    let targetZ = target.z;\n    let changeX = current.x - targetX;\n    let changeY = current.y - targetY;\n    let changeZ = current.z - targetZ;\n    const originalToX = targetX;\n    const originalToY = targetY;\n    const originalToZ = targetZ;\n    // Clamp maximum speed\n    const maxChange = maxSpeed * smoothTime;\n    const maxChangeSq = maxChange * maxChange;\n    const magnitudeSq = changeX * changeX + changeY * changeY + changeZ * changeZ;\n    if (magnitudeSq > maxChangeSq) {\n        const magnitude = Math.sqrt(magnitudeSq);\n        changeX = changeX / magnitude * maxChange;\n        changeY = changeY / magnitude * maxChange;\n        changeZ = changeZ / magnitude * maxChange;\n    }\n    targetX = current.x - changeX;\n    targetY = current.y - changeY;\n    targetZ = current.z - changeZ;\n    const tempX = (currentVelocityRef.x + omega * changeX) * deltaTime;\n    const tempY = (currentVelocityRef.y + omega * changeY) * deltaTime;\n    const tempZ = (currentVelocityRef.z + omega * changeZ) * deltaTime;\n    currentVelocityRef.x = (currentVelocityRef.x - omega * tempX) * exp;\n    currentVelocityRef.y = (currentVelocityRef.y - omega * tempY) * exp;\n    currentVelocityRef.z = (currentVelocityRef.z - omega * tempZ) * exp;\n    out.x = targetX + (changeX + tempX) * exp;\n    out.y = targetY + (changeY + tempY) * exp;\n    out.z = targetZ + (changeZ + tempZ) * exp;\n    // Prevent overshooting\n    const origMinusCurrentX = originalToX - current.x;\n    const origMinusCurrentY = originalToY - current.y;\n    const origMinusCurrentZ = originalToZ - current.z;\n    const outMinusOrigX = out.x - originalToX;\n    const outMinusOrigY = out.y - originalToY;\n    const outMinusOrigZ = out.z - originalToZ;\n    if (origMinusCurrentX * outMinusOrigX + origMinusCurrentY * outMinusOrigY + origMinusCurrentZ * outMinusOrigZ > 0) {\n        out.x = originalToX;\n        out.y = originalToY;\n        out.z = originalToZ;\n        currentVelocityRef.x = (out.x - originalToX) / deltaTime;\n        currentVelocityRef.y = (out.y - originalToY) / deltaTime;\n        currentVelocityRef.z = (out.z - originalToZ) / deltaTime;\n    }\n    return out;\n}\n\nfunction extractClientCoordFromEvent(pointers, out) {\n    out.set(0, 0);\n    pointers.forEach((pointer) => {\n        out.x += pointer.clientX;\n        out.y += pointer.clientY;\n    });\n    out.x /= pointers.length;\n    out.y /= pointers.length;\n}\n\nfunction notSupportedInOrthographicCamera(camera, message) {\n    if (isOrthographicCamera(camera)) {\n        console.warn(`${message} is not supported in OrthographicCamera`);\n        return true;\n    }\n    return false;\n}\n\nclass EventDispatcher {\n    constructor() {\n        this._listeners = {};\n    }\n    /**\n     * Adds the specified event listener.\n     * @param type event name\n     * @param listener handler function\n     * @category Methods\n     */\n    addEventListener(type, listener) {\n        const listeners = this._listeners;\n        if (listeners[type] === undefined)\n            listeners[type] = [];\n        if (listeners[type].indexOf(listener) === -1)\n            listeners[type].push(listener);\n    }\n    /**\n     * Presence of the specified event listener.\n     * @param type event name\n     * @param listener handler function\n     * @category Methods\n     */\n    hasEventListener(type, listener) {\n        const listeners = this._listeners;\n        return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;\n    }\n    /**\n     * Removes the specified event listener\n     * @param type event name\n     * @param listener handler function\n     * @category Methods\n     */\n    removeEventListener(type, listener) {\n        const listeners = this._listeners;\n        const listenerArray = listeners[type];\n        if (listenerArray !== undefined) {\n            const index = listenerArray.indexOf(listener);\n            if (index !== -1)\n                listenerArray.splice(index, 1);\n        }\n    }\n    /**\n     * Removes all event listeners\n     * @param type event name\n     * @category Methods\n     */\n    removeAllEventListeners(type) {\n        if (!type) {\n            this._listeners = {};\n            return;\n        }\n        if (Array.isArray(this._listeners[type]))\n            this._listeners[type].length = 0;\n    }\n    /**\n     * Fire an event type.\n     * @param event DispatcherEvent\n     * @category Methods\n     */\n    dispatchEvent(event) {\n        const listeners = this._listeners;\n        const listenerArray = listeners[event.type];\n        if (listenerArray !== undefined) {\n            event.target = this;\n            const array = listenerArray.slice(0);\n            for (let i = 0, l = array.length; i < l; i++) {\n                array[i].call(this, event);\n            }\n        }\n    }\n}\n\nvar _a;\nconst VERSION = '2.10.1'; // will be replaced with `version` in package.json during the build process.\nconst TOUCH_DOLLY_FACTOR = 1 / 8;\nconst isMac = /Mac/.test((_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.navigator) === null || _a === void 0 ? void 0 : _a.platform);\nlet THREE;\nlet _ORIGIN;\nlet _AXIS_Y;\nlet _AXIS_Z;\nlet _v2;\nlet _v3A;\nlet _v3B;\nlet _v3C;\nlet _cameraDirection;\nlet _xColumn;\nlet _yColumn;\nlet _zColumn;\nlet _deltaTarget;\nlet _deltaOffset;\nlet _sphericalA;\nlet _sphericalB;\nlet _box3A;\nlet _box3B;\nlet _sphere;\nlet _quaternionA;\nlet _quaternionB;\nlet _rotationMatrix;\nlet _raycaster;\nclass CameraControls extends EventDispatcher {\n    /**\n     * Injects THREE as the dependency. You can then proceed to use CameraControls.\n     *\n     * e.g\n     * ```javascript\n     * CameraControls.install( { THREE: THREE } );\n     * ```\n     *\n     * Note: If you do not wish to use enter three.js to reduce file size(tree-shaking for example), make a subset to install.\n     *\n     * ```js\n     * import {\n     * \tVector2,\n     * \tVector3,\n     * \tVector4,\n     * \tQuaternion,\n     * \tMatrix4,\n     * \tSpherical,\n     * \tBox3,\n     * \tSphere,\n     * \tRaycaster,\n     * \tMathUtils,\n     * } from 'three';\n     *\n     * const subsetOfTHREE = {\n     * \tVector2   : Vector2,\n     * \tVector3   : Vector3,\n     * \tVector4   : Vector4,\n     * \tQuaternion: Quaternion,\n     * \tMatrix4   : Matrix4,\n     * \tSpherical : Spherical,\n     * \tBox3      : Box3,\n     * \tSphere    : Sphere,\n     * \tRaycaster : Raycaster,\n     * };\n\n     * CameraControls.install( { THREE: subsetOfTHREE } );\n     * ```\n     * @category Statics\n     */\n    static install(libs) {\n        THREE = libs.THREE;\n        _ORIGIN = Object.freeze(new THREE.Vector3(0, 0, 0));\n        _AXIS_Y = Object.freeze(new THREE.Vector3(0, 1, 0));\n        _AXIS_Z = Object.freeze(new THREE.Vector3(0, 0, 1));\n        _v2 = new THREE.Vector2();\n        _v3A = new THREE.Vector3();\n        _v3B = new THREE.Vector3();\n        _v3C = new THREE.Vector3();\n        _cameraDirection = new THREE.Vector3();\n        _xColumn = new THREE.Vector3();\n        _yColumn = new THREE.Vector3();\n        _zColumn = new THREE.Vector3();\n        _deltaTarget = new THREE.Vector3();\n        _deltaOffset = new THREE.Vector3();\n        _sphericalA = new THREE.Spherical();\n        _sphericalB = new THREE.Spherical();\n        _box3A = new THREE.Box3();\n        _box3B = new THREE.Box3();\n        _sphere = new THREE.Sphere();\n        _quaternionA = new THREE.Quaternion();\n        _quaternionB = new THREE.Quaternion();\n        _rotationMatrix = new THREE.Matrix4();\n        _raycaster = new THREE.Raycaster();\n    }\n    /**\n     * list all ACTIONs\n     * @category Statics\n     */\n    static get ACTION() {\n        return ACTION;\n    }\n    /**\n     * @deprecated Use `cameraControls.mouseButtons.left = CameraControls.ACTION.SCREEN_PAN` instead.\n     */\n    set verticalDragToForward(_) {\n        console.warn('camera-controls: `verticalDragToForward` was removed. Use `mouseButtons.left = CameraControls.ACTION.SCREEN_PAN` instead.');\n    }\n    /**\n     * Creates a `CameraControls` instance.\n     *\n     * Note:\n     * You **must install** three.js before using camera-controls. see [#install](#install)\n     * Not doing so will lead to runtime errors (`undefined` references to THREE).\n     *\n     * e.g.\n     * ```\n     * CameraControls.install( { THREE } );\n     * const cameraControls = new CameraControls( camera, domElement );\n     * ```\n     *\n     * @param camera A `THREE.PerspectiveCamera` or `THREE.OrthographicCamera` to be controlled.\n     * @param domElement A `HTMLElement` for the draggable area, usually `renderer.domElement`.\n     * @category Constructor\n     */\n    constructor(camera, domElement) {\n        super();\n        /**\n         * Minimum vertical angle in radians.\n         * The angle has to be between `0` and `.maxPolarAngle` inclusive.\n         * The default value is `0`.\n         *\n         * e.g.\n         * ```\n         * cameraControls.maxPolarAngle = 0;\n         * ```\n         * @category Properties\n         */\n        this.minPolarAngle = 0; // radians\n        /**\n         * Maximum vertical angle in radians.\n         * The angle has to be between `.maxPolarAngle` and `Math.PI` inclusive.\n         * The default value is `Math.PI`.\n         *\n         * e.g.\n         * ```\n         * cameraControls.maxPolarAngle = Math.PI;\n         * ```\n         * @category Properties\n         */\n        this.maxPolarAngle = Math.PI; // radians\n        /**\n         * Minimum horizontal angle in radians.\n         * The angle has to be less than `.maxAzimuthAngle`.\n         * The default value is `- Infinity`.\n         *\n         * e.g.\n         * ```\n         * cameraControls.minAzimuthAngle = - Infinity;\n         * ```\n         * @category Properties\n         */\n        this.minAzimuthAngle = -Infinity; // radians\n        /**\n         * Maximum horizontal angle in radians.\n         * The angle has to be greater than `.minAzimuthAngle`.\n         * The default value is `Infinity`.\n         *\n         * e.g.\n         * ```\n         * cameraControls.maxAzimuthAngle = Infinity;\n         * ```\n         * @category Properties\n         */\n        this.maxAzimuthAngle = Infinity; // radians\n        // How far you can dolly in and out ( PerspectiveCamera only )\n        /**\n         * Minimum distance for dolly. The value must be higher than `0`. Default is `Number.EPSILON`.\n         * PerspectiveCamera only.\n         * @category Properties\n         */\n        this.minDistance = Number.EPSILON;\n        /**\n         * Maximum distance for dolly. The value must be higher than `minDistance`. Default is `Infinity`.\n         * PerspectiveCamera only.\n         * @category Properties\n         */\n        this.maxDistance = Infinity;\n        /**\n         * `true` to enable Infinity Dolly for wheel and pinch. Use this with `minDistance` and `maxDistance`\n         * If the Dolly distance is less (or over) than the `minDistance` (or `maxDistance`), `infinityDolly` will keep the distance and pushes the target position instead.\n         * @category Properties\n         */\n        this.infinityDolly = false;\n        /**\n         * Minimum camera zoom.\n         * @category Properties\n         */\n        this.minZoom = 0.01;\n        /**\n         * Maximum camera zoom.\n         * @category Properties\n         */\n        this.maxZoom = Infinity;\n        /**\n         * Approximate time in seconds to reach the target. A smaller value will reach the target faster.\n         * @category Properties\n         */\n        this.smoothTime = 0.25;\n        /**\n         * the smoothTime while dragging\n         * @category Properties\n         */\n        this.draggingSmoothTime = 0.125;\n        /**\n         * Max transition speed in unit-per-seconds\n         * @category Properties\n         */\n        this.maxSpeed = Infinity;\n        /**\n         * Speed of azimuth (horizontal) rotation.\n         * @category Properties\n         */\n        this.azimuthRotateSpeed = 1.0;\n        /**\n         * Speed of polar (vertical) rotation.\n         * @category Properties\n         */\n        this.polarRotateSpeed = 1.0;\n        /**\n         * Speed of mouse-wheel dollying.\n         * @category Properties\n         */\n        this.dollySpeed = 1.0;\n        /**\n         * `true` to invert direction when dollying or zooming via drag\n         * @category Properties\n         */\n        this.dollyDragInverted = false;\n        /**\n         * Speed of drag for truck and pedestal.\n         * @category Properties\n         */\n        this.truckSpeed = 2.0;\n        /**\n         * `true` to enable Dolly-in to the mouse cursor coords.\n         * @category Properties\n         */\n        this.dollyToCursor = false;\n        /**\n         * @category Properties\n         */\n        this.dragToOffset = false;\n        /**\n         * Friction ratio of the boundary.\n         * @category Properties\n         */\n        this.boundaryFriction = 0.0;\n        /**\n         * Controls how soon the `rest` event fires as the camera slows.\n         * @category Properties\n         */\n        this.restThreshold = 0.01;\n        /**\n         * An array of Meshes to collide with camera.\n         * Be aware colliderMeshes may decrease performance. The collision test uses 4 raycasters from the camera since the near plane has 4 corners.\n         * @category Properties\n         */\n        this.colliderMeshes = [];\n        /**\n         * Force cancel user dragging.\n         * @category Methods\n         */\n        // cancel will be overwritten in the constructor.\n        this.cancel = () => { };\n        this._enabled = true;\n        this._state = ACTION.NONE;\n        this._viewport = null;\n        this._changedDolly = 0;\n        this._changedZoom = 0;\n        this._hasRested = true;\n        this._boundaryEnclosesCamera = false;\n        this._needsUpdate = true;\n        this._updatedLastTime = false;\n        this._elementRect = new DOMRect();\n        this._isDragging = false;\n        this._dragNeedsUpdate = true;\n        this._activePointers = [];\n        this._lockedPointer = null;\n        this._interactiveArea = new DOMRect(0, 0, 1, 1);\n        // Use draggingSmoothTime over smoothTime while true.\n        // set automatically true on user-dragging start.\n        // set automatically false on programmable methods call.\n        this._isUserControllingRotate = false;\n        this._isUserControllingDolly = false;\n        this._isUserControllingTruck = false;\n        this._isUserControllingOffset = false;\n        this._isUserControllingZoom = false;\n        this._lastDollyDirection = DOLLY_DIRECTION.NONE;\n        // velocities for smoothDamp\n        this._thetaVelocity = { value: 0 };\n        this._phiVelocity = { value: 0 };\n        this._radiusVelocity = { value: 0 };\n        this._targetVelocity = new THREE.Vector3();\n        this._focalOffsetVelocity = new THREE.Vector3();\n        this._zoomVelocity = { value: 0 };\n        this._truckInternal = (deltaX, deltaY, dragToOffset, screenSpacePanning) => {\n            let truckX;\n            let pedestalY;\n            if (isPerspectiveCamera(this._camera)) {\n                const offset = _v3A.copy(this._camera.position).sub(this._target);\n                // half of the fov is center to top of screen\n                const fov = this._camera.getEffectiveFOV() * DEG2RAD;\n                const targetDistance = offset.length() * Math.tan(fov * 0.5);\n                truckX = (this.truckSpeed * deltaX * targetDistance / this._elementRect.height);\n                pedestalY = (this.truckSpeed * deltaY * targetDistance / this._elementRect.height);\n            }\n            else if (isOrthographicCamera(this._camera)) {\n                const camera = this._camera;\n                truckX = this.truckSpeed * deltaX * (camera.right - camera.left) / camera.zoom / this._elementRect.width;\n                pedestalY = this.truckSpeed * deltaY * (camera.top - camera.bottom) / camera.zoom / this._elementRect.height;\n            }\n            else {\n                return;\n            }\n            if (screenSpacePanning) {\n                dragToOffset ?\n                    this.setFocalOffset(this._focalOffsetEnd.x + truckX, this._focalOffsetEnd.y, this._focalOffsetEnd.z, true) :\n                    this.truck(truckX, 0, true);\n                this.forward(-pedestalY, true);\n            }\n            else {\n                dragToOffset ?\n                    this.setFocalOffset(this._focalOffsetEnd.x + truckX, this._focalOffsetEnd.y + pedestalY, this._focalOffsetEnd.z, true) :\n                    this.truck(truckX, pedestalY, true);\n            }\n        };\n        this._rotateInternal = (deltaX, deltaY) => {\n            const theta = PI_2 * this.azimuthRotateSpeed * deltaX / this._elementRect.height; // divide by *height* to refer the resolution\n            const phi = PI_2 * this.polarRotateSpeed * deltaY / this._elementRect.height;\n            this.rotate(theta, phi, true);\n        };\n        this._dollyInternal = (delta, x, y) => {\n            const dollyScale = Math.pow(0.95, -delta * this.dollySpeed);\n            const lastDistance = this._sphericalEnd.radius;\n            const distance = this._sphericalEnd.radius * dollyScale;\n            const clampedDistance = clamp(distance, this.minDistance, this.maxDistance);\n            const overflowedDistance = clampedDistance - distance;\n            if (this.infinityDolly && this.dollyToCursor) {\n                this._dollyToNoClamp(distance, true);\n            }\n            else if (this.infinityDolly && !this.dollyToCursor) {\n                this.dollyInFixed(overflowedDistance, true);\n                this._dollyToNoClamp(clampedDistance, true);\n            }\n            else {\n                this._dollyToNoClamp(clampedDistance, true);\n            }\n            if (this.dollyToCursor) {\n                this._changedDolly += (this.infinityDolly ? distance : clampedDistance) - lastDistance;\n                this._dollyControlCoord.set(x, y);\n            }\n            this._lastDollyDirection = Math.sign(-delta);\n        };\n        this._zoomInternal = (delta, x, y) => {\n            const zoomScale = Math.pow(0.95, delta * this.dollySpeed);\n            const lastZoom = this._zoom;\n            const zoom = this._zoom * zoomScale;\n            // for both PerspectiveCamera and OrthographicCamera\n            this.zoomTo(zoom, true);\n            if (this.dollyToCursor) {\n                this._changedZoom += zoom - lastZoom;\n                this._dollyControlCoord.set(x, y);\n            }\n        };\n        // Check if the user has installed THREE\n        if (typeof THREE === 'undefined') {\n            console.error('camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information.');\n        }\n        this._camera = camera;\n        this._yAxisUpSpace = new THREE.Quaternion().setFromUnitVectors(this._camera.up, _AXIS_Y);\n        this._yAxisUpSpaceInverse = this._yAxisUpSpace.clone().invert();\n        this._state = ACTION.NONE;\n        // the location\n        this._target = new THREE.Vector3();\n        this._targetEnd = this._target.clone();\n        this._focalOffset = new THREE.Vector3();\n        this._focalOffsetEnd = this._focalOffset.clone();\n        // rotation\n        this._spherical = new THREE.Spherical().setFromVector3(_v3A.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace));\n        this._sphericalEnd = this._spherical.clone();\n        this._lastDistance = this._spherical.radius;\n        this._zoom = this._camera.zoom;\n        this._zoomEnd = this._zoom;\n        this._lastZoom = this._zoom;\n        // collisionTest uses nearPlane.s\n        this._nearPlaneCorners = [\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n        ];\n        this._updateNearPlaneCorners();\n        // Target cannot move outside of this box\n        this._boundary = new THREE.Box3(new THREE.Vector3(-Infinity, -Infinity, -Infinity), new THREE.Vector3(Infinity, Infinity, Infinity));\n        // reset\n        this._cameraUp0 = this._camera.up.clone();\n        this._target0 = this._target.clone();\n        this._position0 = this._camera.position.clone();\n        this._zoom0 = this._zoom;\n        this._focalOffset0 = this._focalOffset.clone();\n        this._dollyControlCoord = new THREE.Vector2();\n        // configs\n        this.mouseButtons = {\n            left: ACTION.ROTATE,\n            middle: ACTION.DOLLY,\n            right: ACTION.TRUCK,\n            wheel: isPerspectiveCamera(this._camera) ? ACTION.DOLLY :\n                isOrthographicCamera(this._camera) ? ACTION.ZOOM :\n                    ACTION.NONE,\n        };\n        this.touches = {\n            one: ACTION.TOUCH_ROTATE,\n            two: isPerspectiveCamera(this._camera) ? ACTION.TOUCH_DOLLY_TRUCK :\n                isOrthographicCamera(this._camera) ? ACTION.TOUCH_ZOOM_TRUCK :\n                    ACTION.NONE,\n            three: ACTION.TOUCH_TRUCK,\n        };\n        const dragStartPosition = new THREE.Vector2();\n        const lastDragPosition = new THREE.Vector2();\n        const dollyStart = new THREE.Vector2();\n        const onPointerDown = (event) => {\n            if (!this._enabled || !this._domElement)\n                return;\n            if (this._interactiveArea.left !== 0 ||\n                this._interactiveArea.top !== 0 ||\n                this._interactiveArea.width !== 1 ||\n                this._interactiveArea.height !== 1) {\n                const elRect = this._domElement.getBoundingClientRect();\n                const left = event.clientX / elRect.width;\n                const top = event.clientY / elRect.height;\n                // check if the interactiveArea contains the drag start position.\n                if (left < this._interactiveArea.left ||\n                    left > this._interactiveArea.right ||\n                    top < this._interactiveArea.top ||\n                    top > this._interactiveArea.bottom)\n                    return;\n            }\n            // Don't call `event.preventDefault()` on the pointerdown event\n            // to keep receiving pointermove evens outside dragging iframe\n            // https://taye.me/blog/tips/2015/11/16/mouse-drag-outside-iframe/\n            const mouseButton = event.pointerType !== 'mouse' ? null :\n                (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT ? MOUSE_BUTTON.LEFT :\n                    (event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE ? MOUSE_BUTTON.MIDDLE :\n                        (event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT ? MOUSE_BUTTON.RIGHT :\n                            null;\n            if (mouseButton !== null) {\n                const zombiePointer = this._findPointerByMouseButton(mouseButton);\n                zombiePointer && this._disposePointer(zombiePointer);\n            }\n            if ((event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT && this._lockedPointer)\n                return;\n            const pointer = {\n                pointerId: event.pointerId,\n                clientX: event.clientX,\n                clientY: event.clientY,\n                deltaX: 0,\n                deltaY: 0,\n                mouseButton,\n            };\n            this._activePointers.push(pointer);\n            // eslint-disable-next-line no-undef\n            this._domElement.ownerDocument.removeEventListener('pointermove', onPointerMove, { passive: false });\n            this._domElement.ownerDocument.removeEventListener('pointerup', onPointerUp);\n            this._domElement.ownerDocument.addEventListener('pointermove', onPointerMove, { passive: false });\n            this._domElement.ownerDocument.addEventListener('pointerup', onPointerUp);\n            this._isDragging = true;\n            startDragging(event);\n        };\n        const onPointerMove = (event) => {\n            if (event.cancelable)\n                event.preventDefault();\n            const pointerId = event.pointerId;\n            const pointer = this._lockedPointer || this._findPointerById(pointerId);\n            if (!pointer)\n                return;\n            pointer.clientX = event.clientX;\n            pointer.clientY = event.clientY;\n            pointer.deltaX = event.movementX;\n            pointer.deltaY = event.movementY;\n            this._state = 0;\n            if (event.pointerType === 'touch') {\n                switch (this._activePointers.length) {\n                    case 1:\n                        this._state = this.touches.one;\n                        break;\n                    case 2:\n                        this._state = this.touches.two;\n                        break;\n                    case 3:\n                        this._state = this.touches.three;\n                        break;\n                }\n            }\n            else {\n                if ((!this._isDragging && this._lockedPointer) ||\n                    this._isDragging && (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT) {\n                    this._state = this._state | this.mouseButtons.left;\n                }\n                if (this._isDragging && (event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE) {\n                    this._state = this._state | this.mouseButtons.middle;\n                }\n                if (this._isDragging && (event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT) {\n                    this._state = this._state | this.mouseButtons.right;\n                }\n            }\n            dragging();\n        };\n        const onPointerUp = (event) => {\n            const pointer = this._findPointerById(event.pointerId);\n            if (pointer && pointer === this._lockedPointer)\n                return;\n            pointer && this._disposePointer(pointer);\n            if (event.pointerType === 'touch') {\n                switch (this._activePointers.length) {\n                    case 0:\n                        this._state = ACTION.NONE;\n                        break;\n                    case 1:\n                        this._state = this.touches.one;\n                        break;\n                    case 2:\n                        this._state = this.touches.two;\n                        break;\n                    case 3:\n                        this._state = this.touches.three;\n                        break;\n                }\n            }\n            else {\n                this._state = ACTION.NONE;\n            }\n            endDragging();\n        };\n        let lastScrollTimeStamp = -1;\n        const onMouseWheel = (event) => {\n            if (!this._domElement)\n                return;\n            if (!this._enabled || this.mouseButtons.wheel === ACTION.NONE)\n                return;\n            if (this._interactiveArea.left !== 0 ||\n                this._interactiveArea.top !== 0 ||\n                this._interactiveArea.width !== 1 ||\n                this._interactiveArea.height !== 1) {\n                const elRect = this._domElement.getBoundingClientRect();\n                const left = event.clientX / elRect.width;\n                const top = event.clientY / elRect.height;\n                // check if the interactiveArea contains the drag start position.\n                if (left < this._interactiveArea.left ||\n                    left > this._interactiveArea.right ||\n                    top < this._interactiveArea.top ||\n                    top > this._interactiveArea.bottom)\n                    return;\n            }\n            event.preventDefault();\n            if (this.dollyToCursor ||\n                this.mouseButtons.wheel === ACTION.ROTATE ||\n                this.mouseButtons.wheel === ACTION.TRUCK) {\n                const now = performance.now();\n                // only need to fire this at scroll start.\n                if (lastScrollTimeStamp - now < 1000)\n                    this._getClientRect(this._elementRect);\n                lastScrollTimeStamp = now;\n            }\n            // Ref: https://github.com/cedricpinson/osgjs/blob/00e5a7e9d9206c06fdde0436e1d62ab7cb5ce853/sources/osgViewer/input/source/InputSourceMouse.js#L89-L103\n            const deltaYFactor = isMac ? -1 : -3;\n            // Checks event.ctrlKey to detect multi-touch gestures on a trackpad.\n            const delta = (event.deltaMode === 1 || event.ctrlKey) ? event.deltaY / deltaYFactor : event.deltaY / (deltaYFactor * 10);\n            const x = this.dollyToCursor ? (event.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;\n            const y = this.dollyToCursor ? (event.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;\n            switch (this.mouseButtons.wheel) {\n                case ACTION.ROTATE: {\n                    this._rotateInternal(event.deltaX, event.deltaY);\n                    this._isUserControllingRotate = true;\n                    break;\n                }\n                case ACTION.TRUCK: {\n                    this._truckInternal(event.deltaX, event.deltaY, false, false);\n                    this._isUserControllingTruck = true;\n                    break;\n                }\n                case ACTION.SCREEN_PAN: {\n                    this._truckInternal(event.deltaX, event.deltaY, false, true);\n                    this._isUserControllingTruck = true;\n                    break;\n                }\n                case ACTION.OFFSET: {\n                    this._truckInternal(event.deltaX, event.deltaY, true, false);\n                    this._isUserControllingOffset = true;\n                    break;\n                }\n                case ACTION.DOLLY: {\n                    this._dollyInternal(-delta, x, y);\n                    this._isUserControllingDolly = true;\n                    break;\n                }\n                case ACTION.ZOOM: {\n                    this._zoomInternal(-delta, x, y);\n                    this._isUserControllingZoom = true;\n                    break;\n                }\n            }\n            this.dispatchEvent({ type: 'control' });\n        };\n        const onContextMenu = (event) => {\n            if (!this._domElement || !this._enabled)\n                return;\n            // contextmenu event is fired right after pointerdown\n            // remove attached handlers and active pointer, if interrupted by contextmenu.\n            if (this.mouseButtons.right === CameraControls.ACTION.NONE) {\n                const pointerId = event instanceof PointerEvent ? event.pointerId : 0;\n                const pointer = this._findPointerById(pointerId);\n                pointer && this._disposePointer(pointer);\n                // eslint-disable-next-line no-undef\n                this._domElement.ownerDocument.removeEventListener('pointermove', onPointerMove, { passive: false });\n                this._domElement.ownerDocument.removeEventListener('pointerup', onPointerUp);\n                return;\n            }\n            event.preventDefault();\n        };\n        const startDragging = (event) => {\n            if (!this._enabled)\n                return;\n            extractClientCoordFromEvent(this._activePointers, _v2);\n            this._getClientRect(this._elementRect);\n            dragStartPosition.copy(_v2);\n            lastDragPosition.copy(_v2);\n            const isMultiTouch = this._activePointers.length >= 2;\n            if (isMultiTouch) {\n                // 2 finger pinch\n                const dx = _v2.x - this._activePointers[1].clientX;\n                const dy = _v2.y - this._activePointers[1].clientY;\n                const distance = Math.sqrt(dx * dx + dy * dy);\n                dollyStart.set(0, distance);\n                // center coords of 2 finger truck\n                const x = (this._activePointers[0].clientX + this._activePointers[1].clientX) * 0.5;\n                const y = (this._activePointers[0].clientY + this._activePointers[1].clientY) * 0.5;\n                lastDragPosition.set(x, y);\n            }\n            this._state = 0;\n            if (!event) {\n                if (this._lockedPointer)\n                    this._state = this._state | this.mouseButtons.left;\n            }\n            else if ('pointerType' in event && event.pointerType === 'touch') {\n                switch (this._activePointers.length) {\n                    case 1:\n                        this._state = this.touches.one;\n                        break;\n                    case 2:\n                        this._state = this.touches.two;\n                        break;\n                    case 3:\n                        this._state = this.touches.three;\n                        break;\n                }\n            }\n            else {\n                if (!this._lockedPointer && (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT) {\n                    this._state = this._state | this.mouseButtons.left;\n                }\n                if ((event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE) {\n                    this._state = this._state | this.mouseButtons.middle;\n                }\n                if ((event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT) {\n                    this._state = this._state | this.mouseButtons.right;\n                }\n            }\n            // stop current movement on drag start\n            // - rotate\n            if ((this._state & ACTION.ROTATE) === ACTION.ROTATE ||\n                (this._state & ACTION.TOUCH_ROTATE) === ACTION.TOUCH_ROTATE ||\n                (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE ||\n                (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {\n                this._sphericalEnd.theta = this._spherical.theta;\n                this._sphericalEnd.phi = this._spherical.phi;\n                this._thetaVelocity.value = 0;\n                this._phiVelocity.value = 0;\n            }\n            // - truck and screen-pan\n            if ((this._state & ACTION.TRUCK) === ACTION.TRUCK ||\n                (this._state & ACTION.SCREEN_PAN) === ACTION.SCREEN_PAN ||\n                (this._state & ACTION.TOUCH_TRUCK) === ACTION.TOUCH_TRUCK ||\n                (this._state & ACTION.TOUCH_SCREEN_PAN) === ACTION.TOUCH_SCREEN_PAN ||\n                (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK ||\n                (this._state & ACTION.TOUCH_DOLLY_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN ||\n                (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK ||\n                (this._state & ACTION.TOUCH_ZOOM_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN) {\n                this._targetEnd.copy(this._target);\n                this._targetVelocity.set(0, 0, 0);\n            }\n            // - dolly\n            if ((this._state & ACTION.DOLLY) === ACTION.DOLLY ||\n                (this._state & ACTION.TOUCH_DOLLY) === ACTION.TOUCH_DOLLY ||\n                (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK ||\n                (this._state & ACTION.TOUCH_DOLLY_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN ||\n                (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET ||\n                (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE) {\n                this._sphericalEnd.radius = this._spherical.radius;\n                this._radiusVelocity.value = 0;\n            }\n            // - zoom\n            if ((this._state & ACTION.ZOOM) === ACTION.ZOOM ||\n                (this._state & ACTION.TOUCH_ZOOM) === ACTION.TOUCH_ZOOM ||\n                (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK ||\n                (this._state & ACTION.TOUCH_ZOOM_SCREEN_PAN) === ACTION.TOUCH_ZOOM_SCREEN_PAN ||\n                (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET ||\n                (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {\n                this._zoomEnd = this._zoom;\n                this._zoomVelocity.value = 0;\n            }\n            // - offset\n            if ((this._state & ACTION.OFFSET) === ACTION.OFFSET ||\n                (this._state & ACTION.TOUCH_OFFSET) === ACTION.TOUCH_OFFSET ||\n                (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET ||\n                (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET) {\n                this._focalOffsetEnd.copy(this._focalOffset);\n                this._focalOffsetVelocity.set(0, 0, 0);\n            }\n            this.dispatchEvent({ type: 'controlstart' });\n        };\n        const dragging = () => {\n            if (!this._enabled || !this._dragNeedsUpdate)\n                return;\n            this._dragNeedsUpdate = false;\n            extractClientCoordFromEvent(this._activePointers, _v2);\n            // When pointer lock is enabled clientX, clientY, screenX, and screenY remain 0.\n            // If pointer lock is enabled, use the Delta directory, and assume active-pointer is not multiple.\n            const isPointerLockActive = this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement;\n            const lockedPointer = isPointerLockActive ? this._lockedPointer || this._activePointers[0] : null;\n            const deltaX = lockedPointer ? -lockedPointer.deltaX : lastDragPosition.x - _v2.x;\n            const deltaY = lockedPointer ? -lockedPointer.deltaY : lastDragPosition.y - _v2.y;\n            lastDragPosition.copy(_v2);\n            // rotate\n            if ((this._state & ACTION.ROTATE) === ACTION.ROTATE ||\n                (this._state & ACTION.TOUCH_ROTATE) === ACTION.TOUCH_ROTATE ||\n                (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE ||\n                (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {\n                this._rotateInternal(deltaX, deltaY);\n                this._isUserControllingRotate = true;\n            }\n            // mouse dolly or zoom\n            if ((this._state & ACTION.DOLLY) === ACTION.DOLLY ||\n                (this._state & ACTION.ZOOM) === ACTION.ZOOM) {\n                const dollyX = this.dollyToCursor ? (dragStartPosition.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;\n                const dollyY = this.dollyToCursor ? (dragStartPosition.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;\n                const dollyDirection = this.dollyDragInverted ? -1 : 1;\n                if ((this._state & ACTION.DOLLY) === ACTION.DOLLY) {\n                    this._dollyInternal(dollyDirection * deltaY * TOUCH_DOLLY_FACTOR, dollyX, dollyY);\n                    this._isUserControllingDolly = true;\n                }\n                else {\n                    this._zoomInternal(dollyDirection * deltaY * TOUCH_DOLLY_FACTOR, dollyX, dollyY);\n                    this._isUserControllingZoom = true;\n                }\n            }\n            // touch dolly or zoom\n            if ((this._state & ACTION.TOUCH_DOLLY) === ACTION.TOUCH_DOLLY ||\n                (this._state & ACTION.TOUCH_ZOOM) === ACTION.TOUCH_ZOOM ||\n                (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK ||\n                (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK ||\n                (this._state & ACTION.TOUCH_DOLLY_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN ||\n                (this._state & ACTION.TOUCH_ZOOM_SCREEN_PAN) === ACTION.TOUCH_ZOOM_SCREEN_PAN ||\n                (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET ||\n                (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET ||\n                (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE ||\n                (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {\n                const dx = _v2.x - this._activePointers[1].clientX;\n                const dy = _v2.y - this._activePointers[1].clientY;\n                const distance = Math.sqrt(dx * dx + dy * dy);\n                const dollyDelta = dollyStart.y - distance;\n                dollyStart.set(0, distance);\n                const dollyX = this.dollyToCursor ? (lastDragPosition.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;\n                const dollyY = this.dollyToCursor ? (lastDragPosition.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;\n                if ((this._state & ACTION.TOUCH_DOLLY) === ACTION.TOUCH_DOLLY ||\n                    (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE ||\n                    (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK ||\n                    (this._state & ACTION.TOUCH_DOLLY_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN ||\n                    (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET) {\n                    this._dollyInternal(dollyDelta * TOUCH_DOLLY_FACTOR, dollyX, dollyY);\n                    this._isUserControllingDolly = true;\n                }\n                else {\n                    this._zoomInternal(dollyDelta * TOUCH_DOLLY_FACTOR, dollyX, dollyY);\n                    this._isUserControllingZoom = true;\n                }\n            }\n            // truck\n            if ((this._state & ACTION.TRUCK) === ACTION.TRUCK ||\n                (this._state & ACTION.TOUCH_TRUCK) === ACTION.TOUCH_TRUCK ||\n                (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK ||\n                (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK) {\n                this._truckInternal(deltaX, deltaY, false, false);\n                this._isUserControllingTruck = true;\n            }\n            // screen-pan\n            if ((this._state & ACTION.SCREEN_PAN) === ACTION.SCREEN_PAN ||\n                (this._state & ACTION.TOUCH_SCREEN_PAN) === ACTION.TOUCH_SCREEN_PAN ||\n                (this._state & ACTION.TOUCH_DOLLY_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN ||\n                (this._state & ACTION.TOUCH_ZOOM_SCREEN_PAN) === ACTION.TOUCH_ZOOM_SCREEN_PAN) {\n                this._truckInternal(deltaX, deltaY, false, true);\n                this._isUserControllingTruck = true;\n            }\n            // offset\n            if ((this._state & ACTION.OFFSET) === ACTION.OFFSET ||\n                (this._state & ACTION.TOUCH_OFFSET) === ACTION.TOUCH_OFFSET ||\n                (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET ||\n                (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET) {\n                this._truckInternal(deltaX, deltaY, true, false);\n                this._isUserControllingOffset = true;\n            }\n            this.dispatchEvent({ type: 'control' });\n        };\n        const endDragging = () => {\n            extractClientCoordFromEvent(this._activePointers, _v2);\n            lastDragPosition.copy(_v2);\n            this._dragNeedsUpdate = false;\n            if (this._activePointers.length === 0 ||\n                (this._activePointers.length === 1 && this._activePointers[0] === this._lockedPointer)) {\n                this._isDragging = false;\n            }\n            if (this._activePointers.length === 0 && this._domElement) {\n                // eslint-disable-next-line no-undef\n                this._domElement.ownerDocument.removeEventListener('pointermove', onPointerMove, { passive: false });\n                this._domElement.ownerDocument.removeEventListener('pointerup', onPointerUp);\n                this.dispatchEvent({ type: 'controlend' });\n            }\n        };\n        this.lockPointer = () => {\n            if (!this._enabled || !this._domElement)\n                return;\n            this.cancel();\n            // Element.requestPointerLock is allowed to happen without any pointer active - create a faux one for compatibility with controls\n            this._lockedPointer = {\n                pointerId: -1,\n                clientX: 0,\n                clientY: 0,\n                deltaX: 0,\n                deltaY: 0,\n                mouseButton: null,\n            };\n            this._activePointers.push(this._lockedPointer);\n            // eslint-disable-next-line no-undef\n            this._domElement.ownerDocument.removeEventListener('pointermove', onPointerMove, { passive: false });\n            this._domElement.ownerDocument.removeEventListener('pointerup', onPointerUp);\n            this._domElement.requestPointerLock();\n            this._domElement.ownerDocument.addEventListener('pointerlockchange', onPointerLockChange);\n            this._domElement.ownerDocument.addEventListener('pointerlockerror', onPointerLockError);\n            this._domElement.ownerDocument.addEventListener('pointermove', onPointerMove, { passive: false });\n            this._domElement.ownerDocument.addEventListener('pointerup', onPointerUp);\n            startDragging();\n        };\n        this.unlockPointer = () => {\n            var _a, _b, _c;\n            if (this._lockedPointer !== null) {\n                this._disposePointer(this._lockedPointer);\n                this._lockedPointer = null;\n            }\n            (_a = this._domElement) === null || _a === void 0 ? void 0 : _a.ownerDocument.exitPointerLock();\n            (_b = this._domElement) === null || _b === void 0 ? void 0 : _b.ownerDocument.removeEventListener('pointerlockchange', onPointerLockChange);\n            (_c = this._domElement) === null || _c === void 0 ? void 0 : _c.ownerDocument.removeEventListener('pointerlockerror', onPointerLockError);\n            this.cancel();\n        };\n        const onPointerLockChange = () => {\n            const isPointerLockActive = this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement;\n            if (!isPointerLockActive)\n                this.unlockPointer();\n        };\n        const onPointerLockError = () => {\n            this.unlockPointer();\n        };\n        this._addAllEventListeners = (domElement) => {\n            this._domElement = domElement;\n            this._domElement.style.touchAction = 'none';\n            this._domElement.style.userSelect = 'none';\n            this._domElement.style.webkitUserSelect = 'none';\n            this._domElement.addEventListener('pointerdown', onPointerDown);\n            this._domElement.addEventListener('pointercancel', onPointerUp);\n            this._domElement.addEventListener('wheel', onMouseWheel, { passive: false });\n            this._domElement.addEventListener('contextmenu', onContextMenu);\n        };\n        this._removeAllEventListeners = () => {\n            if (!this._domElement)\n                return;\n            this._domElement.style.touchAction = '';\n            this._domElement.style.userSelect = '';\n            this._domElement.style.webkitUserSelect = '';\n            this._domElement.removeEventListener('pointerdown', onPointerDown);\n            this._domElement.removeEventListener('pointercancel', onPointerUp);\n            // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener#matching_event_listeners_for_removal\n            // > it's probably wise to use the same values used for the call to `addEventListener()` when calling `removeEventListener()`\n            // see https://github.com/microsoft/TypeScript/issues/32912#issuecomment-522142969\n            // eslint-disable-next-line no-undef\n            this._domElement.removeEventListener('wheel', onMouseWheel, { passive: false });\n            this._domElement.removeEventListener('contextmenu', onContextMenu);\n            // eslint-disable-next-line no-undef\n            this._domElement.ownerDocument.removeEventListener('pointermove', onPointerMove, { passive: false });\n            this._domElement.ownerDocument.removeEventListener('pointerup', onPointerUp);\n            this._domElement.ownerDocument.removeEventListener('pointerlockchange', onPointerLockChange);\n            this._domElement.ownerDocument.removeEventListener('pointerlockerror', onPointerLockError);\n        };\n        this.cancel = () => {\n            if (this._state === ACTION.NONE)\n                return;\n            this._state = ACTION.NONE;\n            this._activePointers.length = 0;\n            endDragging();\n        };\n        if (domElement)\n            this.connect(domElement);\n        this.update(0);\n    }\n    /**\n     * The camera to be controlled\n     * @category Properties\n     */\n    get camera() {\n        return this._camera;\n    }\n    set camera(camera) {\n        this._camera = camera;\n        this.updateCameraUp();\n        this._camera.updateProjectionMatrix();\n        this._updateNearPlaneCorners();\n        this._needsUpdate = true;\n    }\n    /**\n     * Whether or not the controls are enabled.\n     * `false` to disable user dragging/touch-move, but all methods works.\n     * @category Properties\n     */\n    get enabled() {\n        return this._enabled;\n    }\n    set enabled(enabled) {\n        this._enabled = enabled;\n        if (!this._domElement)\n            return;\n        if (enabled) {\n            this._domElement.style.touchAction = 'none';\n            this._domElement.style.userSelect = 'none';\n            this._domElement.style.webkitUserSelect = 'none';\n        }\n        else {\n            this.cancel();\n            this._domElement.style.touchAction = '';\n            this._domElement.style.userSelect = '';\n            this._domElement.style.webkitUserSelect = '';\n        }\n    }\n    /**\n     * Returns `true` if the controls are active updating.\n     * readonly value.\n     * @category Properties\n     */\n    get active() {\n        return !this._hasRested;\n    }\n    /**\n     * Getter for the current `ACTION`.\n     * readonly value.\n     * @category Properties\n     */\n    get currentAction() {\n        return this._state;\n    }\n    /**\n     * get/set Current distance.\n     * @category Properties\n     */\n    get distance() {\n        return this._spherical.radius;\n    }\n    set distance(distance) {\n        if (this._spherical.radius === distance &&\n            this._sphericalEnd.radius === distance)\n            return;\n        this._spherical.radius = distance;\n        this._sphericalEnd.radius = distance;\n        this._needsUpdate = true;\n    }\n    // horizontal angle\n    /**\n     * get/set the azimuth angle (horizontal) in radians.\n     * Every 360 degrees turn is added to `.azimuthAngle` value, which is accumulative.\n     * @category Properties\n     */\n    get azimuthAngle() {\n        return this._spherical.theta;\n    }\n    set azimuthAngle(azimuthAngle) {\n        if (this._spherical.theta === azimuthAngle &&\n            this._sphericalEnd.theta === azimuthAngle)\n            return;\n        this._spherical.theta = azimuthAngle;\n        this._sphericalEnd.theta = azimuthAngle;\n        this._needsUpdate = true;\n    }\n    // vertical angle\n    /**\n     * get/set the polar angle (vertical) in radians.\n     * @category Properties\n     */\n    get polarAngle() {\n        return this._spherical.phi;\n    }\n    set polarAngle(polarAngle) {\n        if (this._spherical.phi === polarAngle &&\n            this._sphericalEnd.phi === polarAngle)\n            return;\n        this._spherical.phi = polarAngle;\n        this._sphericalEnd.phi = polarAngle;\n        this._needsUpdate = true;\n    }\n    /**\n     * Whether camera position should be enclosed in the boundary or not.\n     * @category Properties\n     */\n    get boundaryEnclosesCamera() {\n        return this._boundaryEnclosesCamera;\n    }\n    set boundaryEnclosesCamera(boundaryEnclosesCamera) {\n        this._boundaryEnclosesCamera = boundaryEnclosesCamera;\n        this._needsUpdate = true;\n    }\n    /**\n     * Set drag-start, touches and wheel enable area in the domElement.\n     * each values are between `0` and `1` inclusive, where `0` is left/top and `1` is right/bottom of the screen.\n     * e.g. `{ x: 0, y: 0, width: 1, height: 1 }` for entire area.\n     * @category Properties\n     */\n    set interactiveArea(interactiveArea) {\n        this._interactiveArea.width = clamp(interactiveArea.width, 0, 1);\n        this._interactiveArea.height = clamp(interactiveArea.height, 0, 1);\n        this._interactiveArea.x = clamp(interactiveArea.x, 0, 1 - this._interactiveArea.width);\n        this._interactiveArea.y = clamp(interactiveArea.y, 0, 1 - this._interactiveArea.height);\n    }\n    /**\n     * Adds the specified event listener.\n     * Applicable event types (which is `K`) are:\n     * | Event name          | Timing |\n     * | ------------------- | ------ |\n     * | `'controlstart'`    | When the user starts to control the camera via mouse / touches.  |\n     * | `'control'`         | When the user controls the camera (dragging). |\n     * | `'controlend'`      | When the user ends to control the camera.  |\n     * | `'transitionstart'` | When any kind of transition starts, either user control or using a method with `enableTransition = true` |\n     * | `'update'`          | When the camera position is updated. |\n     * | `'wake'`            | When the camera starts moving. |\n     * | `'rest'`            | When the camera movement is below `.restThreshold` . |\n     * | `'sleep'`           | When the camera end moving. |\n     *\n     * 1. `mouseButtons.wheel` (Mouse wheel control) does not emit `'controlstart'` and `'controlend'`. `mouseButtons.wheel` uses scroll-event internally, and scroll-event happens intermittently. That means \"start\" and \"end\" cannot be detected.\n     * 2. Due to damping, `sleep` will usually fire a few seconds after the camera _appears_ to have stopped moving. If you want to do something (e.g. enable UI, perform another transition) at the point when the camera has stopped, you probably want the `rest` event. This can be fine tuned using the `.restThreshold` parameter. See the [Rest and Sleep Example](https://yomotsu.github.io/camera-controls/examples/rest-and-sleep.html).\n     *\n     * e.g.\n     * ```\n     * cameraControl.addEventListener( 'controlstart', myCallbackFunction );\n     * ```\n     * @param type event name\n     * @param listener handler function\n     * @category Methods\n     */\n    addEventListener(type, listener) {\n        super.addEventListener(type, listener);\n    }\n    /**\n     * Removes the specified event listener\n     * e.g.\n     * ```\n     * cameraControl.addEventListener( 'controlstart', myCallbackFunction );\n     * ```\n     * @param type event name\n     * @param listener handler function\n     * @category Methods\n     */\n    removeEventListener(type, listener) {\n        super.removeEventListener(type, listener);\n    }\n    /**\n     * Rotate azimuthal angle(horizontal) and polar angle(vertical).\n     * Every value is added to the current value.\n     * @param azimuthAngle Azimuth rotate angle. In radian.\n     * @param polarAngle Polar rotate angle. In radian.\n     * @param enableTransition Whether to move smoothly or immediately\n     * @category Methods\n     */\n    rotate(azimuthAngle, polarAngle, enableTransition = false) {\n        return this.rotateTo(this._sphericalEnd.theta + azimuthAngle, this._sphericalEnd.phi + polarAngle, enableTransition);\n    }\n    /**\n     * Rotate azimuthal angle(horizontal) to the given angle and keep the same polar angle(vertical) target.\n     *\n     * e.g.\n     * ```\n     * cameraControls.rotateAzimuthTo( 30 * THREE.MathUtils.DEG2RAD, true );\n     * ```\n     * @param azimuthAngle Azimuth rotate angle. In radian.\n     * @param enableTransition Whether to move smoothly or immediately\n     * @category Methods\n     */\n    rotateAzimuthTo(azimuthAngle, enableTransition = false) {\n        return this.rotateTo(azimuthAngle, this._sphericalEnd.phi, enableTransition);\n    }\n    /**\n     * Rotate polar angle(vertical) to the given angle and keep the same azimuthal angle(horizontal) target.\n     *\n     * e.g.\n     * ```\n     * cameraControls.rotatePolarTo( 30 * THREE.MathUtils.DEG2RAD, true );\n     * ```\n     * @param polarAngle Polar rotate angle. In radian.\n     * @param enableTransition Whether to move smoothly or immediately\n     * @category Methods\n     */\n    rotatePolarTo(polarAngle, enableTransition = false) {\n        return this.rotateTo(this._sphericalEnd.theta, polarAngle, enableTransition);\n    }\n    /**\n     * Rotate azimuthal angle(horizontal) and polar angle(vertical) to the given angle.\n     * Camera view will rotate over the orbit pivot absolutely:\n     *\n     * azimuthAngle\n     * ```\n     *       0\n     *         \\\n     * 90 -----+----- -90\n     *           \\\n     *           180\n     * ```\n     * | direction | angle                  |\n     * | --------- | ---------------------- |\n     * | front     | 0                     |\n     * | left      | 90 (`Math.PI / 2`)    |\n     * | right     | -90 (`- Math.PI / 2`) |\n     * | back      | 180 (`Math.PI`)       |\n     *\n     * polarAngle\n     * ```\n     *     180\n     *      |\n     *      90\n     *      |\n     *      0\n     * ```\n     * | direction            | angle                  |\n     * | -------------------- | ---------------------- |\n     * | top/sky              | 180 (`Math.PI`)       |\n     * | horizontal from view | 90 (`Math.PI / 2`)    |\n     * | bottom/floor         | 0                     |\n     *\n     * @param azimuthAngle Azimuth rotate angle to. In radian.\n     * @param polarAngle Polar rotate angle to. In radian.\n     * @param enableTransition  Whether to move smoothly or immediately\n     * @category Methods\n     */\n    rotateTo(azimuthAngle, polarAngle, enableTransition = false) {\n        this._isUserControllingRotate = false;\n        const theta = clamp(azimuthAngle, this.minAzimuthAngle, this.maxAzimuthAngle);\n        const phi = clamp(polarAngle, this.minPolarAngle, this.maxPolarAngle);\n        this._sphericalEnd.theta = theta;\n        this._sphericalEnd.phi = phi;\n        this._sphericalEnd.makeSafe();\n        this._needsUpdate = true;\n        if (!enableTransition) {\n            this._spherical.theta = this._sphericalEnd.theta;\n            this._spherical.phi = this._sphericalEnd.phi;\n        }\n        const resolveImmediately = !enableTransition ||\n            approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) &&\n                approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold);\n        return this._createOnRestPromise(resolveImmediately);\n    }\n    /**\n     * Dolly in/out camera position.\n     * @param distance Distance of dollyIn. Negative number for dollyOut.\n     * @param enableTransition Whether to move smoothly or immediately.\n     * @category Methods\n     */\n    dolly(distance, enableTransition = false) {\n        return this.dollyTo(this._sphericalEnd.radius - distance, enableTransition);\n    }\n    /**\n     * Dolly in/out camera position to given distance.\n     * @param distance Distance of dolly.\n     * @param enableTransition Whether to move smoothly or immediately.\n     * @category Methods\n     */\n    dollyTo(distance, enableTransition = false) {\n        this._isUserControllingDolly = false;\n        this._lastDollyDirection = DOLLY_DIRECTION.NONE;\n        this._changedDolly = 0;\n        return this._dollyToNoClamp(clamp(distance, this.minDistance, this.maxDistance), enableTransition);\n    }\n    _dollyToNoClamp(distance, enableTransition = false) {\n        const lastRadius = this._sphericalEnd.radius;\n        const hasCollider = this.colliderMeshes.length >= 1;\n        if (hasCollider) {\n            const maxDistanceByCollisionTest = this._collisionTest();\n            const isCollided = approxEquals(maxDistanceByCollisionTest, this._spherical.radius);\n            const isDollyIn = lastRadius > distance;\n            if (!isDollyIn && isCollided)\n                return Promise.resolve();\n            this._sphericalEnd.radius = Math.min(distance, maxDistanceByCollisionTest);\n        }\n        else {\n            this._sphericalEnd.radius = distance;\n        }\n        this._needsUpdate = true;\n        if (!enableTransition) {\n            this._spherical.radius = this._sphericalEnd.radius;\n        }\n        const resolveImmediately = !enableTransition || approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);\n        return this._createOnRestPromise(resolveImmediately);\n    }\n    /**\n     * Dolly in, but does not change the distance between the target and the camera, and moves the target position instead.\n     * Specify a negative value for dolly out.\n     * @param distance Distance of dolly.\n     * @param enableTransition Whether to move smoothly or immediately.\n     * @category Methods\n     */\n    dollyInFixed(distance, enableTransition = false) {\n        this._targetEnd.add(this._getCameraDirection(_cameraDirection).multiplyScalar(distance));\n        if (!enableTransition) {\n            this._target.copy(this._targetEnd);\n        }\n        const resolveImmediately = !enableTransition ||\n            approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) &&\n                approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) &&\n                approxEquals(this._target.z, this._targetEnd.z, this.restThreshold);\n        return this._createOnRestPromise(resolveImmediately);\n    }\n    /**\n     * Zoom in/out camera. The value is added to camera zoom.\n     * Limits set with `.minZoom` and `.maxZoom`\n     * @param zoomStep zoom scale\n     * @param enableTransition Whether to move smoothly or immediately\n     * @category Methods\n     */\n    zoom(zoomStep, enableTransition = false) {\n        return this.zoomTo(this._zoomEnd + zoomStep, enableTransition);\n    }\n    /**\n     * Zoom in/out camera to given scale. The value overwrites camera zoom.\n     * Limits set with .minZoom and .maxZoom\n     * @param zoom\n     * @param enableTransition\n     * @category Methods\n     */\n    zoomTo(zoom, enableTransition = false) {\n        this._isUserControllingZoom = false;\n        this._zoomEnd = clamp(zoom, this.minZoom, this.maxZoom);\n        this._needsUpdate = true;\n        if (!enableTransition) {\n            this._zoom = this._zoomEnd;\n        }\n        const resolveImmediately = !enableTransition || approxEquals(this._zoom, this._zoomEnd, this.restThreshold);\n        this._changedZoom = 0;\n        return this._createOnRestPromise(resolveImmediately);\n    }\n    /**\n     * @deprecated `pan()` has been renamed to `truck()`\n     * @category Methods\n     */\n    pan(x, y, enableTransition = false) {\n        console.warn('`pan` has been renamed to `truck`');\n        return this.truck(x, y, enableTransition);\n    }\n    /**\n     * Truck and pedestal camera using current azimuthal angle\n     * @param x Horizontal translate amount\n     * @param y Vertical translate amount\n     * @param enableTransition Whether to move smoothly or immediately\n     * @category Methods\n     */\n    truck(x, y, enableTransition = false) {\n        this._camera.updateMatrix();\n        _xColumn.setFromMatrixColumn(this._camera.matrix, 0);\n        _yColumn.setFromMatrixColumn(this._camera.matrix, 1);\n        _xColumn.multiplyScalar(x);\n        _yColumn.multiplyScalar(-y);\n        const offset = _v3A.copy(_xColumn).add(_yColumn);\n        const to = _v3B.copy(this._targetEnd).add(offset);\n        return this.moveTo(to.x, to.y, to.z, enableTransition);\n    }\n    /**\n     * Move forward / backward.\n     * @param distance Amount to move forward / backward. Negative value to move backward\n     * @param enableTransition Whether to move smoothly or immediately\n     * @category Methods\n     */\n    forward(distance, enableTransition = false) {\n        _v3A.setFromMatrixColumn(this._camera.matrix, 0);\n        _v3A.crossVectors(this._camera.up, _v3A);\n        _v3A.multiplyScalar(distance);\n        const to = _v3B.copy(this._targetEnd).add(_v3A);\n        return this.moveTo(to.x, to.y, to.z, enableTransition);\n    }\n    /**\n     * Move up / down.\n     * @param height Amount to move up / down. Negative value to move down\n     * @param enableTransition Whether to move smoothly or immediately\n     * @category Methods\n     */\n    elevate(height, enableTransition = false) {\n        _v3A.copy(this._camera.up).multiplyScalar(height);\n        return this.moveTo(this._targetEnd.x + _v3A.x, this._targetEnd.y + _v3A.y, this._targetEnd.z + _v3A.z, enableTransition);\n    }\n    /**\n     * Move target position to given point.\n     * @param x x coord to move center position\n     * @param y y coord to move center position\n     * @param z z coord to move center position\n     * @param enableTransition Whether to move smoothly or immediately\n     * @category Methods\n     */\n    moveTo(x, y, z, enableTransition = false) {\n        this._isUserControllingTruck = false;\n        const offset = _v3A.set(x, y, z).sub(this._targetEnd);\n        this._encloseToBoundary(this._targetEnd, offset, this.boundaryFriction);\n        this._needsUpdate = true;\n        if (!enableTransition) {\n            this._target.copy(this._targetEnd);\n        }\n        const resolveImmediately = !enableTransition ||\n            approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) &&\n                approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) &&\n                approxEquals(this._target.z, this._targetEnd.z, this.restThreshold);\n        return this._createOnRestPromise(resolveImmediately);\n    }\n    /**\n     * Look in the given point direction.\n     * @param x point x.\n     * @param y point y.\n     * @param z point z.\n     * @param enableTransition Whether to move smoothly or immediately.\n     * @returns Transition end promise\n     * @category Methods\n     */\n    lookInDirectionOf(x, y, z, enableTransition = false) {\n        const point = _v3A.set(x, y, z);\n        const direction = point.sub(this._targetEnd).normalize();\n        const position = direction.multiplyScalar(-this._sphericalEnd.radius).add(this._targetEnd);\n        return this.setPosition(position.x, position.y, position.z, enableTransition);\n    }\n    /**\n     * Fit the viewport to the box or the bounding box of the object, using the nearest axis. paddings are in unit.\n     * set `cover: true` to fill enter screen.\n     * e.g.\n     * ```\n     * cameraControls.fitToBox( myMesh );\n     * ```\n     * @param box3OrObject Axis aligned bounding box to fit the view.\n     * @param enableTransition Whether to move smoothly or immediately.\n     * @param options | `<object>` { cover: boolean, paddingTop: number, paddingLeft: number, paddingBottom: number, paddingRight: number }\n     * @returns Transition end promise\n     * @category Methods\n     */\n    fitToBox(box3OrObject, enableTransition, { cover = false, paddingLeft = 0, paddingRight = 0, paddingBottom = 0, paddingTop = 0 } = {}) {\n        const promises = [];\n        const aabb = box3OrObject.isBox3\n            ? _box3A.copy(box3OrObject)\n            : _box3A.setFromObject(box3OrObject);\n        if (aabb.isEmpty()) {\n            console.warn('camera-controls: fitTo() cannot be used with an empty box. Aborting');\n            Promise.resolve();\n        }\n        // round to closest axis ( forward | backward | right | left | top | bottom )\n        const theta = roundToStep(this._sphericalEnd.theta, PI_HALF);\n        const phi = roundToStep(this._sphericalEnd.phi, PI_HALF);\n        promises.push(this.rotateTo(theta, phi, enableTransition));\n        const normal = _v3A.setFromSpherical(this._sphericalEnd).normalize();\n        const rotation = _quaternionA.setFromUnitVectors(normal, _AXIS_Z);\n        const viewFromPolar = approxEquals(Math.abs(normal.y), 1);\n        if (viewFromPolar) {\n            rotation.multiply(_quaternionB.setFromAxisAngle(_AXIS_Y, theta));\n        }\n        rotation.multiply(this._yAxisUpSpaceInverse);\n        // make oriented bounding box\n        const bb = _box3B.makeEmpty();\n        // left bottom back corner\n        _v3B.copy(aabb.min).applyQuaternion(rotation);\n        bb.expandByPoint(_v3B);\n        // right bottom back corner\n        _v3B.copy(aabb.min).setX(aabb.max.x).applyQuaternion(rotation);\n        bb.expandByPoint(_v3B);\n        // left top back corner\n        _v3B.copy(aabb.min).setY(aabb.max.y).applyQuaternion(rotation);\n        bb.expandByPoint(_v3B);\n        // right top back corner\n        _v3B.copy(aabb.max).setZ(aabb.min.z).applyQuaternion(rotation);\n        bb.expandByPoint(_v3B);\n        // left bottom front corner\n        _v3B.copy(aabb.min).setZ(aabb.max.z).applyQuaternion(rotation);\n        bb.expandByPoint(_v3B);\n        // right bottom front corner\n        _v3B.copy(aabb.max).setY(aabb.min.y).applyQuaternion(rotation);\n        bb.expandByPoint(_v3B);\n        // left top front corner\n        _v3B.copy(aabb.max).setX(aabb.min.x).applyQuaternion(rotation);\n        bb.expandByPoint(_v3B);\n        // right top front corner\n        _v3B.copy(aabb.max).applyQuaternion(rotation);\n        bb.expandByPoint(_v3B);\n        // add padding\n        bb.min.x -= paddingLeft;\n        bb.min.y -= paddingBottom;\n        bb.max.x += paddingRight;\n        bb.max.y += paddingTop;\n        rotation.setFromUnitVectors(_AXIS_Z, normal);\n        if (viewFromPolar) {\n            rotation.premultiply(_quaternionB.invert());\n        }\n        rotation.premultiply(this._yAxisUpSpace);\n        const bbSize = bb.getSize(_v3A);\n        const center = bb.getCenter(_v3B).applyQuaternion(rotation);\n        if (isPerspectiveCamera(this._camera)) {\n            const distance = this.getDistanceToFitBox(bbSize.x, bbSize.y, bbSize.z, cover);\n            promises.push(this.moveTo(center.x, center.y, center.z, enableTransition));\n            promises.push(this.dollyTo(distance, enableTransition));\n            promises.push(this.setFocalOffset(0, 0, 0, enableTransition));\n        }\n        else if (isOrthographicCamera(this._camera)) {\n            const camera = this._camera;\n            const width = camera.right - camera.left;\n            const height = camera.top - camera.bottom;\n            const zoom = cover ? Math.max(width / bbSize.x, height / bbSize.y) : Math.min(width / bbSize.x, height / bbSize.y);\n            promises.push(this.moveTo(center.x, center.y, center.z, enableTransition));\n            promises.push(this.zoomTo(zoom, enableTransition));\n            promises.push(this.setFocalOffset(0, 0, 0, enableTransition));\n        }\n        return Promise.all(promises);\n    }\n    /**\n     * Fit the viewport to the sphere or the bounding sphere of the object.\n     * @param sphereOrMesh\n     * @param enableTransition\n     * @category Methods\n     */\n    fitToSphere(sphereOrMesh, enableTransition) {\n        const promises = [];\n        const isObject3D = 'isObject3D' in sphereOrMesh;\n        const boundingSphere = isObject3D ?\n            CameraControls.createBoundingSphere(sphereOrMesh, _sphere) :\n            _sphere.copy(sphereOrMesh);\n        promises.push(this.moveTo(boundingSphere.center.x, boundingSphere.center.y, boundingSphere.center.z, enableTransition));\n        if (isPerspectiveCamera(this._camera)) {\n            const distanceToFit = this.getDistanceToFitSphere(boundingSphere.radius);\n            promises.push(this.dollyTo(distanceToFit, enableTransition));\n        }\n        else if (isOrthographicCamera(this._camera)) {\n            const width = this._camera.right - this._camera.left;\n            const height = this._camera.top - this._camera.bottom;\n            const diameter = 2 * boundingSphere.radius;\n            const zoom = Math.min(width / diameter, height / diameter);\n            promises.push(this.zoomTo(zoom, enableTransition));\n        }\n        promises.push(this.setFocalOffset(0, 0, 0, enableTransition));\n        return Promise.all(promises);\n    }\n    /**\n     * Look at the `target` from the `position`.\n     * @param positionX\n     * @param positionY\n     * @param positionZ\n     * @param targetX\n     * @param targetY\n     * @param targetZ\n     * @param enableTransition\n     * @category Methods\n     */\n    setLookAt(positionX, positionY, positionZ, targetX, targetY, targetZ, enableTransition = false) {\n        this._isUserControllingRotate = false;\n        this._isUserControllingDolly = false;\n        this._isUserControllingTruck = false;\n        this._lastDollyDirection = DOLLY_DIRECTION.NONE;\n        this._changedDolly = 0;\n        const target = _v3B.set(targetX, targetY, targetZ);\n        const position = _v3A.set(positionX, positionY, positionZ);\n        this._targetEnd.copy(target);\n        this._sphericalEnd.setFromVector3(position.sub(target).applyQuaternion(this._yAxisUpSpace));\n        this.normalizeRotations();\n        this._needsUpdate = true;\n        if (!enableTransition) {\n            this._target.copy(this._targetEnd);\n            this._spherical.copy(this._sphericalEnd);\n        }\n        const resolveImmediately = !enableTransition ||\n            approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) &&\n                approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) &&\n                approxEquals(this._target.z, this._targetEnd.z, this.restThreshold) &&\n                approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) &&\n                approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) &&\n                approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);\n        return this._createOnRestPromise(resolveImmediately);\n    }\n    /**\n     * Similar to setLookAt, but it interpolates between two states.\n     * @param positionAX\n     * @param positionAY\n     * @param positionAZ\n     * @param targetAX\n     * @param targetAY\n     * @param targetAZ\n     * @param positionBX\n     * @param positionBY\n     * @param positionBZ\n     * @param targetBX\n     * @param targetBY\n     * @param targetBZ\n     * @param t\n     * @param enableTransition\n     * @category Methods\n     */\n    lerpLookAt(positionAX, positionAY, positionAZ, targetAX, targetAY, targetAZ, positionBX, positionBY, positionBZ, targetBX, targetBY, targetBZ, t, enableTransition = false) {\n        this._isUserControllingRotate = false;\n        this._isUserControllingDolly = false;\n        this._isUserControllingTruck = false;\n        this._lastDollyDirection = DOLLY_DIRECTION.NONE;\n        this._changedDolly = 0;\n        const targetA = _v3A.set(targetAX, targetAY, targetAZ);\n        const positionA = _v3B.set(positionAX, positionAY, positionAZ);\n        _sphericalA.setFromVector3(positionA.sub(targetA).applyQuaternion(this._yAxisUpSpace));\n        const targetB = _v3C.set(targetBX, targetBY, targetBZ);\n        const positionB = _v3B.set(positionBX, positionBY, positionBZ);\n        _sphericalB.setFromVector3(positionB.sub(targetB).applyQuaternion(this._yAxisUpSpace));\n        this._targetEnd.copy(targetA.lerp(targetB, t)); // tricky\n        const deltaTheta = _sphericalB.theta - _sphericalA.theta;\n        const deltaPhi = _sphericalB.phi - _sphericalA.phi;\n        const deltaRadius = _sphericalB.radius - _sphericalA.radius;\n        this._sphericalEnd.set(_sphericalA.radius + deltaRadius * t, _sphericalA.phi + deltaPhi * t, _sphericalA.theta + deltaTheta * t);\n        this.normalizeRotations();\n        this._needsUpdate = true;\n        if (!enableTransition) {\n            this._target.copy(this._targetEnd);\n            this._spherical.copy(this._sphericalEnd);\n        }\n        const resolveImmediately = !enableTransition ||\n            approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) &&\n                approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) &&\n                approxEquals(this._target.z, this._targetEnd.z, this.restThreshold) &&\n                approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) &&\n                approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) &&\n                approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);\n        return this._createOnRestPromise(resolveImmediately);\n    }\n    /**\n     * Set angle and distance by given position.\n     * An alias of `setLookAt()`, without target change. Thus keep gazing at the current target\n     * @param positionX\n     * @param positionY\n     * @param positionZ\n     * @param enableTransition\n     * @category Methods\n     */\n    setPosition(positionX, positionY, positionZ, enableTransition = false) {\n        return this.setLookAt(positionX, positionY, positionZ, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, enableTransition);\n    }\n    /**\n     * Set the target position where gaze at.\n     * An alias of `setLookAt()`, without position change. Thus keep the same position.\n     * @param targetX\n     * @param targetY\n     * @param targetZ\n     * @param enableTransition\n     * @category Methods\n     */\n    setTarget(targetX, targetY, targetZ, enableTransition = false) {\n        const pos = this.getPosition(_v3A);\n        const promise = this.setLookAt(pos.x, pos.y, pos.z, targetX, targetY, targetZ, enableTransition);\n        // see https://github.com/yomotsu/camera-controls/issues/335\n        this._sphericalEnd.phi = clamp(this._sphericalEnd.phi, this.minPolarAngle, this.maxPolarAngle);\n        return promise;\n    }\n    /**\n     * Set focal offset using the screen parallel coordinates. z doesn't affect in Orthographic as with Dolly.\n     * @param x\n     * @param y\n     * @param z\n     * @param enableTransition\n     * @category Methods\n     */\n    setFocalOffset(x, y, z, enableTransition = false) {\n        this._isUserControllingOffset = false;\n        this._focalOffsetEnd.set(x, y, z);\n        this._needsUpdate = true;\n        if (!enableTransition)\n            this._focalOffset.copy(this._focalOffsetEnd);\n        const resolveImmediately = !enableTransition ||\n            approxEquals(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) &&\n                approxEquals(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) &&\n                approxEquals(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold);\n        return this._createOnRestPromise(resolveImmediately);\n    }\n    /**\n     * Set orbit point without moving the camera.\n     * SHOULD NOT RUN DURING ANIMATIONS. `setOrbitPoint()` will immediately fix the positions.\n     * @param targetX\n     * @param targetY\n     * @param targetZ\n     * @category Methods\n     */\n    setOrbitPoint(targetX, targetY, targetZ) {\n        this._camera.updateMatrixWorld();\n        _xColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 0);\n        _yColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 1);\n        _zColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);\n        const position = _v3A.set(targetX, targetY, targetZ);\n        const distance = position.distanceTo(this._camera.position);\n        const cameraToPoint = position.sub(this._camera.position);\n        _xColumn.multiplyScalar(cameraToPoint.x);\n        _yColumn.multiplyScalar(cameraToPoint.y);\n        _zColumn.multiplyScalar(cameraToPoint.z);\n        _v3A.copy(_xColumn).add(_yColumn).add(_zColumn);\n        _v3A.z = _v3A.z + distance;\n        this.dollyTo(distance, false);\n        this.setFocalOffset(-_v3A.x, _v3A.y, -_v3A.z, false);\n        this.moveTo(targetX, targetY, targetZ, false);\n    }\n    /**\n     * Set the boundary box that encloses the target of the camera. box3 is in THREE.Box3\n     * @param box3\n     * @category Methods\n     */\n    setBoundary(box3) {\n        if (!box3) {\n            this._boundary.min.set(-Infinity, -Infinity, -Infinity);\n            this._boundary.max.set(Infinity, Infinity, Infinity);\n            this._needsUpdate = true;\n            return;\n        }\n        this._boundary.copy(box3);\n        this._boundary.clampPoint(this._targetEnd, this._targetEnd);\n        this._needsUpdate = true;\n    }\n    /**\n     * Set (or unset) the current viewport.\n     * Set this when you want to use renderer viewport and .dollyToCursor feature at the same time.\n     * @param viewportOrX\n     * @param y\n     * @param width\n     * @param height\n     * @category Methods\n     */\n    setViewport(viewportOrX, y, width, height) {\n        if (viewportOrX === null) { // null\n            this._viewport = null;\n            return;\n        }\n        this._viewport = this._viewport || new THREE.Vector4();\n        if (typeof viewportOrX === 'number') { // number\n            this._viewport.set(viewportOrX, y, width, height);\n        }\n        else { // Vector4\n            this._viewport.copy(viewportOrX);\n        }\n    }\n    /**\n     * Calculate the distance to fit the box.\n     * @param width box width\n     * @param height box height\n     * @param depth box depth\n     * @returns distance\n     * @category Methods\n     */\n    getDistanceToFitBox(width, height, depth, cover = false) {\n        if (notSupportedInOrthographicCamera(this._camera, 'getDistanceToFitBox'))\n            return this._spherical.radius;\n        const boundingRectAspect = width / height;\n        const fov = this._camera.getEffectiveFOV() * DEG2RAD;\n        const aspect = this._camera.aspect;\n        const heightToFit = (cover ? boundingRectAspect > aspect : boundingRectAspect < aspect) ? height : width / aspect;\n        return heightToFit * 0.5 / Math.tan(fov * 0.5) + depth * 0.5;\n    }\n    /**\n     * Calculate the distance to fit the sphere.\n     * @param radius sphere radius\n     * @returns distance\n     * @category Methods\n     */\n    getDistanceToFitSphere(radius) {\n        if (notSupportedInOrthographicCamera(this._camera, 'getDistanceToFitSphere'))\n            return this._spherical.radius;\n        // https://stackoverflow.com/a/44849975\n        const vFOV = this._camera.getEffectiveFOV() * DEG2RAD;\n        const hFOV = Math.atan(Math.tan(vFOV * 0.5) * this._camera.aspect) * 2;\n        const fov = 1 < this._camera.aspect ? vFOV : hFOV;\n        return radius / (Math.sin(fov * 0.5));\n    }\n    /**\n     * Returns the orbit center position, where the camera looking at.\n     * @param out The receiving Vector3 instance to copy the result\n     * @param receiveEndValue Whether receive the transition end coords or current. default is `true`\n     * @category Methods\n     */\n    getTarget(out, receiveEndValue = true) {\n        const _out = !!out && out.isVector3 ? out : new THREE.Vector3();\n        return _out.copy(receiveEndValue ? this._targetEnd : this._target);\n    }\n    /**\n     * Returns the camera position.\n     * @param out The receiving Vector3 instance to copy the result\n     * @param receiveEndValue Whether receive the transition end coords or current. default is `true`\n     * @category Methods\n     */\n    getPosition(out, receiveEndValue = true) {\n        const _out = !!out && out.isVector3 ? out : new THREE.Vector3();\n        return _out.setFromSpherical(receiveEndValue ? this._sphericalEnd : this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(receiveEndValue ? this._targetEnd : this._target);\n    }\n    /**\n     * Returns the spherical coordinates of the orbit.\n     * @param out The receiving Spherical instance to copy the result\n     * @param receiveEndValue Whether receive the transition end coords or current. default is `true`\n     * @category Methods\n     */\n    getSpherical(out, receiveEndValue = true) {\n        const _out = out || new THREE.Spherical();\n        return _out.copy(receiveEndValue ? this._sphericalEnd : this._spherical);\n    }\n    /**\n     * Returns the focal offset, which is how much the camera appears to be translated in screen parallel coordinates.\n     * @param out The receiving Vector3 instance to copy the result\n     * @param receiveEndValue Whether receive the transition end coords or current. default is `true`\n     * @category Methods\n     */\n    getFocalOffset(out, receiveEndValue = true) {\n        const _out = !!out && out.isVector3 ? out : new THREE.Vector3();\n        return _out.copy(receiveEndValue ? this._focalOffsetEnd : this._focalOffset);\n    }\n    /**\n     * Normalize camera azimuth angle rotation between 0 and 360 degrees.\n     * @category Methods\n     */\n    normalizeRotations() {\n        this._sphericalEnd.theta = this._sphericalEnd.theta % PI_2;\n        if (this._sphericalEnd.theta < 0)\n            this._sphericalEnd.theta += PI_2;\n        this._spherical.theta += PI_2 * Math.round((this._sphericalEnd.theta - this._spherical.theta) / PI_2);\n    }\n    /**\n     * stop all transitions.\n     */\n    stop() {\n        this._focalOffset.copy(this._focalOffsetEnd);\n        this._target.copy(this._targetEnd);\n        this._spherical.copy(this._sphericalEnd);\n        this._zoom = this._zoomEnd;\n    }\n    /**\n     * Reset all rotation and position to defaults.\n     * @param enableTransition\n     * @category Methods\n     */\n    reset(enableTransition = false) {\n        if (!approxEquals(this._camera.up.x, this._cameraUp0.x) ||\n            !approxEquals(this._camera.up.y, this._cameraUp0.y) ||\n            !approxEquals(this._camera.up.z, this._cameraUp0.z)) {\n            this._camera.up.copy(this._cameraUp0);\n            const position = this.getPosition(_v3A);\n            this.updateCameraUp();\n            this.setPosition(position.x, position.y, position.z);\n        }\n        const promises = [\n            this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, enableTransition),\n            this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, enableTransition),\n            this.zoomTo(this._zoom0, enableTransition),\n        ];\n        return Promise.all(promises);\n    }\n    /**\n     * Set current camera position as the default position.\n     * @category Methods\n     */\n    saveState() {\n        this._cameraUp0.copy(this._camera.up);\n        this.getTarget(this._target0);\n        this.getPosition(this._position0);\n        this._zoom0 = this._zoom;\n        this._focalOffset0.copy(this._focalOffset);\n    }\n    /**\n     * Sync camera-up direction.\n     * When camera-up vector is changed, `.updateCameraUp()` must be called.\n     * @category Methods\n     */\n    updateCameraUp() {\n        this._yAxisUpSpace.setFromUnitVectors(this._camera.up, _AXIS_Y);\n        this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert();\n    }\n    /**\n     * Apply current camera-up direction to the camera.\n     * The orbit system will be re-initialized with the current position.\n     * @category Methods\n     */\n    applyCameraUp() {\n        const cameraDirection = _v3A.subVectors(this._target, this._camera.position).normalize();\n        // So first find the vector off to the side, orthogonal to both this.object.up and\n        // the \"view\" vector.\n        const side = _v3B.crossVectors(cameraDirection, this._camera.up);\n        // Then find the vector orthogonal to both this \"side\" vector and the \"view\" vector.\n        // This vector will be the new \"up\" vector.\n        this._camera.up.crossVectors(side, cameraDirection).normalize();\n        this._camera.updateMatrixWorld();\n        const position = this.getPosition(_v3A);\n        this.updateCameraUp();\n        this.setPosition(position.x, position.y, position.z);\n    }\n    /**\n     * Update camera position and directions.\n     * This should be called in your tick loop every time, and returns true if re-rendering is needed.\n     * @param delta\n     * @returns updated\n     * @category Methods\n     */\n    update(delta) {\n        const deltaTheta = this._sphericalEnd.theta - this._spherical.theta;\n        const deltaPhi = this._sphericalEnd.phi - this._spherical.phi;\n        const deltaRadius = this._sphericalEnd.radius - this._spherical.radius;\n        const deltaTarget = _deltaTarget.subVectors(this._targetEnd, this._target);\n        const deltaOffset = _deltaOffset.subVectors(this._focalOffsetEnd, this._focalOffset);\n        const deltaZoom = this._zoomEnd - this._zoom;\n        // update theta\n        if (approxZero(deltaTheta)) {\n            this._thetaVelocity.value = 0;\n            this._spherical.theta = this._sphericalEnd.theta;\n        }\n        else {\n            const smoothTime = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;\n            this._spherical.theta = smoothDamp(this._spherical.theta, this._sphericalEnd.theta, this._thetaVelocity, smoothTime, Infinity, delta);\n            this._needsUpdate = true;\n        }\n        // update phi\n        if (approxZero(deltaPhi)) {\n            this._phiVelocity.value = 0;\n            this._spherical.phi = this._sphericalEnd.phi;\n        }\n        else {\n            const smoothTime = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;\n            this._spherical.phi = smoothDamp(this._spherical.phi, this._sphericalEnd.phi, this._phiVelocity, smoothTime, Infinity, delta);\n            this._needsUpdate = true;\n        }\n        // update distance\n        if (approxZero(deltaRadius)) {\n            this._radiusVelocity.value = 0;\n            this._spherical.radius = this._sphericalEnd.radius;\n        }\n        else {\n            const smoothTime = this._isUserControllingDolly ? this.draggingSmoothTime : this.smoothTime;\n            this._spherical.radius = smoothDamp(this._spherical.radius, this._sphericalEnd.radius, this._radiusVelocity, smoothTime, this.maxSpeed, delta);\n            this._needsUpdate = true;\n        }\n        // update target position\n        if (approxZero(deltaTarget.x) && approxZero(deltaTarget.y) && approxZero(deltaTarget.z)) {\n            this._targetVelocity.set(0, 0, 0);\n            this._target.copy(this._targetEnd);\n        }\n        else {\n            const smoothTime = this._isUserControllingTruck ? this.draggingSmoothTime : this.smoothTime;\n            smoothDampVec3(this._target, this._targetEnd, this._targetVelocity, smoothTime, this.maxSpeed, delta, this._target);\n            this._needsUpdate = true;\n        }\n        // update focalOffset\n        if (approxZero(deltaOffset.x) && approxZero(deltaOffset.y) && approxZero(deltaOffset.z)) {\n            this._focalOffsetVelocity.set(0, 0, 0);\n            this._focalOffset.copy(this._focalOffsetEnd);\n        }\n        else {\n            const smoothTime = this._isUserControllingOffset ? this.draggingSmoothTime : this.smoothTime;\n            smoothDampVec3(this._focalOffset, this._focalOffsetEnd, this._focalOffsetVelocity, smoothTime, this.maxSpeed, delta, this._focalOffset);\n            this._needsUpdate = true;\n        }\n        // update zoom\n        if (approxZero(deltaZoom)) {\n            this._zoomVelocity.value = 0;\n            this._zoom = this._zoomEnd;\n        }\n        else {\n            const smoothTime = this._isUserControllingZoom ? this.draggingSmoothTime : this.smoothTime;\n            this._zoom = smoothDamp(this._zoom, this._zoomEnd, this._zoomVelocity, smoothTime, Infinity, delta);\n        }\n        if (this.dollyToCursor) {\n            if (isPerspectiveCamera(this._camera) && this._changedDolly !== 0) {\n                const dollyControlAmount = this._spherical.radius - this._lastDistance;\n                const camera = this._camera;\n                const cameraDirection = this._getCameraDirection(_cameraDirection);\n                const planeX = _v3A.copy(cameraDirection).cross(camera.up).normalize();\n                if (planeX.lengthSq() === 0)\n                    planeX.x = 1.0;\n                const planeY = _v3B.crossVectors(planeX, cameraDirection);\n                const worldToScreen = this._sphericalEnd.radius * Math.tan(camera.getEffectiveFOV() * DEG2RAD * 0.5);\n                const prevRadius = this._sphericalEnd.radius - dollyControlAmount;\n                const lerpRatio = (prevRadius - this._sphericalEnd.radius) / this._sphericalEnd.radius;\n                const cursor = _v3C.copy(this._targetEnd)\n                    .add(planeX.multiplyScalar(this._dollyControlCoord.x * worldToScreen * camera.aspect))\n                    .add(planeY.multiplyScalar(this._dollyControlCoord.y * worldToScreen));\n                const newTargetEnd = _v3A.copy(this._targetEnd).lerp(cursor, lerpRatio);\n                const isMin = this._lastDollyDirection === DOLLY_DIRECTION.IN && this._spherical.radius <= this.minDistance;\n                const isMax = this._lastDollyDirection === DOLLY_DIRECTION.OUT && this.maxDistance <= this._spherical.radius;\n                if (this.infinityDolly && (isMin || isMax)) {\n                    this._sphericalEnd.radius -= dollyControlAmount;\n                    this._spherical.radius -= dollyControlAmount;\n                    const dollyAmount = _v3B.copy(cameraDirection).multiplyScalar(-dollyControlAmount);\n                    newTargetEnd.add(dollyAmount);\n                }\n                // target position may be moved beyond boundary.\n                this._boundary.clampPoint(newTargetEnd, newTargetEnd);\n                const targetEndDiff = _v3B.subVectors(newTargetEnd, this._targetEnd);\n                this._targetEnd.copy(newTargetEnd);\n                this._target.add(targetEndDiff);\n                this._changedDolly -= dollyControlAmount;\n                if (approxZero(this._changedDolly))\n                    this._changedDolly = 0;\n            }\n            else if (isOrthographicCamera(this._camera) && this._changedZoom !== 0) {\n                const dollyControlAmount = this._zoom - this._lastZoom;\n                const camera = this._camera;\n                const worldCursorPosition = _v3A.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);\n                const quaternion = _v3B.set(0, 0, -1).applyQuaternion(camera.quaternion);\n                const cursor = _v3C.copy(worldCursorPosition).add(quaternion.multiplyScalar(-worldCursorPosition.dot(camera.up)));\n                const prevZoom = this._zoom - dollyControlAmount;\n                const lerpRatio = -(prevZoom - this._zoom) / this._zoom;\n                // find the \"distance\" (aka plane constant in three.js) of Plane\n                // from a given position (this._targetEnd) and normal vector (cameraDirection)\n                // https://www.maplesoft.com/support/help/maple/view.aspx?path=MathApps%2FEquationOfAPlaneNormal#bkmrk0\n                const cameraDirection = this._getCameraDirection(_cameraDirection);\n                const prevPlaneConstant = this._targetEnd.dot(cameraDirection);\n                const newTargetEnd = _v3A.copy(this._targetEnd).lerp(cursor, lerpRatio);\n                const newPlaneConstant = newTargetEnd.dot(cameraDirection);\n                // Pull back the camera depth that has moved, to be the camera stationary as zoom\n                const pullBack = cameraDirection.multiplyScalar(newPlaneConstant - prevPlaneConstant);\n                newTargetEnd.sub(pullBack);\n                // target position may be moved beyond boundary.\n                this._boundary.clampPoint(newTargetEnd, newTargetEnd);\n                const targetEndDiff = _v3B.subVectors(newTargetEnd, this._targetEnd);\n                this._targetEnd.copy(newTargetEnd);\n                this._target.add(targetEndDiff);\n                // this._target.copy( this._targetEnd );\n                this._changedZoom -= dollyControlAmount;\n                if (approxZero(this._changedZoom))\n                    this._changedZoom = 0;\n            }\n        }\n        if (this._camera.zoom !== this._zoom) {\n            this._camera.zoom = this._zoom;\n            this._camera.updateProjectionMatrix();\n            this._updateNearPlaneCorners();\n            this._needsUpdate = true;\n        }\n        this._dragNeedsUpdate = true;\n        // collision detection\n        const maxDistance = this._collisionTest();\n        this._spherical.radius = Math.min(this._spherical.radius, maxDistance);\n        // decompose spherical to the camera position\n        this._spherical.makeSafe();\n        this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target);\n        this._camera.lookAt(this._target);\n        // set offset after the orbit movement\n        const affectOffset = !approxZero(this._focalOffset.x) ||\n            !approxZero(this._focalOffset.y) ||\n            !approxZero(this._focalOffset.z);\n        if (affectOffset) {\n            _xColumn.setFromMatrixColumn(this._camera.matrix, 0);\n            _yColumn.setFromMatrixColumn(this._camera.matrix, 1);\n            _zColumn.setFromMatrixColumn(this._camera.matrix, 2);\n            _xColumn.multiplyScalar(this._focalOffset.x);\n            _yColumn.multiplyScalar(-this._focalOffset.y);\n            _zColumn.multiplyScalar(this._focalOffset.z); // notice: z-offset will not affect in Orthographic.\n            _v3A.copy(_xColumn).add(_yColumn).add(_zColumn);\n            this._camera.position.add(_v3A);\n            this._camera.updateMatrixWorld();\n        }\n        if (this._boundaryEnclosesCamera) {\n            this._encloseToBoundary(this._camera.position.copy(this._target), _v3A.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1.0);\n        }\n        const updated = this._needsUpdate;\n        if (updated && !this._updatedLastTime) {\n            this._hasRested = false;\n            this.dispatchEvent({ type: 'wake' });\n            this.dispatchEvent({ type: 'update' });\n        }\n        else if (updated) {\n            this.dispatchEvent({ type: 'update' });\n            if (approxZero(deltaTheta, this.restThreshold) &&\n                approxZero(deltaPhi, this.restThreshold) &&\n                approxZero(deltaRadius, this.restThreshold) &&\n                approxZero(deltaTarget.x, this.restThreshold) &&\n                approxZero(deltaTarget.y, this.restThreshold) &&\n                approxZero(deltaTarget.z, this.restThreshold) &&\n                approxZero(deltaOffset.x, this.restThreshold) &&\n                approxZero(deltaOffset.y, this.restThreshold) &&\n                approxZero(deltaOffset.z, this.restThreshold) &&\n                approxZero(deltaZoom, this.restThreshold) &&\n                !this._hasRested) {\n                this._hasRested = true;\n                this.dispatchEvent({ type: 'rest' });\n            }\n        }\n        else if (!updated && this._updatedLastTime) {\n            this.dispatchEvent({ type: 'sleep' });\n        }\n        this._lastDistance = this._spherical.radius;\n        this._lastZoom = this._zoom;\n        this._updatedLastTime = updated;\n        this._needsUpdate = false;\n        return updated;\n    }\n    /**\n     * Get all state in JSON string\n     * @category Methods\n     */\n    toJSON() {\n        return JSON.stringify({\n            enabled: this._enabled,\n            minDistance: this.minDistance,\n            maxDistance: infinityToMaxNumber(this.maxDistance),\n            minZoom: this.minZoom,\n            maxZoom: infinityToMaxNumber(this.maxZoom),\n            minPolarAngle: this.minPolarAngle,\n            maxPolarAngle: infinityToMaxNumber(this.maxPolarAngle),\n            minAzimuthAngle: infinityToMaxNumber(this.minAzimuthAngle),\n            maxAzimuthAngle: infinityToMaxNumber(this.maxAzimuthAngle),\n            smoothTime: this.smoothTime,\n            draggingSmoothTime: this.draggingSmoothTime,\n            dollySpeed: this.dollySpeed,\n            truckSpeed: this.truckSpeed,\n            dollyToCursor: this.dollyToCursor,\n            target: this._targetEnd.toArray(),\n            position: _v3A.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),\n            zoom: this._zoomEnd,\n            focalOffset: this._focalOffsetEnd.toArray(),\n            target0: this._target0.toArray(),\n            position0: this._position0.toArray(),\n            zoom0: this._zoom0,\n            focalOffset0: this._focalOffset0.toArray(),\n        });\n    }\n    /**\n     * Reproduce the control state with JSON. enableTransition is where anim or not in a boolean.\n     * @param json\n     * @param enableTransition\n     * @category Methods\n     */\n    fromJSON(json, enableTransition = false) {\n        const obj = JSON.parse(json);\n        this.enabled = obj.enabled;\n        this.minDistance = obj.minDistance;\n        this.maxDistance = maxNumberToInfinity(obj.maxDistance);\n        this.minZoom = obj.minZoom;\n        this.maxZoom = maxNumberToInfinity(obj.maxZoom);\n        this.minPolarAngle = obj.minPolarAngle;\n        this.maxPolarAngle = maxNumberToInfinity(obj.maxPolarAngle);\n        this.minAzimuthAngle = maxNumberToInfinity(obj.minAzimuthAngle);\n        this.maxAzimuthAngle = maxNumberToInfinity(obj.maxAzimuthAngle);\n        this.smoothTime = obj.smoothTime;\n        this.draggingSmoothTime = obj.draggingSmoothTime;\n        this.dollySpeed = obj.dollySpeed;\n        this.truckSpeed = obj.truckSpeed;\n        this.dollyToCursor = obj.dollyToCursor;\n        this._target0.fromArray(obj.target0);\n        this._position0.fromArray(obj.position0);\n        this._zoom0 = obj.zoom0;\n        this._focalOffset0.fromArray(obj.focalOffset0);\n        this.moveTo(obj.target[0], obj.target[1], obj.target[2], enableTransition);\n        _sphericalA.setFromVector3(_v3A.fromArray(obj.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace));\n        this.rotateTo(_sphericalA.theta, _sphericalA.phi, enableTransition);\n        this.dollyTo(_sphericalA.radius, enableTransition);\n        this.zoomTo(obj.zoom, enableTransition);\n        this.setFocalOffset(obj.focalOffset[0], obj.focalOffset[1], obj.focalOffset[2], enableTransition);\n        this._needsUpdate = true;\n    }\n    /**\n     * Attach all internal event handlers to enable drag control.\n     * @category Methods\n     */\n    connect(domElement) {\n        if (this._domElement) {\n            console.warn('camera-controls is already connected.');\n            return;\n        }\n        domElement.setAttribute('data-camera-controls-version', VERSION);\n        this._addAllEventListeners(domElement);\n        this._getClientRect(this._elementRect);\n    }\n    /**\n     * Detach all internal event handlers to disable drag control.\n     */\n    disconnect() {\n        this.cancel();\n        this._removeAllEventListeners();\n        if (this._domElement) {\n            this._domElement.removeAttribute('data-camera-controls-version');\n            this._domElement = undefined;\n        }\n    }\n    /**\n     * Dispose the cameraControls instance itself, remove all eventListeners.\n     * @category Methods\n     */\n    dispose() {\n        // remove all user event listeners\n        this.removeAllEventListeners();\n        // remove all internal event listeners\n        this.disconnect();\n    }\n    // it's okay to expose public though\n    _getTargetDirection(out) {\n        // divide by distance to normalize, lighter than `Vector3.prototype.normalize()`\n        return out.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse);\n    }\n    // it's okay to expose public though\n    _getCameraDirection(out) {\n        return this._getTargetDirection(out).negate();\n    }\n    _findPointerById(pointerId) {\n        return this._activePointers.find((activePointer) => activePointer.pointerId === pointerId);\n    }\n    _findPointerByMouseButton(mouseButton) {\n        return this._activePointers.find((activePointer) => activePointer.mouseButton === mouseButton);\n    }\n    _disposePointer(pointer) {\n        this._activePointers.splice(this._activePointers.indexOf(pointer), 1);\n    }\n    _encloseToBoundary(position, offset, friction) {\n        const offsetLength2 = offset.lengthSq();\n        if (offsetLength2 === 0.0) { // sanity check\n            return position;\n        }\n        // See: https://twitter.com/FMS_Cat/status/1106508958640988161\n        const newTarget = _v3B.copy(offset).add(position); // target\n        const clampedTarget = this._boundary.clampPoint(newTarget, _v3C); // clamped target\n        const deltaClampedTarget = clampedTarget.sub(newTarget); // newTarget -> clampedTarget\n        const deltaClampedTargetLength2 = deltaClampedTarget.lengthSq(); // squared length of deltaClampedTarget\n        if (deltaClampedTargetLength2 === 0.0) { // when the position doesn't have to be clamped\n            return position.add(offset);\n        }\n        else if (deltaClampedTargetLength2 === offsetLength2) { // when the position is completely stuck\n            return position;\n        }\n        else if (friction === 0.0) {\n            return position.add(offset).add(deltaClampedTarget);\n        }\n        else {\n            const offsetFactor = 1.0 + friction * deltaClampedTargetLength2 / offset.dot(deltaClampedTarget);\n            return position\n                .add(_v3B.copy(offset).multiplyScalar(offsetFactor))\n                .add(deltaClampedTarget.multiplyScalar(1.0 - friction));\n        }\n    }\n    _updateNearPlaneCorners() {\n        if (isPerspectiveCamera(this._camera)) {\n            const camera = this._camera;\n            const near = camera.near;\n            const fov = camera.getEffectiveFOV() * DEG2RAD;\n            const heightHalf = Math.tan(fov * 0.5) * near; // near plain half height\n            const widthHalf = heightHalf * camera.aspect; // near plain half width\n            this._nearPlaneCorners[0].set(-widthHalf, -heightHalf, 0);\n            this._nearPlaneCorners[1].set(widthHalf, -heightHalf, 0);\n            this._nearPlaneCorners[2].set(widthHalf, heightHalf, 0);\n            this._nearPlaneCorners[3].set(-widthHalf, heightHalf, 0);\n        }\n        else if (isOrthographicCamera(this._camera)) {\n            const camera = this._camera;\n            const zoomInv = 1 / camera.zoom;\n            const left = camera.left * zoomInv;\n            const right = camera.right * zoomInv;\n            const top = camera.top * zoomInv;\n            const bottom = camera.bottom * zoomInv;\n            this._nearPlaneCorners[0].set(left, top, 0);\n            this._nearPlaneCorners[1].set(right, top, 0);\n            this._nearPlaneCorners[2].set(right, bottom, 0);\n            this._nearPlaneCorners[3].set(left, bottom, 0);\n        }\n    }\n    // lateUpdate\n    _collisionTest() {\n        let distance = Infinity;\n        const hasCollider = this.colliderMeshes.length >= 1;\n        if (!hasCollider)\n            return distance;\n        if (notSupportedInOrthographicCamera(this._camera, '_collisionTest'))\n            return distance;\n        const rayDirection = this._getTargetDirection(_cameraDirection);\n        _rotationMatrix.lookAt(_ORIGIN, rayDirection, this._camera.up);\n        for (let i = 0; i < 4; i++) {\n            const nearPlaneCorner = _v3B.copy(this._nearPlaneCorners[i]);\n            nearPlaneCorner.applyMatrix4(_rotationMatrix);\n            const origin = _v3C.addVectors(this._target, nearPlaneCorner);\n            _raycaster.set(origin, rayDirection);\n            _raycaster.far = this._spherical.radius + 1;\n            const intersects = _raycaster.intersectObjects(this.colliderMeshes);\n            if (intersects.length !== 0 && intersects[0].distance < distance) {\n                distance = intersects[0].distance;\n            }\n        }\n        return distance;\n    }\n    /**\n     * Get its client rect and package into given `DOMRect` .\n     */\n    _getClientRect(target) {\n        if (!this._domElement)\n            return;\n        const rect = this._domElement.getBoundingClientRect();\n        target.x = rect.left;\n        target.y = rect.top;\n        if (this._viewport) {\n            target.x += this._viewport.x;\n            target.y += rect.height - this._viewport.w - this._viewport.y;\n            target.width = this._viewport.z;\n            target.height = this._viewport.w;\n        }\n        else {\n            target.width = rect.width;\n            target.height = rect.height;\n        }\n        return target;\n    }\n    _createOnRestPromise(resolveImmediately) {\n        if (resolveImmediately)\n            return Promise.resolve();\n        this._hasRested = false;\n        this.dispatchEvent({ type: 'transitionstart' });\n        return new Promise((resolve) => {\n            const onResolve = () => {\n                this.removeEventListener('rest', onResolve);\n                resolve();\n            };\n            this.addEventListener('rest', onResolve);\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _addAllEventListeners(_domElement) { }\n    _removeAllEventListeners() { }\n    /**\n     * backward compatible\n     * @deprecated use smoothTime (in seconds) instead\n     * @category Properties\n     */\n    get dampingFactor() {\n        console.warn('.dampingFactor has been deprecated. use smoothTime (in seconds) instead.');\n        return 0;\n    }\n    /**\n     * backward compatible\n     * @deprecated use smoothTime (in seconds) instead\n     * @category Properties\n     */\n    set dampingFactor(_) {\n        console.warn('.dampingFactor has been deprecated. use smoothTime (in seconds) instead.');\n    }\n    /**\n     * backward compatible\n     * @deprecated use draggingSmoothTime (in seconds) instead\n     * @category Properties\n     */\n    get draggingDampingFactor() {\n        console.warn('.draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.');\n        return 0;\n    }\n    /**\n     * backward compatible\n     * @deprecated use draggingSmoothTime (in seconds) instead\n     * @category Properties\n     */\n    set draggingDampingFactor(_) {\n        console.warn('.draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.');\n    }\n    static createBoundingSphere(object3d, out = new THREE.Sphere()) {\n        const boundingSphere = out;\n        const center = boundingSphere.center;\n        _box3A.makeEmpty();\n        // find the center\n        object3d.traverseVisible((object) => {\n            if (!object.isMesh)\n                return;\n            _box3A.expandByObject(object);\n        });\n        _box3A.getCenter(center);\n        // find the radius\n        let maxRadiusSq = 0;\n        object3d.traverseVisible((object) => {\n            if (!object.isMesh)\n                return;\n            const mesh = object;\n            if (!mesh.geometry)\n                return;\n            const geometry = mesh.geometry.clone();\n            geometry.applyMatrix4(mesh.matrixWorld);\n            const bufferGeometry = geometry;\n            const position = bufferGeometry.attributes.position;\n            for (let i = 0, l = position.count; i < l; i++) {\n                _v3A.fromBufferAttribute(position, i);\n                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_v3A));\n            }\n        });\n        boundingSphere.radius = Math.sqrt(maxRadiusSq);\n        return boundingSphere;\n    }\n}\n\nexport { EventDispatcher, CameraControls as default };\n","var oe = Object.defineProperty;\nvar re = (s, e, t) => e in s ? oe(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : s[e] = t;\nvar m = (s, e, t) => re(s, typeof e != \"symbol\" ? e + \"\" : e, t);\nimport { Vector3 as U, Vector2 as Q, Raycaster as ae, Object3D as ft, Color as Vt, CanvasTexture as ce, RepeatWrapping as zt, SRGBColorSpace as le, BufferGeometry as Xt, BufferAttribute as nt, Sprite as bt, SpriteMaterial as St, Mesh as V, MeshBasicMaterial as at, BackSide as de, SphereGeometry as ue, InstancedBufferGeometry as he, Float32BufferAttribute as Bt, InstancedInterleavedBuffer as pt, InterleavedBufferAttribute as N, WireframeGeometry as fe, Box3 as xt, Sphere as Zt, ShaderMaterial as pe, ShaderLib as it, UniformsUtils as $t, UniformsLib as st, Vector4 as X, Line3 as me, Matrix4 as Yt, MathUtils as ge, Clock as ye, Quaternion as ct, Scene as _e, OrthographicCamera as ve, PerspectiveCamera as we, Spherical as be } from \"three\";\nconst Qt = (s, e) => {\n  const [t, n] = e.split(\"-\");\n  return Object.assign(s.style, {\n    left: n === \"left\" ? \"0\" : n === \"center\" ? \"50%\" : \"\",\n    right: n === \"right\" ? \"0\" : \"\",\n    top: t === \"top\" ? \"0\" : t === \"bottom\" ? \"\" : \"50%\",\n    bottom: t === \"bottom\" ? \"0\" : \"\",\n    transform: `${n === \"center\" ? \"translateX(-50%)\" : \"\"} ${t === \"center\" ? \"translateY(-50%)\" : \"\"}`\n  }), e;\n}, Se = ({\n  placement: s,\n  size: e,\n  offset: t,\n  id: n,\n  className: i\n}) => {\n  const o = document.createElement(\"div\"), { top: a, left: l, right: d, bottom: h } = t;\n  return Object.assign(o.style, {\n    id: n,\n    position: \"absolute\",\n    zIndex: \"1000\",\n    height: `${e}px`,\n    width: `${e}px`,\n    margin: `${a}px ${d}px ${h}px ${l}px`,\n    borderRadius: \"100%\"\n  }), Qt(o, s), n && (o.id = n), i && (o.className = i), o;\n}, xe = (s) => {\n  const e = typeof s == \"string\" ? document.querySelector(s) : s;\n  if (!e) throw Error(\"Invalid DOM element\");\n  return e;\n};\nfunction mt(s, e, t) {\n  return Math.max(e, Math.min(t, s));\n}\nconst Ee = [\n  [\"x\", 0, 3],\n  [\"y\", 1, 4],\n  [\"z\", 2, 5]\n], Ct = /* @__PURE__ */ new U();\nfunction Ot({ isSphere: s }, e, t) {\n  s && (Ct.set(0, 0, 1).applyQuaternion(t.quaternion), Ee.forEach(([n, i, o]) => {\n    const a = Ct[n];\n    let l = e[i], d = l.userData.opacity;\n    l.material.opacity = mt(a >= 0 ? d : d / 2, 0, 1), l = e[o], d = l.userData.opacity, l.material.opacity = mt(a >= 0 ? d / 2 : d, 0, 1);\n  }));\n}\nconst Ae = (s, e, t = 10) => Math.abs(s.clientX - e.x) < t && Math.abs(s.clientY - e.y) < t, Dt = /* @__PURE__ */ new ae(), Pt = /* @__PURE__ */ new Q(), Gt = (s, e, t, n) => {\n  Pt.set(\n    (s.clientX - e.left) / e.width * 2 - 1,\n    -((s.clientY - e.top) / e.height) * 2 + 1\n  ), Dt.setFromCamera(Pt, t);\n  const i = Dt.intersectObjects(\n    n,\n    !1\n  ), o = i.length ? i[0] : null;\n  return !o || !o.object.visible ? null : o;\n}, lt = 1e-6, Me = 2 * Math.PI, Jt = [\"x\", \"y\", \"z\"], Y = [...Jt, \"nx\", \"ny\", \"nz\"], Te = [\"x\", \"z\", \"y\", \"nx\", \"nz\", \"ny\"], Ue = [\"z\", \"x\", \"y\", \"nz\", \"nx\", \"ny\"], gt = \"Right\", ot = \"Top\", yt = \"Front\", _t = \"Left\", rt = \"Bottom\", vt = \"Back\", Le = [\n  gt,\n  ot,\n  yt,\n  _t,\n  rt,\n  vt\n].map((s) => s.toLocaleLowerCase()), Kt = 1.3, Rt = (s, e = !0) => {\n  const { material: t, userData: n } = s, { color: i, opacity: o } = e ? n.hover : n;\n  t.color.set(i), t.opacity = o;\n}, k = (s) => JSON.parse(JSON.stringify(s)), ze = (s) => {\n  const e = s.type || \"sphere\", t = e === \"sphere\", n = s.resolution || t ? 64 : 128, i = ft.DEFAULT_UP, o = i.z === 1, a = i.x === 1, { container: l } = s;\n  s.container = void 0, s = JSON.parse(JSON.stringify(s)), s.container = l;\n  const d = o ? Te : a ? Ue : Y;\n  Le.forEach((c, f) => {\n    s[c] && (s[d[f]] = s[c]);\n  });\n  const h = {\n    enabled: !0,\n    color: 16777215,\n    opacity: 1,\n    scale: 0.7,\n    labelColor: 2236962,\n    line: !1,\n    border: {\n      size: 0,\n      color: 14540253\n    },\n    hover: {\n      color: t ? 16777215 : 9688043,\n      labelColor: 2236962,\n      opacity: 1,\n      scale: 0.7,\n      border: {\n        size: 0,\n        color: 14540253\n      }\n    }\n  }, r = {\n    line: !1,\n    scale: t ? 0.45 : 0.7,\n    hover: {\n      scale: t ? 0.5 : 0.7\n    }\n  }, u = {\n    type: e,\n    container: document.body,\n    size: 128,\n    placement: \"top-right\",\n    resolution: n,\n    lineWidth: 4,\n    radius: t ? 1 : 0.2,\n    smoothness: 18,\n    animated: !0,\n    speed: 1,\n    background: {\n      enabled: !0,\n      color: t ? 16777215 : 14739180,\n      opacity: t ? 0 : 1,\n      hover: {\n        color: t ? 16777215 : 14739180,\n        opacity: t ? 0.2 : 1\n      }\n    },\n    font: {\n      family: \"sans-serif\",\n      weight: 900\n    },\n    offset: {\n      top: 10,\n      left: 10,\n      bottom: 10,\n      right: 10\n    },\n    corners: {\n      enabled: !t,\n      color: t ? 15915362 : 16777215,\n      opacity: 1,\n      scale: t ? 0.15 : 0.2,\n      radius: 1,\n      smoothness: 18,\n      hover: {\n        color: t ? 16777215 : 9688043,\n        opacity: 1,\n        scale: t ? 0.2 : 0.225\n      }\n    },\n    edges: {\n      enabled: !t,\n      color: t ? 15915362 : 16777215,\n      opacity: t ? 1 : 0,\n      radius: t ? 1 : 0.125,\n      smoothness: 18,\n      scale: t ? 0.15 : 1,\n      hover: {\n        color: t ? 16777215 : 9688043,\n        opacity: 1,\n        scale: t ? 0.2 : 1\n      }\n    },\n    x: {\n      ...k(h),\n      ...t ? { label: \"X\", color: 16725587, line: !0 } : { label: a ? ot : gt }\n    },\n    y: {\n      ...k(h),\n      ...t ? { label: \"Y\", color: 9100032, line: !0 } : { label: o || a ? yt : ot }\n    },\n    z: {\n      ...k(h),\n      ...t ? { label: \"Z\", color: 2920447, line: !0 } : {\n        label: o ? ot : a ? gt : yt\n      }\n    },\n    nx: {\n      ...k(r),\n      label: t ? \"\" : a ? rt : _t\n    },\n    ny: {\n      ...k(r),\n      label: t ? \"\" : o || a ? vt : rt\n    },\n    nz: {\n      ...k(r),\n      label: t ? \"\" : o ? rt : a ? _t : vt\n    }\n  };\n  return wt(s, u), Jt.forEach(\n    (c) => wt(\n      s[`n${c}`],\n      k(s[c])\n    )\n  ), { ...s, isSphere: t };\n};\nfunction wt(s, ...e) {\n  if (s instanceof HTMLElement || typeof s != \"object\" || s === null)\n    return s;\n  for (const t of e)\n    for (const n in t)\n      n !== \"container\" && n in t && (s[n] === void 0 ? s[n] = t[n] : typeof t[n] == \"object\" && !Array.isArray(t[n]) && (s[n] = wt(\n        s[n] || {},\n        t[n]\n      )));\n  return s;\n}\nconst Be = (s, e = 2) => {\n  const t = new Vt(), n = e * 2, { isSphere: i, resolution: o, radius: a, font: l, corners: d, edges: h } = s, r = Y.map((p) => ({ ...s[p], radius: a }));\n  i && d.enabled && r.push(d), i && h.enabled && r.push(h);\n  const u = document.createElement(\"canvas\"), c = u.getContext(\"2d\");\n  u.width = o * 2 + n * 2, u.height = o * r.length + n * r.length;\n  const [f, y] = Z(r, o, l);\n  r.forEach(\n    ({\n      radius: p,\n      label: x,\n      color: I,\n      labelColor: _,\n      border: b,\n      hover: {\n        color: F,\n        labelColor: B,\n        border: C\n      }\n    }, G) => {\n      const R = o * G + G * n + e;\n      L(\n        e,\n        R,\n        e,\n        o,\n        p,\n        x,\n        b,\n        I,\n        _\n      ), L(\n        o + e * 3,\n        R,\n        e,\n        o,\n        p,\n        x,\n        C ?? b,\n        F ?? I,\n        B ?? _\n      );\n    }\n  );\n  const v = r.length, g = e / (o * 2), S = e / (o * 6), w = 1 / v, E = new ce(u);\n  return E.repeat.set(0.5 - 2 * g, w - 2 * S), E.offset.set(g, 1 - S), Object.assign(E, {\n    colorSpace: le,\n    wrapS: zt,\n    wrapT: zt,\n    userData: {\n      offsetX: g,\n      offsetY: S,\n      cellHeight: w\n    }\n  }), E;\n  function L(p, x, I, _, b, F, B, C, G) {\n    if (b = b * (_ / 2), C != null && C !== \"\" && (R(), c.fillStyle = t.set(C).getStyle(), c.fill()), B && B.size) {\n      const W = B.size * _ / 2;\n      p += W, x += W, _ -= B.size * _, b = Math.max(0, b - W), R(), c.strokeStyle = t.set(B.color).getStyle(), c.lineWidth = B.size * _, c.stroke();\n    }\n    F && z(\n      c,\n      p + _ / 2,\n      x + (_ + I) / 2,\n      F,\n      t.set(G).getStyle()\n    );\n    function R() {\n      c.beginPath(), c.moveTo(p + b, x), c.lineTo(p + _ - b, x), c.arcTo(p + _, x, p + _, x + b, b), c.lineTo(p + _, x + _ - b), c.arcTo(p + _, x + _, p + _ - b, x + _, b), c.lineTo(p + b, x + _), c.arcTo(p, x + _, p, x + _ - b, b), c.lineTo(p, x + b), c.arcTo(p, x, p + b, x, b), c.closePath();\n    }\n  }\n  function Z(p, x, I) {\n    const b = [...p].sort((J, se) => {\n      var Ut, Lt;\n      return (((Ut = J.label) == null ? void 0 : Ut.length) || 0) - (((Lt = se.label) == null ? void 0 : Lt.length) || 0);\n    }).pop().label, { family: F, weight: B } = I, C = i ? Math.sqrt(Math.pow(x * 0.7, 2) / 2) : x;\n    let G = C, R = 0, W = 0;\n    do {\n      c.font = `${B} ${G}px ${F}`;\n      const J = c.measureText(b);\n      R = J.width, W = J.fontBoundingBoxDescent, G--;\n    } while (R > C && G > 0);\n    const Tt = C / W, ne = Math.min(C / R, Tt), ie = Math.floor(G * ne);\n    return [`${B} ${ie}px ${F}`, Tt];\n  }\n  function z(p, x, I, _, b) {\n    p.font = f, p.textAlign = \"center\", p.textBaseline = \"middle\", p.fillStyle = b, p.fillText(_, x, I + (i ? y : 0));\n  }\n}, Ce = (s, e) => s.offset.x = (e ? 0.5 : 0) + s.userData.offsetX, Et = (s, e) => {\n  const {\n    offset: t,\n    userData: { offsetY: n, cellHeight: i }\n  } = s;\n  t.y = 1 - (e + 1) * i + n;\n};\nfunction At(s, e, t = 2, n = 2) {\n  const i = t / 2 - s, o = n / 2 - s, a = s / t, l = (t - s) / t, d = s / n, h = (n - s) / n, r = [i, o, 0, -i, o, 0, -i, -o, 0, i, -o, 0], u = [l, h, a, h, a, d, l, d], c = [\n    3 * (e + 1) + 3,\n    3 * (e + 1) + 4,\n    e + 4,\n    e + 5,\n    2 * (e + 1) + 4,\n    2,\n    1,\n    2 * (e + 1) + 3,\n    3,\n    4 * (e + 1) + 3,\n    4,\n    0\n  ], f = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11].map(\n    (z) => c[z]\n  );\n  let y, v, g, S, w, E, L, Z;\n  for (let z = 0; z < 4; z++) {\n    S = z < 1 || z > 2 ? i : -i, w = z < 2 ? o : -o, E = z < 1 || z > 2 ? l : a, L = z < 2 ? h : d;\n    for (let p = 0; p <= e; p++)\n      y = Math.PI / 2 * (z + p / e), v = Math.cos(y), g = Math.sin(y), r.push(S + s * v, w + s * g, 0), u.push(E + a * v, L + d * g), p < e && (Z = (e + 1) * z + p + 4, f.push(z, Z, Z + 1));\n  }\n  return new Xt().setIndex(new nt(new Uint32Array(f), 1)).setAttribute(\n    \"position\",\n    new nt(new Float32Array(r), 3)\n  ).setAttribute(\"uv\", new nt(new Float32Array(u), 2));\n}\nconst Oe = (s, e) => {\n  const t = new U(), { isSphere: n, radius: i, smoothness: o } = s, a = At(i, o);\n  return Y.map((l, d) => {\n    const h = d < 3, r = Y[d], u = d ? e.clone() : e;\n    Et(u, d);\n    const { enabled: c, scale: f, opacity: y, hover: v } = s[r], g = {\n      map: u,\n      opacity: y,\n      transparent: !0\n    }, S = n ? new bt(new St(g)) : new V(a, new at(g)), w = h ? r : r[1];\n    return S.position[w] = (h ? 1 : -1) * (n ? Kt : 1), n || S.lookAt(t.copy(S.position).multiplyScalar(1.7)), S.scale.setScalar(f), S.renderOrder = 1, S.visible = c, S.userData = {\n      scale: f,\n      opacity: y,\n      hover: v\n    }, S;\n  });\n}, De = (s, e) => {\n  const { isSphere: t, corners: n } = s;\n  if (!n.enabled) return [];\n  const { color: i, opacity: o, scale: a, radius: l, smoothness: d, hover: h } = n, r = t ? null : At(l, d), u = {\n    transparent: !0,\n    opacity: o\n  }, c = [\n    1,\n    1,\n    1,\n    -1,\n    1,\n    1,\n    1,\n    -1,\n    1,\n    -1,\n    -1,\n    1,\n    1,\n    1,\n    -1,\n    -1,\n    1,\n    -1,\n    1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1\n  ].map((y) => y * 0.85), f = new U();\n  return Array(c.length / 3).fill(0).map((y, v) => {\n    if (t) {\n      const w = e.clone();\n      Et(w, 6), u.map = w;\n    } else\n      u.color = i;\n    const g = t ? new bt(new St(u)) : new V(r, new at(u)), S = v * 3;\n    return g.position.set(c[S], c[S + 1], c[S + 2]), t && g.position.normalize().multiplyScalar(1.7), g.scale.setScalar(a), g.lookAt(f.copy(g.position).multiplyScalar(2)), g.renderOrder = 1, g.userData = {\n      color: i,\n      opacity: o,\n      scale: a,\n      hover: h\n    }, g;\n  });\n}, Pe = (s, e, t) => {\n  const { isSphere: n, edges: i } = s;\n  if (!i.enabled) return [];\n  const { color: o, opacity: a, scale: l, hover: d, radius: h, smoothness: r } = i, u = n ? null : At(h, r, 1.2, 0.25), c = {\n    transparent: !0,\n    opacity: a\n  }, f = [\n    0,\n    1,\n    1,\n    0,\n    -1,\n    1,\n    1,\n    0,\n    1,\n    -1,\n    0,\n    1,\n    0,\n    1,\n    -1,\n    0,\n    -1,\n    -1,\n    1,\n    0,\n    -1,\n    -1,\n    0,\n    -1,\n    1,\n    1,\n    0,\n    1,\n    -1,\n    0,\n    -1,\n    1,\n    0,\n    -1,\n    -1,\n    0\n  ].map((g) => g * 0.925), y = new U(), v = new U(0, 1, 0);\n  return Array(f.length / 3).fill(0).map((g, S) => {\n    if (n) {\n      const L = e.clone();\n      Et(L, t), c.map = L;\n    } else\n      c.color = o;\n    const w = n ? new bt(new St(c)) : new V(u, new at(c)), E = S * 3;\n    return w.position.set(f[E], f[E + 1], f[E + 2]), n && w.position.normalize().multiplyScalar(1.7), w.scale.setScalar(l), w.up.copy(v), w.lookAt(y.copy(w.position).multiplyScalar(2)), !n && !w.position.y && (w.rotation.z = Math.PI / 2), w.renderOrder = 1, w.userData = {\n      color: o,\n      opacity: a,\n      scale: l,\n      hover: d\n    }, w;\n  });\n};\nfunction Ge(s, e = !1) {\n  const t = s[0].index !== null, n = new Set(Object.keys(s[0].attributes)), i = new Set(Object.keys(s[0].morphAttributes)), o = {}, a = {}, l = s[0].morphTargetsRelative, d = new Xt();\n  let h = 0;\n  for (let r = 0; r < s.length; ++r) {\n    const u = s[r];\n    let c = 0;\n    if (t !== (u.index !== null))\n      return console.error(\"THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index \" + r + \". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.\"), null;\n    for (const f in u.attributes) {\n      if (!n.has(f))\n        return console.error(\"THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index \" + r + '. All geometries must have compatible attributes; make sure \"' + f + '\" attribute exists among all geometries, or in none of them.'), null;\n      o[f] === void 0 && (o[f] = []), o[f].push(u.attributes[f]), c++;\n    }\n    if (c !== n.size)\n      return console.error(\"THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index \" + r + \". Make sure all geometries have the same number of attributes.\"), null;\n    if (l !== u.morphTargetsRelative)\n      return console.error(\"THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index \" + r + \". .morphTargetsRelative must be consistent throughout all geometries.\"), null;\n    for (const f in u.morphAttributes) {\n      if (!i.has(f))\n        return console.error(\"THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index \" + r + \".  .morphAttributes must be consistent throughout all geometries.\"), null;\n      a[f] === void 0 && (a[f] = []), a[f].push(u.morphAttributes[f]);\n    }\n    if (e) {\n      let f;\n      if (t)\n        f = u.index.count;\n      else if (u.attributes.position !== void 0)\n        f = u.attributes.position.count;\n      else\n        return console.error(\"THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index \" + r + \". The geometry must have either an index or a position attribute\"), null;\n      d.addGroup(h, f, r), h += f;\n    }\n  }\n  if (t) {\n    let r = 0;\n    const u = [];\n    for (let c = 0; c < s.length; ++c) {\n      const f = s[c].index;\n      for (let y = 0; y < f.count; ++y)\n        u.push(f.getX(y) + r);\n      r += s[c].attributes.position.count;\n    }\n    d.setIndex(u);\n  }\n  for (const r in o) {\n    const u = It(o[r]);\n    if (!u)\n      return console.error(\"THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the \" + r + \" attribute.\"), null;\n    d.setAttribute(r, u);\n  }\n  for (const r in a) {\n    const u = a[r][0].length;\n    if (u === 0) break;\n    d.morphAttributes = d.morphAttributes || {}, d.morphAttributes[r] = [];\n    for (let c = 0; c < u; ++c) {\n      const f = [];\n      for (let v = 0; v < a[r].length; ++v)\n        f.push(a[r][v][c]);\n      const y = It(f);\n      if (!y)\n        return console.error(\"THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the \" + r + \" morphAttribute.\"), null;\n      d.morphAttributes[r].push(y);\n    }\n  }\n  return d;\n}\nfunction It(s) {\n  let e, t, n, i = -1, o = 0;\n  for (let h = 0; h < s.length; ++h) {\n    const r = s[h];\n    if (e === void 0 && (e = r.array.constructor), e !== r.array.constructor)\n      return console.error(\"THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.\"), null;\n    if (t === void 0 && (t = r.itemSize), t !== r.itemSize)\n      return console.error(\"THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.\"), null;\n    if (n === void 0 && (n = r.normalized), n !== r.normalized)\n      return console.error(\"THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.\"), null;\n    if (i === -1 && (i = r.gpuType), i !== r.gpuType)\n      return console.error(\"THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.\"), null;\n    o += r.count * t;\n  }\n  const a = new e(o), l = new nt(a, t, n);\n  let d = 0;\n  for (let h = 0; h < s.length; ++h) {\n    const r = s[h];\n    if (r.isInterleavedBufferAttribute) {\n      const u = d / t;\n      for (let c = 0, f = r.count; c < f; c++)\n        for (let y = 0; y < t; y++) {\n          const v = r.getComponent(c, y);\n          l.setComponent(c + u, y, v);\n        }\n    } else\n      a.set(r.array, d);\n    d += r.count * t;\n  }\n  return i !== void 0 && (l.gpuType = i), l;\n}\nconst Re = (s, e) => {\n  const {\n    isSphere: t,\n    background: { enabled: n, color: i, opacity: o, hover: a }\n  } = e;\n  let l;\n  const d = new at({\n    color: i,\n    side: de,\n    opacity: o,\n    transparent: !0,\n    depthWrite: !1\n  });\n  if (!n) return null;\n  if (t)\n    l = new V(\n      new ue(1.8, 64, 64),\n      d\n    );\n  else {\n    let h;\n    s.forEach((r) => {\n      const u = r.scale.x;\n      r.scale.setScalar(0.9), r.updateMatrix();\n      const c = r.geometry.clone();\n      c.applyMatrix4(r.matrix), h = h ? Ge([h, c]) : c, r.scale.setScalar(u);\n    }), l = new V(h, d);\n  }\n  return l.userData = {\n    color: i,\n    opacity: o,\n    hover: a\n  }, l;\n}, Ft = new xt(), K = new U();\nclass te extends he {\n  constructor() {\n    super(), this.isLineSegmentsGeometry = !0, this.type = \"LineSegmentsGeometry\";\n    const e = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], t = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], n = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];\n    this.setIndex(n), this.setAttribute(\"position\", new Bt(e, 3)), this.setAttribute(\"uv\", new Bt(t, 2));\n  }\n  applyMatrix4(e) {\n    const t = this.attributes.instanceStart, n = this.attributes.instanceEnd;\n    return t !== void 0 && (t.applyMatrix4(e), n.applyMatrix4(e), t.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;\n  }\n  setPositions(e) {\n    let t;\n    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));\n    const n = new pt(t, 6, 1);\n    return this.setAttribute(\"instanceStart\", new N(n, 3, 0)), this.setAttribute(\"instanceEnd\", new N(n, 3, 3)), this.instanceCount = this.attributes.instanceStart.count, this.computeBoundingBox(), this.computeBoundingSphere(), this;\n  }\n  setColors(e) {\n    let t;\n    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));\n    const n = new pt(t, 6, 1);\n    return this.setAttribute(\"instanceColorStart\", new N(n, 3, 0)), this.setAttribute(\"instanceColorEnd\", new N(n, 3, 3)), this;\n  }\n  fromWireframeGeometry(e) {\n    return this.setPositions(e.attributes.position.array), this;\n  }\n  fromEdgesGeometry(e) {\n    return this.setPositions(e.attributes.position.array), this;\n  }\n  fromMesh(e) {\n    return this.fromWireframeGeometry(new fe(e.geometry)), this;\n  }\n  fromLineSegments(e) {\n    const t = e.geometry;\n    return this.setPositions(t.attributes.position.array), this;\n  }\n  computeBoundingBox() {\n    this.boundingBox === null && (this.boundingBox = new xt());\n    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;\n    e !== void 0 && t !== void 0 && (this.boundingBox.setFromBufferAttribute(e), Ft.setFromBufferAttribute(t), this.boundingBox.union(Ft));\n  }\n  computeBoundingSphere() {\n    this.boundingSphere === null && (this.boundingSphere = new Zt()), this.boundingBox === null && this.computeBoundingBox();\n    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;\n    if (e !== void 0 && t !== void 0) {\n      const n = this.boundingSphere.center;\n      this.boundingBox.getCenter(n);\n      let i = 0;\n      for (let o = 0, a = e.count; o < a; o++)\n        K.fromBufferAttribute(e, o), i = Math.max(i, n.distanceToSquared(K)), K.fromBufferAttribute(t, o), i = Math.max(i, n.distanceToSquared(K));\n      this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error(\"THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.\", this);\n    }\n  }\n  toJSON() {\n  }\n  applyMatrix(e) {\n    return console.warn(\"THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().\"), this.applyMatrix4(e);\n  }\n}\nst.line = {\n  worldUnits: { value: 1 },\n  linewidth: { value: 1 },\n  resolution: { value: new Q(1, 1) },\n  dashOffset: { value: 0 },\n  dashScale: { value: 1 },\n  dashSize: { value: 1 },\n  gapSize: { value: 1 }\n  // todo FIX - maybe change to totalSize\n};\nit.line = {\n  uniforms: $t.merge([\n    st.common,\n    st.fog,\n    st.line\n  ]),\n  vertexShader: (\n    /* glsl */\n    `\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\tworldStart = start.xyz;\n\t\t\t\tworldEnd = end.xyz;\n\n\t\t\t#else\n\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\tvec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );\n\t\t\t\tvec3 worldUp = normalize( cross( worldDir, tmpFwd ) );\n\t\t\t\tvec3 worldFwd = cross( worldDir, worldUp );\n\t\t\t\tworldPos = position.y < 0.5 ? start: end;\n\n\t\t\t\t// height offset\n\t\t\t\tfloat hw = linewidth * 0.5;\n\t\t\t\tworldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t// cap extension\n\t\t\t\t\tworldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;\n\n\t\t\t\t\t// add width to the box\n\t\t\t\t\tworldPos.xyz += worldFwd * hw;\n\n\t\t\t\t\t// endcaps\n\t\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\t\tworldPos.xyz -= worldFwd * 2.0 * hw;\n\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t\t// project the worldpos\n\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segments overlap neatly\n\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t#else\n\n\t\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\tdir.x /= aspect;\n\t\t\t\toffset.x /= aspect;\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\t\toffset += - dir;\n\n\t\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\t\toffset += dir;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth;\n\n\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\toffset /= resolution.y;\n\n\t\t\t\t// select end\n\t\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t\t// back to clip space\n\t\t\t\toffset *= clip.w;\n\n\t\t\t\tclip.xy += offset;\n\n\t\t\t#endif\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t`\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\t\tuniform float linewidth;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\tfloat mua;\n\t\t\tfloat mub;\n\n\t\t\tvec3 p13 = p1 - p3;\n\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\tmua = numer / denom;\n\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\tfloat len = length( delta );\n\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t#else\n\n\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t#else\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t`\n  )\n};\nclass Mt extends pe {\n  constructor(e) {\n    super({\n      type: \"LineMaterial\",\n      uniforms: $t.clone(it.line.uniforms),\n      vertexShader: it.line.vertexShader,\n      fragmentShader: it.line.fragmentShader,\n      clipping: !0\n      // required for clipping support\n    }), this.isLineMaterial = !0, this.setValues(e);\n  }\n  get color() {\n    return this.uniforms.diffuse.value;\n  }\n  set color(e) {\n    this.uniforms.diffuse.value = e;\n  }\n  get worldUnits() {\n    return \"WORLD_UNITS\" in this.defines;\n  }\n  set worldUnits(e) {\n    e === !0 ? this.defines.WORLD_UNITS = \"\" : delete this.defines.WORLD_UNITS;\n  }\n  get linewidth() {\n    return this.uniforms.linewidth.value;\n  }\n  set linewidth(e) {\n    this.uniforms.linewidth && (this.uniforms.linewidth.value = e);\n  }\n  get dashed() {\n    return \"USE_DASH\" in this.defines;\n  }\n  set dashed(e) {\n    e === !0 !== this.dashed && (this.needsUpdate = !0), e === !0 ? this.defines.USE_DASH = \"\" : delete this.defines.USE_DASH;\n  }\n  get dashScale() {\n    return this.uniforms.dashScale.value;\n  }\n  set dashScale(e) {\n    this.uniforms.dashScale.value = e;\n  }\n  get dashSize() {\n    return this.uniforms.dashSize.value;\n  }\n  set dashSize(e) {\n    this.uniforms.dashSize.value = e;\n  }\n  get dashOffset() {\n    return this.uniforms.dashOffset.value;\n  }\n  set dashOffset(e) {\n    this.uniforms.dashOffset.value = e;\n  }\n  get gapSize() {\n    return this.uniforms.gapSize.value;\n  }\n  set gapSize(e) {\n    this.uniforms.gapSize.value = e;\n  }\n  get opacity() {\n    return this.uniforms.opacity.value;\n  }\n  set opacity(e) {\n    this.uniforms && (this.uniforms.opacity.value = e);\n  }\n  get resolution() {\n    return this.uniforms.resolution.value;\n  }\n  set resolution(e) {\n    this.uniforms.resolution.value.copy(e);\n  }\n  get alphaToCoverage() {\n    return \"USE_ALPHA_TO_COVERAGE\" in this.defines;\n  }\n  set alphaToCoverage(e) {\n    this.defines && (e === !0 !== this.alphaToCoverage && (this.needsUpdate = !0), e === !0 ? this.defines.USE_ALPHA_TO_COVERAGE = \"\" : delete this.defines.USE_ALPHA_TO_COVERAGE);\n  }\n}\nconst dt = new X(), kt = new U(), Ht = new U(), A = new X(), M = new X(), O = new X(), ut = new U(), ht = new Yt(), T = new me(), jt = new U(), tt = new xt(), et = new Zt(), D = new X();\nlet P, j;\nfunction Wt(s, e, t) {\n  return D.set(0, 0, -e, 1).applyMatrix4(s.projectionMatrix), D.multiplyScalar(1 / D.w), D.x = j / t.width, D.y = j / t.height, D.applyMatrix4(s.projectionMatrixInverse), D.multiplyScalar(1 / D.w), Math.abs(Math.max(D.x, D.y));\n}\nfunction Ie(s, e) {\n  const t = s.matrixWorld, n = s.geometry, i = n.attributes.instanceStart, o = n.attributes.instanceEnd, a = Math.min(n.instanceCount, i.count);\n  for (let l = 0, d = a; l < d; l++) {\n    T.start.fromBufferAttribute(i, l), T.end.fromBufferAttribute(o, l), T.applyMatrix4(t);\n    const h = new U(), r = new U();\n    P.distanceSqToSegment(T.start, T.end, r, h), r.distanceTo(h) < j * 0.5 && e.push({\n      point: r,\n      pointOnLine: h,\n      distance: P.origin.distanceTo(r),\n      object: s,\n      face: null,\n      faceIndex: l,\n      uv: null,\n      uv1: null\n    });\n  }\n}\nfunction Fe(s, e, t) {\n  const n = e.projectionMatrix, o = s.material.resolution, a = s.matrixWorld, l = s.geometry, d = l.attributes.instanceStart, h = l.attributes.instanceEnd, r = Math.min(l.instanceCount, d.count), u = -e.near;\n  P.at(1, O), O.w = 1, O.applyMatrix4(e.matrixWorldInverse), O.applyMatrix4(n), O.multiplyScalar(1 / O.w), O.x *= o.x / 2, O.y *= o.y / 2, O.z = 0, ut.copy(O), ht.multiplyMatrices(e.matrixWorldInverse, a);\n  for (let c = 0, f = r; c < f; c++) {\n    if (A.fromBufferAttribute(d, c), M.fromBufferAttribute(h, c), A.w = 1, M.w = 1, A.applyMatrix4(ht), M.applyMatrix4(ht), A.z > u && M.z > u)\n      continue;\n    if (A.z > u) {\n      const E = A.z - M.z, L = (A.z - u) / E;\n      A.lerp(M, L);\n    } else if (M.z > u) {\n      const E = M.z - A.z, L = (M.z - u) / E;\n      M.lerp(A, L);\n    }\n    A.applyMatrix4(n), M.applyMatrix4(n), A.multiplyScalar(1 / A.w), M.multiplyScalar(1 / M.w), A.x *= o.x / 2, A.y *= o.y / 2, M.x *= o.x / 2, M.y *= o.y / 2, T.start.copy(A), T.start.z = 0, T.end.copy(M), T.end.z = 0;\n    const v = T.closestPointToPointParameter(ut, !0);\n    T.at(v, jt);\n    const g = ge.lerp(A.z, M.z, v), S = g >= -1 && g <= 1, w = ut.distanceTo(jt) < j * 0.5;\n    if (S && w) {\n      T.start.fromBufferAttribute(d, c), T.end.fromBufferAttribute(h, c), T.start.applyMatrix4(a), T.end.applyMatrix4(a);\n      const E = new U(), L = new U();\n      P.distanceSqToSegment(T.start, T.end, L, E), t.push({\n        point: L,\n        pointOnLine: E,\n        distance: P.origin.distanceTo(L),\n        object: s,\n        face: null,\n        faceIndex: c,\n        uv: null,\n        uv1: null\n      });\n    }\n  }\n}\nclass ke extends V {\n  constructor(e = new te(), t = new Mt({ color: Math.random() * 16777215 })) {\n    super(e, t), this.isLineSegments2 = !0, this.type = \"LineSegments2\";\n  }\n  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n  computeLineDistances() {\n    const e = this.geometry, t = e.attributes.instanceStart, n = e.attributes.instanceEnd, i = new Float32Array(2 * t.count);\n    for (let a = 0, l = 0, d = t.count; a < d; a++, l += 2)\n      kt.fromBufferAttribute(t, a), Ht.fromBufferAttribute(n, a), i[l] = l === 0 ? 0 : i[l - 1], i[l + 1] = i[l] + kt.distanceTo(Ht);\n    const o = new pt(i, 2, 1);\n    return e.setAttribute(\"instanceDistanceStart\", new N(o, 1, 0)), e.setAttribute(\"instanceDistanceEnd\", new N(o, 1, 1)), this;\n  }\n  raycast(e, t) {\n    const n = this.material.worldUnits, i = e.camera;\n    i === null && !n && console.error('LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');\n    const o = e.params.Line2 !== void 0 && e.params.Line2.threshold || 0;\n    P = e.ray;\n    const a = this.matrixWorld, l = this.geometry, d = this.material;\n    j = d.linewidth + o, l.boundingSphere === null && l.computeBoundingSphere(), et.copy(l.boundingSphere).applyMatrix4(a);\n    let h;\n    if (n)\n      h = j * 0.5;\n    else {\n      const u = Math.max(i.near, et.distanceToPoint(P.origin));\n      h = Wt(i, u, d.resolution);\n    }\n    if (et.radius += h, P.intersectsSphere(et) === !1)\n      return;\n    l.boundingBox === null && l.computeBoundingBox(), tt.copy(l.boundingBox).applyMatrix4(a);\n    let r;\n    if (n)\n      r = j * 0.5;\n    else {\n      const u = Math.max(i.near, tt.distanceToPoint(P.origin));\n      r = Wt(i, u, d.resolution);\n    }\n    tt.expandByScalar(r), P.intersectsBox(tt) !== !1 && (n ? Ie(this, t) : Fe(this, i, t));\n  }\n  onBeforeRender(e) {\n    const t = this.material.uniforms;\n    t && t.resolution && (e.getViewport(dt), this.material.uniforms.resolution.value.set(dt.z, dt.w));\n  }\n}\nclass ee extends te {\n  constructor() {\n    super(), this.isLineGeometry = !0, this.type = \"LineGeometry\";\n  }\n  setPositions(e) {\n    const t = e.length - 3, n = new Float32Array(2 * t);\n    for (let i = 0; i < t; i += 3)\n      n[2 * i] = e[i], n[2 * i + 1] = e[i + 1], n[2 * i + 2] = e[i + 2], n[2 * i + 3] = e[i + 3], n[2 * i + 4] = e[i + 4], n[2 * i + 5] = e[i + 5];\n    return super.setPositions(n), this;\n  }\n  setColors(e) {\n    const t = e.length - 3, n = new Float32Array(2 * t);\n    for (let i = 0; i < t; i += 3)\n      n[2 * i] = e[i], n[2 * i + 1] = e[i + 1], n[2 * i + 2] = e[i + 2], n[2 * i + 3] = e[i + 3], n[2 * i + 4] = e[i + 4], n[2 * i + 5] = e[i + 5];\n    return super.setColors(n), this;\n  }\n  setFromPoints(e) {\n    const t = e.length - 1, n = new Float32Array(6 * t);\n    for (let i = 0; i < t; i++)\n      n[6 * i] = e[i].x, n[6 * i + 1] = e[i].y, n[6 * i + 2] = e[i].z || 0, n[6 * i + 3] = e[i + 1].x, n[6 * i + 4] = e[i + 1].y, n[6 * i + 5] = e[i + 1].z || 0;\n    return super.setPositions(n), this;\n  }\n  fromLine(e) {\n    const t = e.geometry;\n    return this.setPositions(t.attributes.position.array), this;\n  }\n}\nclass He extends ke {\n  constructor(e = new ee(), t = new Mt({ color: Math.random() * 16777215 })) {\n    super(e, t), this.isLine2 = !0, this.type = \"Line2\";\n  }\n}\nconst je = (s) => {\n  const e = new Vt(), t = [], n = [], { isSphere: i } = s;\n  if (Y.forEach((l, d) => {\n    const { enabled: h, line: r, scale: u, color: c } = s[l];\n    if (!h || !r) return;\n    const f = d < 3 ? 1 : -1, v = (i ? Kt - u / 2 : 0.975) * f;\n    t.push(\n      l.includes(\"x\") ? v : 0,\n      l.includes(\"y\") ? v : 0,\n      l.includes(\"z\") ? v : 0,\n      0,\n      0,\n      0\n    );\n    const g = e.set(c).toArray();\n    n.push(...g, ...g);\n  }), !t.length) return null;\n  const o = new ee().setPositions(t).setColors(n), a = new Mt({\n    linewidth: s.lineWidth,\n    vertexColors: !0,\n    resolution: new Q(window.innerWidth, window.innerHeight)\n  });\n  return new He(o, a).computeLineDistances();\n}, We = (s) => {\n  const { corners: e, edges: t } = s, n = [], i = Be(s), o = Oe(s, i);\n  n.push(...o), e.enabled && n.push(...De(s, i)), t.enabled && n.push(...Pe(s, i, e.enabled ? 7 : 6));\n  const a = Re(o, s), l = je(s);\n  return [n, a, l];\n}, $ = (s, e = !0) => {\n  const { material: t, userData: n } = s, { opacity: i, color: o, scale: a } = e ? n.hover : n;\n  s.scale.setScalar(a), t.opacity = i, t.map ? Ce(t.map, e) : t.color.set(o);\n}, q = /* @__PURE__ */ new Yt(), qt = /* @__PURE__ */ new be(), qe = /* @__PURE__ */ new Q(), H = /* @__PURE__ */ new U(), Nt = /* @__PURE__ */ new X();\nclass Xe extends ft {\n  /**\n   * Creates a new ViewportGizmo instance.\n   *\n   * @param camera - The camera to be controlled by this gizmo\n   * @param renderer - The WebGL renderer used to render the scene\n   * @param options - {@link GizmoOptions}, Configuration options for the gizmo.\n   * @param options.container - Parent element for the gizmo. Can be an HTMLElement or a CSS selector string\n   * @param options.type - The gizmo configuration type. Either 'sphere' or 'cube', defaults to 'sphere'\n   * @param options.size - Size of the gizmo widget in pixels. Defaults to 128\n   * @param options.placement - Position of the gizmo in the viewport\n   *    Options include:\n   *    - `\"top-left\"`\n   *    - `\"top-center\"`\n   *    - `\"top-right\"`\n   *    - `\"center-left\"`\n   *    - `\"center-center\"`\n   *    - `\"center-right\"`\n   *    - `\"bottom-left\"`\n   *    - `\"bottom-center\"`\n   *    - `\"bottom-right\"`\n   * @param options.offset - Offset of the gizmo from container edges in pixels\n   * @param options.offset.left - Offset from the left edge\n   * @param options.offset.top - Offset from the top edge\n   * @param options.offset.right - Offset from the right edge\n   * @param options.offset.bottom - Offset from the bottom edge\n   * @param options.animated - Whether view changes should be animated. Defaults to true\n   * @param options.speed - Animation speed multiplier. Defaults to 1\n   * @param options.resolution - Texture resolution. Defaults to 64 for sphere, 128 for cube\n   * @param options.lineWidth - Width of the axes lines in pixels\n   * @param options.id - HTML `id` attribute for the gizmo container\n   * @param options.className - HTML `class` attribute for the gizmo container\n   * @param options.font - Font configuration for axis labels\n   * @param options.font.family - Font family for axis labels\n   * @param options.font.weight - Font weight for axis labels\n   * @param options.background - Configuration for the background sphere/cube\n   * @param options.background.enabled - Whether to display the background\n   * @param options.background.color - Color of the background in normal state\n   * @param options.background.opacity - Opacity of the background in normal state\n   * @param options.background.hover.color - Color of the background when hovered\n   * @param options.background.hover.opacity - Opacity of the background when hovered\n   * @param options.corners - Configuration for corner indicators\n   * @param options.corners.enabled - Whether to display corner indicators\n   * @param options.corners.color - Base color of corner indicators\n   * @param options.corners.opacity - Opacity of corner indicators\n   * @param options.corners.scale - Scale multiplier for corner indicators\n   * @param options.corners.radius - Radius of corner indicators\n   * @param options.corners.smoothness - Smoothness of corner indicators\n   * @param options.corners.hover.color - Color of corner indicators when hovered\n   * @param options.corners.hover.opacity - Opacity of corner indicators when hovered\n   * @param options.corners.hover.scale - Scale of corner indicators when hovered\n   * @param options.edges - Configuration for edge indicators\n   * @param options.edges.enabled - Whether to display edge indicators\n   * @param options.edges.color - Base color of edge indicators\n   * @param options.edges.opacity - Opacity of edge indicators\n   * @param options.edges.scale - Scale multiplier for edge indicators\n   * @param options.edges.radius - Radius of edge indicators\n   * @param options.edges.smoothness - Smoothness of edge indicators\n   * @param options.edges.hover.color - Color of edge indicators when hovered\n   * @param options.edges.hover.opacity - Opacity of edge indicators when hovered\n   * @param options.edges.hover.scale - Scale of edge indicators when hovered\n   * @param options.x - Configuration for positive X axis/face\n   * @param options.y - Configuration for positive Y axis/face\n   * @param options.z - Configuration for positive Z axis/face\n   * @param options.nx - Configuration for negative X axis/face\n   * @param options.ny - Configuration for negative Y axis/face\n   * @param options.nz - Configuration for negative Z axis/face\n   *\n   * @remarks Axis-specific configuration can also use alias names for cube mode:\n   * - `right` (same as `x`)\n   * - `left` (same as `nx`)\n   * - `top` (same as `y`)\n   * - `bottom` (same as `ny`)\n   * - `front` (same as `z`)\n   * - `back` (same as `nz`)\n   *\n   * For each axis/face configuration, the following options are available:\n   * @param options.AXIS.enabled - Whether to draw the axis\n   * @param options.AXIS.label - Custom text label for the axis\n   * @param options.AXIS.opacity - Axis opacity\n   * @param options.AXIS.scale - Scale multiplier for indicator size\n   * @param options.AXIS.line - Whether to draw the axis line\n   * @param options.AXIS.color - Axis indicator background color\n   * @param options.AXIS.labelColor - Axis label color\n   * @param options.AXIS.border.size - Border size around the axis indicator\n   * @param options.AXIS.border.color - Border color around the axis indicator\n   * @param options.AXIS.hover.color - Fill color on hover\n   * @param options.AXIS.hover.labelColor - Label text color on hover\n   * @param options.AXIS.hover.opacity - Opacity when hovered\n   * @param options.AXIS.hover.scale - Indicator scale when hovered\n   * @param options.AXIS.hover.border.size - Hover border size\n   * @param options.AXIS.hover.border.color - Hover border color\n   */\n  constructor(t, n, i = {}) {\n    super();\n    /** Whether the gizmo is currently active and responding to user input */\n    m(this, \"enabled\", !0);\n    /** The camera being controlled by this gizmo */\n    m(this, \"camera\");\n    /** The WebGLRenderer rendering the gizmo */\n    m(this, \"renderer\");\n    /** The configuration options */\n    m(this, \"options\");\n    /** The point around which the camera rotates */\n    m(this, \"target\", new U());\n    /** Whether view changes should be animated */\n    m(this, \"animated\", !0);\n    /** The speed of view change animations. Higher values result in faster animations */\n    m(this, \"speed\", 1);\n    /**\n     * Indicates whether the gizmo is currently being animated or not,\n     * Useful when interacting with other camera controllers\n     *\n     * @readonly This value is set internally.\n     **/\n    m(this, \"animating\", !1);\n    m(this, \"_options\");\n    m(this, \"_intersections\");\n    m(this, \"_background\", null);\n    m(this, \"_viewport\", [0, 0, 0, 0]);\n    m(this, \"_originalViewport\", [0, 0, 0, 0]);\n    m(this, \"_originalScissor\", [0, 0, 0, 0]);\n    m(this, \"_scene\");\n    m(this, \"_camera\");\n    m(this, \"_container\");\n    m(this, \"_domElement\");\n    m(this, \"_domRect\");\n    m(this, \"_dragging\", !1);\n    m(this, \"_distance\", 0);\n    m(this, \"_clock\", new ye());\n    m(this, \"_targetQuaternion\", new ct());\n    m(this, \"_quaternionStart\", new ct());\n    m(this, \"_quaternionEnd\", new ct());\n    m(this, \"_pointerStart\", new Q());\n    m(this, \"_focus\", null);\n    m(this, \"_placement\");\n    m(this, \"_controls\");\n    m(this, \"_controlsListeners\");\n    this.camera = t, this.renderer = n, this._scene = new _e().add(this), this.set(i);\n  }\n  /** Gets the current placement of the gizmo relative to its container. */\n  get placement() {\n    return this._placement;\n  }\n  /**\n   * Sets and update the placement of the gizmo relative to its container.\n   *\n   * @param placement - The new placement position\n   */\n  set placement(t) {\n    this._placement = Qt(this._domElement, t), this.domUpdate();\n  }\n  /**\n   * Regenerates the gizmo with the new options.\n   *\n   * @remarks\n   * - Not recommended for use in real-time rendering or animation loops\n   * - Provides a way to completely rebuild the gizmo with new options\n   * - Can be computationally expensive, so use sparingly\n   */\n  set(t = {}) {\n    this.dispose(), this.options = t, this._options = ze(t), this._camera = this._options.isSphere ? new ve(-1.8, 1.8, 1.8, -1.8, 5, 10) : new we(26, 1, 5, 10), this._camera.position.set(0, 0, 7);\n    const [n, i, o] = We(this._options);\n    i && this.add(i), o && this.add(o), this.add(...n), this._background = i, this._intersections = n;\n    const { container: a, animated: l, speed: d } = this._options;\n    return this.animated = l, this.speed = d, this._container = a ? xe(a) : document.body, this._domElement = Se(this._options), this._domElement.onpointerdown = (h) => this._onPointerDown(h), this._domElement.onpointermove = (h) => this._onPointerMove(h), this._domElement.onpointerleave = () => this._onPointerLeave(), this._container.appendChild(this._domElement), this._controls && this.attachControls(this._controls), this.update(), this._updateOrientation(!0), this;\n  }\n  /**\n   * Renders the gizmo to the screen.\n   * This method handles viewport and scissor management to ensure the gizmo\n   * renders correctly without affecting the main scene rendering.\n   *\n   * @returns The gizmo instance for method chaining\n   */\n  render() {\n    this.animating && this._animate();\n    const { renderer: t, _viewport: n } = this, i = t.getScissorTest(), o = t.autoClear;\n    return t.autoClear = !1, t.setViewport(...n), i && t.setScissor(...n), t.clear(!1, !0, !1), t.render(this._scene, this._camera), t.setViewport(...this._originalViewport), i && t.setScissor(...this._originalScissor), t.autoClear = o, this;\n  }\n  /**\n   * Updates the gizmo's DOM-related properties based on its current position\n   * and size in the document.\n   *\n   * @returns The gizmo instance for method chaining\n   */\n  domUpdate() {\n    this._domRect = this._domElement.getBoundingClientRect();\n    const t = this.renderer, n = this._domRect, i = t.domElement.getBoundingClientRect();\n    return this._viewport.splice(\n      0,\n      4,\n      n.left - i.left,\n      t.domElement.clientHeight - (n.top - i.top + n.height),\n      n.width,\n      n.height\n    ), t.getViewport(Nt).toArray(this._originalViewport), t.getScissorTest() && t.getScissor(Nt).toArray(this._originalScissor), this;\n  }\n  /**\n   * Updates the gizmo's orientation to match the current camera orientation.\n   *\n   * @returns The gizmo instance for method chaining\n   */\n  cameraUpdate() {\n    return this._updateOrientation(), this;\n  }\n  /**\n   * Performs a complete update of the gizmo, including both DOM and camera-related updates.\n   *\n   * @param controls - Internal. Set to `false` if the update event comes from the attached controls.\n   *\n   * @returns The gizmo instance for method chaining\n   */\n  update(t = !0) {\n    return t && this._controls && this._controls.update(), this.domUpdate().cameraUpdate();\n  }\n  /**\n   * Connects OrbitControls with the gizmo, handling interaction states and updates.\n   * Automatically detaches any previously attached controls.\n   *\n   * @param controls - The scene's {@link https://threejs.org/docs/#examples/en/controls/OrbitControls OrbitControls}\n   */\n  attachControls(t) {\n    return this.detachControls(), this.target = t.target, this._controlsListeners = {\n      start: () => t.enabled = !1,\n      end: () => t.enabled = !0,\n      change: () => this.update(!1)\n    }, this.addEventListener(\"start\", this._controlsListeners.start), this.addEventListener(\"end\", this._controlsListeners.end), t.addEventListener(\"change\", this._controlsListeners.change), this._controls = t, this;\n  }\n  /** Removes all control event listeners and references. Safe to call multiple times. */\n  detachControls() {\n    if (!(!this._controlsListeners || !this._controls))\n      return this.target = new U().copy(this._controls.target), this.removeEventListener(\"start\", this._controlsListeners.start), this.removeEventListener(\"end\", this._controlsListeners.end), this._controls.removeEventListener(\n        \"change\",\n        this._controlsListeners.change\n      ), this._controlsListeners = void 0, this._controls = void 0, this;\n  }\n  /** Cleans up all resources including geometries, materials, textures, and event listeners. */\n  dispose() {\n    var t;\n    this.detachControls(), this.children.forEach((n) => {\n      var o, a, l, d;\n      this.remove(n);\n      const i = n;\n      (o = i.material) == null || o.dispose(), (l = (a = i.material) == null ? void 0 : a.map) == null || l.dispose(), (d = i.geometry) == null || d.dispose();\n    }), (t = this._domElement) == null || t.remove();\n  }\n  /**\n   * Updates the gizmo's orientation either based on the camera or internal state.\n   *\n   * @private\n   * @param fromCamera - Whether to update based on camera orientation (true) or internal state (false)\n   */\n  _updateOrientation(t = !0) {\n    t && (this.quaternion.copy(this.camera.quaternion).invert(), this.updateMatrixWorld()), Ot(this._options, this._intersections, this.camera);\n  }\n  /**\n   * Handles the animation of camera position and orientation changes.\n   *\n   * @private\n   */\n  _animate() {\n    const { position: t, quaternion: n } = this.camera;\n    if (t.set(0, 0, 1), !this.animated) {\n      t.applyQuaternion(this._quaternionEnd).multiplyScalar(this._distance).add(this.target), n.copy(this._targetQuaternion), this._updateOrientation(), this.animating = !1, this.dispatchEvent({ type: \"change\" }), this.dispatchEvent({ type: \"end\" });\n      return;\n    }\n    this._controls && (this._controls.enabled = !1);\n    const o = this._clock.getDelta() * Me * this.speed;\n    this._quaternionStart.rotateTowards(this._quaternionEnd, o), t.applyQuaternion(this._quaternionStart).multiplyScalar(this._distance).add(this.target), n.rotateTowards(this._targetQuaternion, o), this._updateOrientation(), requestAnimationFrame(() => this.dispatchEvent({ type: \"change\" })), this._quaternionStart.angleTo(this._quaternionEnd) < lt && (this._controls && (this._controls.enabled = !0), this.animating = !1, this.dispatchEvent({ type: \"end\" }));\n  }\n  /**\n   * Sets the camera orientation to look at the target from a specific axis.\n   *\n   * @private\n   * @param position - The axis point position\n   */\n  _setOrientation(t) {\n    const n = this.camera, i = this.target;\n    H.copy(t).multiplyScalar(this._distance), q.setPosition(H).lookAt(H, this.position, this.up), this._targetQuaternion.setFromRotationMatrix(q), H.add(i), q.lookAt(H, i, this.up), this._quaternionEnd.setFromRotationMatrix(q), q.setPosition(n.position).lookAt(n.position, i, this.up), this._quaternionStart.setFromRotationMatrix(q), this.animating = !0, this._clock.start(), this.dispatchEvent({ type: \"start\" });\n  }\n  /**\n   * Handles the pointer down event for starting drag operations.\n   *\n   * @private\n   * @param e - The pointer event\n   */\n  _onPointerDown(t) {\n    if (!this.enabled) return;\n    const n = (h) => {\n      if (!this._dragging) {\n        if (Ae(h, this._pointerStart)) return;\n        this._dragging = !0;\n      }\n      const r = qe.set(h.clientX, h.clientY).sub(this._pointerStart).multiplyScalar(1 / this._domRect.width * Math.PI), u = this.coordinateConversion(\n        H.subVectors(this.camera.position, this.target)\n      ), c = qt.setFromVector3(u);\n      c.theta = l - r.x, c.phi = mt(\n        d - r.y,\n        lt,\n        Math.PI - lt\n      ), this.coordinateConversion(\n        this.camera.position.setFromSpherical(c),\n        !0\n      ).add(this.target), this.camera.lookAt(this.target), this.quaternion.copy(this.camera.quaternion).invert(), this._updateOrientation(!1), this.dispatchEvent({ type: \"change\" });\n    }, i = () => {\n      if (document.removeEventListener(\"pointermove\", n, !1), document.removeEventListener(\"pointerup\", i, !1), !this._dragging) return this._handleClick(t);\n      this._focus && ($(this._focus, !1), this._focus = null), this._dragging = !1, this.dispatchEvent({ type: \"end\" });\n    };\n    if (this.animating) return;\n    t.preventDefault(), this._pointerStart.set(t.clientX, t.clientY);\n    const o = this.coordinateConversion(\n      H.subVectors(this.camera.position, this.target)\n    ), a = qt.setFromVector3(o), l = a.theta, d = a.phi;\n    this._distance = a.radius, document.addEventListener(\"pointermove\", n, !1), document.addEventListener(\"pointerup\", i, !1), this.dispatchEvent({ type: \"start\" });\n  }\n  /**\n   * Converts the input-coordinates from the standard Y-axis up to what is set in Object3D.DEFAULT_UP.\n   *\n   * @private\n   * @param target      - The target Vector3 to be converted\n   * @param isSpherical - Whether or not the coordinates are for a sphere\n   * @returns The converted coordinates\n   */\n  coordinateConversion(t, n = !1) {\n    const { x: i, y: o, z: a } = t, l = ft.DEFAULT_UP;\n    return l.x === 1 ? n ? t.set(o, a, i) : t.set(a, i, o) : l.z === 1 ? n ? t.set(a, i, o) : t.set(o, a, i) : t;\n  }\n  /**\n   * Handles pointer move events for hover effects and drag operations.\n   *\n   * @private\n   * @param e - The pointer event\n   */\n  _onPointerMove(t) {\n    !this.enabled || this._dragging || (this._background && Rt(this._background, !0), this._handleHover(t));\n  }\n  /**\n   * Handles pointer leave events to reset hover states.\n   *\n   * @private\n   */\n  _onPointerLeave() {\n    !this.enabled || this._dragging || (this._background && Rt(this._background, !1), this._focus && $(this._focus, !1), this._domElement.style.cursor = \"\");\n  }\n  /**\n   * Handles click events for axis selection.\n   *\n   * @private\n   * @param e - The pointer event\n   */\n  _handleClick(t) {\n    const n = Gt(\n      t,\n      this._domRect,\n      this._camera,\n      this._intersections\n    );\n    this._focus && ($(this._focus, !1), this._focus = null), n && (this._setOrientation(n.object.position), this.dispatchEvent({ type: \"change\" }));\n  }\n  /**\n   * Handles hover effects for interactive elements.\n   *\n   * @private\n   * @param e - The pointer event\n   */\n  _handleHover(t) {\n    const n = Gt(\n      t,\n      this._domRect,\n      this._camera,\n      this._intersections\n    ), i = (n == null ? void 0 : n.object) || null;\n    this._focus !== i && (this._domElement.style.cursor = i ? \"pointer\" : \"\", this._focus && $(this._focus, !1), (this._focus = i) ? $(i, !0) : Ot(this._options, this._intersections, this.camera));\n  }\n}\nexport {\n  Xe as ViewportGizmo\n};\n//# sourceMappingURL=three-viewport-gizmo.js.map\n","export const common_functions = /* glsl */`\n\n// A stack of uint32 indices can can store the indices for\n// a perfectly balanced tree with a depth up to 31. Lower stack\n// depth gets higher performance.\n//\n// However not all trees are balanced. Best value to set this to\n// is the trees max depth.\n#ifndef BVH_STACK_DEPTH\n#define BVH_STACK_DEPTH 60\n#endif\n\n#ifndef INFINITY\n#define INFINITY 1e20\n#endif\n\n// Utilities\nuvec4 uTexelFetch1D( usampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nivec4 iTexelFetch1D( isampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 texelFetch1D( sampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 textureSampleBarycoord( sampler2D tex, vec3 barycoord, uvec3 faceIndices ) {\n\n\treturn\n\t\tbarycoord.x * texelFetch1D( tex, faceIndices.x ) +\n\t\tbarycoord.y * texelFetch1D( tex, faceIndices.y ) +\n\t\tbarycoord.z * texelFetch1D( tex, faceIndices.z );\n\n}\n\nvoid ndcToCameraRay(\n\tvec2 coord, mat4 cameraWorld, mat4 invProjectionMatrix,\n\tout vec3 rayOrigin, out vec3 rayDirection\n) {\n\n\t// get camera look direction and near plane for camera clipping\n\tvec4 lookDirection = cameraWorld * vec4( 0.0, 0.0, - 1.0, 0.0 );\n\tvec4 nearVector = invProjectionMatrix * vec4( 0.0, 0.0, - 1.0, 1.0 );\n\tfloat near = abs( nearVector.z / nearVector.w );\n\n\t// get the camera direction and position from camera matrices\n\tvec4 origin = cameraWorld * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec4 direction = invProjectionMatrix * vec4( coord, 0.5, 1.0 );\n\tdirection /= direction.w;\n\tdirection = cameraWorld * direction - origin;\n\n\t// slide the origin along the ray until it sits at the near clip plane position\n\torigin.xyz += direction.xyz * near / dot( direction, lookDirection );\n\n\trayOrigin = origin.xyz;\n\trayDirection = direction.xyz;\n\n}\n`;\n","export const bvh_ray_functions = /* glsl */`\n\n#ifndef TRI_INTERSECT_EPSILON\n#define TRI_INTERSECT_EPSILON 1e-5\n#endif\n\n// Raycasting\nbool intersectsBounds( vec3 rayOrigin, vec3 rayDirection, vec3 boundsMin, vec3 boundsMax, out float dist ) {\n\n\t// https://www.reddit.com/r/opengl/comments/8ntzz5/fast_glsl_ray_box_intersection/\n\t// https://tavianator.com/2011/ray_box.html\n\tvec3 invDir = 1.0 / rayDirection;\n\n\t// find intersection distances for each plane\n\tvec3 tMinPlane = invDir * ( boundsMin - rayOrigin );\n\tvec3 tMaxPlane = invDir * ( boundsMax - rayOrigin );\n\n\t// get the min and max distances from each intersection\n\tvec3 tMinHit = min( tMaxPlane, tMinPlane );\n\tvec3 tMaxHit = max( tMaxPlane, tMinPlane );\n\n\t// get the furthest hit distance\n\tvec2 t = max( tMinHit.xx, tMinHit.yz );\n\tfloat t0 = max( t.x, t.y );\n\n\t// get the minimum hit distance\n\tt = min( tMaxHit.xx, tMaxHit.yz );\n\tfloat t1 = min( t.x, t.y );\n\n\t// set distance to 0.0 if the ray starts inside the box\n\tdist = max( t0, 0.0 );\n\n\treturn t1 >= dist;\n\n}\n\nbool intersectsTriangle(\n\tvec3 rayOrigin, vec3 rayDirection, vec3 a, vec3 b, vec3 c,\n\tout vec3 barycoord, out vec3 norm, out float dist, out float side\n) {\n\n\t// https://stackoverflow.com/questions/42740765/intersection-between-line-and-triangle-in-3d\n\tvec3 edge1 = b - a;\n\tvec3 edge2 = c - a;\n\tnorm = cross( edge1, edge2 );\n\n\tfloat det = - dot( rayDirection, norm );\n\tfloat invdet = 1.0 / det;\n\n\tvec3 AO = rayOrigin - a;\n\tvec3 DAO = cross( AO, rayDirection );\n\n\tvec4 uvt;\n\tuvt.x = dot( edge2, DAO ) * invdet;\n\tuvt.y = - dot( edge1, DAO ) * invdet;\n\tuvt.z = dot( AO, norm ) * invdet;\n\tuvt.w = 1.0 - uvt.x - uvt.y;\n\n\t// set the hit information\n\tbarycoord = uvt.wxy; // arranged in A, B, C order\n\tdist = uvt.z;\n\tside = sign( det );\n\tnorm = side * normalize( norm );\n\n\t// add an epsilon to avoid misses between triangles\n\tuvt += vec4( TRI_INTERSECT_EPSILON );\n\n\treturn all( greaterThanEqual( uvt, vec4( 0.0 ) ) );\n\n}\n\nbool intersectTriangles(\n\t// geometry info and triangle range\n\tsampler2D positionAttr, usampler2D indexAttr, uint offset, uint count,\n\n\t// ray\n\tvec3 rayOrigin, vec3 rayDirection,\n\n\t// outputs\n\tinout float minDistance, inout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout float dist\n) {\n\n\tbool found = false;\n\tvec3 localBarycoord, localNormal;\n\tfloat localDist, localSide;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( indexAttr, i ).xyz;\n\t\tvec3 a = texelFetch1D( positionAttr, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( positionAttr, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( positionAttr, indices.z ).rgb;\n\n\t\tif (\n\t\t\tintersectsTriangle( rayOrigin, rayDirection, a, b, c, localBarycoord, localNormal, localDist, localSide )\n\t\t\t&& localDist < minDistance\n\t\t) {\n\n\t\t\tfound = true;\n\t\t\tminDistance = localDist;\n\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = localNormal;\n\n\t\t\tside = localSide;\n\t\t\tbarycoord = localBarycoord;\n\t\t\tdist = localDist;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n\nbool intersectsBVHNodeBounds( vec3 rayOrigin, vec3 rayDirection, sampler2D bvhBounds, uint currNodeIndex, out float dist ) {\n\n\tuint cni2 = currNodeIndex * 2u;\n\tvec3 boundsMin = texelFetch1D( bvhBounds, cni2 ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvhBounds, cni2 + 1u ).xyz;\n\treturn intersectsBounds( rayOrigin, rayDirection, boundsMin, boundsMax, dist );\n\n}\n\n// use a macro to hide the fact that we need to expand the struct into separate fields\n#define\\\n\tbvhIntersectFirstHit(\\\n\t\tbvh,\\\n\t\trayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist\\\n\t)\\\n\t_bvhIntersectFirstHit(\\\n\t\tbvh.position, bvh.index, bvh.bvhBounds, bvh.bvhContents,\\\n\t\trayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist\\\n\t)\n\nbool _bvhIntersectFirstHit(\n\t// bvh info\n\tsampler2D bvh_position, usampler2D bvh_index, sampler2D bvh_bvhBounds, usampler2D bvh_bvhContents,\n\n\t// ray\n\tvec3 rayOrigin, vec3 rayDirection,\n\n\t// output variables split into separate variables due to output precision\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout float dist\n) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint ptr = 0;\n\tuint stack[ BVH_STACK_DEPTH ];\n\tstack[ 0 ] = 0u;\n\n\tfloat triangleDistance = INFINITY;\n\tbool found = false;\n\twhile ( ptr > - 1 && ptr < BVH_STACK_DEPTH ) {\n\n\t\tuint currNodeIndex = stack[ ptr ];\n\t\tptr --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance;\n\t\tif (\n\t\t\t! intersectsBVHNodeBounds( rayOrigin, rayDirection, bvh_bvhBounds, currNodeIndex, boundsHitDistance )\n\t\t\t|| boundsHitDistance > triangleDistance\n\t\t) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh_bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\n\t\t\tfound = intersectTriangles(\n\t\t\t\tbvh_position, bvh_index, offset, count,\n\t\t\t\trayOrigin, rayDirection, triangleDistance,\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, dist\n\t\t\t) || found;\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = boundsInfo.y;\n\n\t\t\tbool leftToRight = rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c2;\n\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n`;\n","// Note that a struct cannot be used for the hit record including faceIndices, faceNormal, barycoord,\n// side, and dist because on some mobile GPUS (such as Adreno) numbers are afforded less precision specifically\n// when in a struct leading to inaccurate hit results. See KhronosGroup/WebGL#3351 for more details.\nexport const bvh_struct_definitions = /* glsl */`\nstruct BVH {\n\n\tusampler2D index;\n\tsampler2D position;\n\n\tsampler2D bvhBounds;\n\tusampler2D bvhContents;\n\n};\n`;\n","export { MeshBVH } from './core/MeshBVH.js';\nexport { MeshBVHHelper } from './objects/MeshBVHHelper.js';\nexport { CENTER, AVERAGE, SAH, NOT_INTERSECTED, INTERSECTED, CONTAINED } from './core/Constants.js';\nexport { getBVHExtremes, estimateMemoryInBytes, getJSONStructure, validateBounds } from './debug/Debug.js';\nexport * from './utils/ExtensionUtilities.js';\nexport { getTriangleHitPointInfo } from './utils/TriangleUtilities.js';\nexport * from './math/ExtendedTriangle.js';\nexport * from './math/OrientedBox.js';\nexport * from './gpu/MeshBVHUniformStruct.js';\nexport * from './gpu/VertexAttributeTexture.js';\nexport * from './utils/StaticGeometryGenerator.js';\nexport * as BVHShaderGLSL from './gpu/BVHShaderGLSL.js';\n\n// backwards compatibility\nimport * as BVHShaderGLSL from './gpu/BVHShaderGLSL.js';\nexport const shaderStructs = BVHShaderGLSL.bvh_struct_definitions;\nexport const shaderDistanceFunction = BVHShaderGLSL.bvh_distance_functions;\nexport const shaderIntersectFunction = `\n\t${ BVHShaderGLSL.common_functions }\n\t${ BVHShaderGLSL.bvh_ray_functions }\n`;\n","var ye = Object.defineProperty;\nvar we = (t, i, e) => i in t ? ye(t, i, { enumerable: !0, configurable: !0, writable: !0, value: e }) : t[i] = e;\nvar y = (t, i, e) => (we(t, typeof i != \"symbol\" ? i + \"\" : i, e), e);\nimport { ShaderLib as _e, UniformsUtils as Me, MeshDepthMaterial as Te, RGBADepthPacking as De, MeshDistanceMaterial as Ae, ShaderChunk as be, InstancedMesh as Ue, MeshBasicMaterial as Fe, InstancedBufferAttribute as Se, DataTexture as Q, RGBAFormat as L, FloatType as C, NearestFilter as b, ClampToEdgeWrapping as k, RepeatWrapping as q, Vector2 as $, Vector4 as he, BufferGeometry as ee, BufferAttribute as R, OrthographicCamera as Pe, Mesh as Re, Float32BufferAttribute as ie, ShaderMaterial as Ve, WebGLRenderTarget as Ce, PlaneGeometry as Ie, REVISION as ne, ImageLoader as Oe, Texture as Ee, CanvasTexture as re, SRGBColorSpace as se } from \"three\";\nconst pe = /\\bvoid\\s+main\\s*\\(\\s*\\)\\s*{/g;\nfunction j(t) {\n  const i = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n  function e(n, r) {\n    let s = be[r];\n    return s ? j(s) : n;\n  }\n  return t.replace(i, e);\n}\nconst T = [];\nfor (let t = 0; t < 256; t++)\n  T[t] = (t < 16 ? \"0\" : \"\") + t.toString(16);\nfunction $e() {\n  const t = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0;\n  return (T[t & 255] + T[t >> 8 & 255] + T[t >> 16 & 255] + T[t >> 24 & 255] + \"-\" + T[i & 255] + T[i >> 8 & 255] + \"-\" + T[i >> 16 & 15 | 64] + T[i >> 24 & 255] + \"-\" + T[e & 63 | 128] + T[e >> 8 & 255] + \"-\" + T[e >> 16 & 255] + T[e >> 24 & 255] + T[n & 255] + T[n >> 8 & 255] + T[n >> 16 & 255] + T[n >> 24 & 255]).toUpperCase();\n}\nconst U = Object.assign || function() {\n  let t = arguments[0];\n  for (let i = 1, e = arguments.length; i < e; i++) {\n    let n = arguments[i];\n    if (n)\n      for (let r in n)\n        Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);\n  }\n  return t;\n}, ze = Date.now(), ae = /* @__PURE__ */ new WeakMap(), oe = /* @__PURE__ */ new Map();\nlet He = 1e10;\nfunction N(t, i) {\n  const e = Ge(i);\n  let n = ae.get(t);\n  if (n || ae.set(t, n = /* @__PURE__ */ Object.create(null)), n[e])\n    return new n[e]();\n  const r = `_onBeforeCompile${e}`, s = function(o, h) {\n    t.onBeforeCompile.call(this, o, h);\n    const g = this.customProgramCacheKey() + \"|\" + o.vertexShader + \"|\" + o.fragmentShader;\n    let c = oe[g];\n    if (!c) {\n      const f = Le(this, o, i, e);\n      c = oe[g] = f;\n    }\n    o.vertexShader = c.vertexShader, o.fragmentShader = c.fragmentShader, U(o.uniforms, this.uniforms), i.timeUniform && (o.uniforms[i.timeUniform] = {\n      get value() {\n        return Date.now() - ze;\n      }\n    }), this[r] && this[r](o);\n  }, a = function() {\n    return l(i.chained ? t : t.clone());\n  }, l = function(o) {\n    const h = Object.create(o, u);\n    return Object.defineProperty(h, \"baseMaterial\", { value: t }), Object.defineProperty(h, \"id\", { value: He++ }), h.uuid = $e(), h.uniforms = U({}, o.uniforms, i.uniforms), h.defines = U({}, o.defines, i.defines), h.defines[`TROIKA_DERIVED_MATERIAL_${e}`] = \"\", h.extensions = U({}, o.extensions, i.extensions), h._listeners = void 0, h;\n  }, u = {\n    constructor: { value: a },\n    isDerivedMaterial: { value: !0 },\n    type: {\n      get: () => t.type,\n      set: (o) => {\n        t.type = o;\n      }\n    },\n    isDerivedFrom: {\n      writable: !0,\n      configurable: !0,\n      value: function(o) {\n        const h = this.baseMaterial;\n        return o === h || h.isDerivedMaterial && h.isDerivedFrom(o) || !1;\n      }\n    },\n    customProgramCacheKey: {\n      writable: !0,\n      configurable: !0,\n      value: function() {\n        return t.customProgramCacheKey() + \"|\" + e;\n      }\n    },\n    onBeforeCompile: {\n      get() {\n        return s;\n      },\n      set(o) {\n        this[r] = o;\n      }\n    },\n    copy: {\n      writable: !0,\n      configurable: !0,\n      value: function(o) {\n        return t.copy.call(this, o), !t.isShaderMaterial && !t.isDerivedMaterial && (U(this.extensions, o.extensions), U(this.defines, o.defines), U(this.uniforms, Me.clone(o.uniforms))), this;\n      }\n    },\n    clone: {\n      writable: !0,\n      configurable: !0,\n      value: function() {\n        const o = new t.constructor();\n        return l(o).copy(this);\n      }\n    },\n    /**\n     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex\n     * transformations and discarded fragments.\n     */\n    getDepthMaterial: {\n      writable: !0,\n      configurable: !0,\n      value: function() {\n        let o = this._depthMaterial;\n        return o || (o = this._depthMaterial = N(\n          t.isDerivedMaterial ? t.getDepthMaterial() : new Te({ depthPacking: De }),\n          i\n        ), o.defines.IS_DEPTH_MATERIAL = \"\", o.uniforms = this.uniforms), o;\n      }\n    },\n    /**\n     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex\n     * transformations and discarded fragments.\n     */\n    getDistanceMaterial: {\n      writable: !0,\n      configurable: !0,\n      value: function() {\n        let o = this._distanceMaterial;\n        return o || (o = this._distanceMaterial = N(\n          t.isDerivedMaterial ? t.getDistanceMaterial() : new Ae(),\n          i\n        ), o.defines.IS_DISTANCE_MATERIAL = \"\", o.uniforms = this.uniforms), o;\n      }\n    },\n    dispose: {\n      writable: !0,\n      configurable: !0,\n      value() {\n        const { _depthMaterial: o, _distanceMaterial: h } = this;\n        o && o.dispose(), h && h.dispose(), t.dispose.call(this);\n      }\n    }\n  };\n  return n[e] = a, new a();\n}\nfunction Le(t, { vertexShader: i, fragmentShader: e }, n, r) {\n  let {\n    vertexDefs: s,\n    vertexMainIntro: a,\n    vertexMainOutro: l,\n    vertexTransform: u,\n    fragmentDefs: o,\n    fragmentMainIntro: h,\n    fragmentMainOutro: g,\n    fragmentColorTransform: c,\n    customRewriter: f,\n    timeUniform: m\n  } = n;\n  if (s = s || \"\", a = a || \"\", l = l || \"\", o = o || \"\", h = h || \"\", g = g || \"\", (u || f) && (i = j(i)), (c || f) && (e = e.replace(\n    /^[ \\t]*#include <((?:tonemapping|encodings|colorspace|fog|premultiplied_alpha|dithering)_fragment)>/gm,\n    `\n//!BEGIN_POST_CHUNK $1\n$&\n//!END_POST_CHUNK\n`\n  ), e = j(e)), f) {\n    let p = f({ vertexShader: i, fragmentShader: e });\n    i = p.vertexShader, e = p.fragmentShader;\n  }\n  if (c) {\n    let p = [];\n    e = e.replace(\n      /^\\/\\/!BEGIN_POST_CHUNK[^]+?^\\/\\/!END_POST_CHUNK/gm,\n      // [^]+? = non-greedy match of any chars including newlines\n      (d) => (p.push(d), \"\")\n    ), g = `${c}\n${p.join(`\n`)}\n${g}`;\n  }\n  if (m) {\n    const p = `\nuniform float ${m};\n`;\n    s = p + s, o = p + o;\n  }\n  return u && (i = `vec3 troika_position_${r};\nvec3 troika_normal_${r};\nvec2 troika_uv_${r};\n${i}\n`, s = `${s}\nvoid troikaVertexTransform${r}(inout vec3 position, inout vec3 normal, inout vec2 uv) {\n  ${u}\n}\n`, a = `\ntroika_position_${r} = vec3(position);\ntroika_normal_${r} = vec3(normal);\ntroika_uv_${r} = vec2(uv);\ntroikaVertexTransform${r}(troika_position_${r}, troika_normal_${r}, troika_uv_${r});\n${a}\n`, i = i.replace(/\\b(position|normal|uv)\\b/g, (p, d, w, _) => /\\battribute\\s+vec[23]\\s+$/.test(_.substr(0, w)) ? d : `troika_${d}_${r}`), t.map && t.map.channel > 0 || (i = i.replace(/\\bMAP_UV\\b/g, `troika_uv_${r}`))), i = le(i, r, s, a, l), e = le(e, r, o, h, g), {\n    vertexShader: i,\n    fragmentShader: e\n  };\n}\nfunction le(t, i, e, n, r) {\n  return (n || r || e) && (t = t.replace(\n    pe,\n    `\n${e}\nvoid troikaOrigMain${i}() {`\n  ), t += `\nvoid main() {\n  ${n}\n  troikaOrigMain${i}();\n  ${r}\n}`), t;\n}\nfunction ke(t, i) {\n  return t === \"uniforms\" ? void 0 : typeof i == \"function\" ? i.toString() : i;\n}\nlet Ne = 0;\nconst ue = /* @__PURE__ */ new Map();\nfunction Ge(t) {\n  const i = JSON.stringify(t, ke);\n  let e = ue.get(i);\n  return e == null && ue.set(i, e = ++Ne), e;\n}\nconst Ze = {\n  MeshDepthMaterial: \"depth\",\n  MeshDistanceMaterial: \"distanceRGBA\",\n  MeshNormalMaterial: \"normal\",\n  MeshBasicMaterial: \"basic\",\n  MeshLambertMaterial: \"lambert\",\n  MeshPhongMaterial: \"phong\",\n  MeshToonMaterial: \"toon\",\n  MeshStandardMaterial: \"physical\",\n  MeshPhysicalMaterial: \"physical\",\n  MeshMatcapMaterial: \"matcap\",\n  LineBasicMaterial: \"basic\",\n  LineDashedMaterial: \"dashed\",\n  PointsMaterial: \"points\",\n  ShadowMaterial: \"shadow\",\n  SpriteMaterial: \"sprite\"\n};\nfunction Be(t) {\n  let i = Ze[t.type];\n  return i ? _e[i] : t;\n}\nfunction ce(t) {\n  let i = /\\buniform\\s+(int|float|vec[234]|mat[34])\\s+([A-Za-z_][\\w]*)/g, e = /* @__PURE__ */ Object.create(null), n;\n  for (; (n = i.exec(t)) !== null; )\n    e[n[2]] = n[1];\n  return e;\n}\nfunction Ke(t) {\n  let i = [], e = \"\";\n  const n = N(t, {\n    chained: !0,\n    customRewriter({ vertexShader: s, fragmentShader: a }) {\n      let l = [], u = [], o = [], h = ce(s), g = ce(a);\n      return i.forEach((c) => {\n        let f = h[c], m = g[c];\n        const p = f || m;\n        if (p) {\n          const d = new RegExp(`\\\\buniform\\\\s+${p}\\\\s+${c}\\\\s*;`, \"g\"), w = new RegExp(`\\\\b${c}\\\\b`, \"g\"), _ = `troika_attr_${c}`, x = `troika_vary_${c}`;\n          if (l.push(`attribute ${p} ${_};`), f && (s = s.replace(d, \"\"), s = s.replace(w, _)), m) {\n            a = a.replace(d, \"\"), a = a.replace(w, x);\n            let v = `varying ${m} ${x};`;\n            l.push(v), o.push(v), u.push(`${x} = ${_};`);\n          }\n        }\n      }), s = `${l.join(`\n`)}\n${s.replace(pe, `\n$&\n${u.join(`\n`)}`)}`, o.length && (a = `${o.join(`\n`)}\n${a}`), { vertexShader: s, fragmentShader: a };\n    }\n  });\n  n.setUniformNames = function(s) {\n    i = s || [];\n    const a = i.sort().join(\"|\");\n    a !== e && (e = a, this.needsUpdate = !0);\n  };\n  const r = n.customProgramCacheKey();\n  return n.customProgramCacheKey = function() {\n    return r + \"|\" + e;\n  }, n.isInstancedUniformsMaterial = !0, n;\n}\nclass je extends Ue {\n  constructor(i, e, n) {\n    super(i, e, n), this._maxCount = n, this._instancedUniformNames = [];\n  }\n  /*\n   * Getter/setter for automatically wrapping the user-supplied geometry with one that will\n   * carry our extra InstancedBufferAttribute(s). We do the wrapping lazily on _read_ rather\n   * than write to avoid unnecessary wrapping on transient values.\n   */\n  get geometry() {\n    let i = this._derivedGeometry;\n    const e = this._baseGeometry;\n    return (!i || i.baseGeometry !== e) && (i = this._derivedGeometry = Object.create(e), i.baseGeometry = e, i.attributes = Object.create(e.attributes), e.addEventListener(\"dispose\", function n() {\n      e.removeEventListener(\"dispose\", n), i.dispose();\n    })), i;\n  }\n  set geometry(i) {\n    this._baseGeometry = i;\n  }\n  /*\n   * Getter/setter for automatically wrapping the user-supplied material with our upgrades. We do the\n   * wrapping lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\n   */\n  get material() {\n    let i = this._derivedMaterial;\n    const e = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = new Fe());\n    return (!i || i.baseMaterial !== e) && (i = this._derivedMaterial = Ke(e), e.addEventListener(\"dispose\", function n() {\n      e.removeEventListener(\"dispose\", n), i.dispose();\n    })), i.setUniformNames(this._instancedUniformNames), i;\n  }\n  set material(i) {\n    if (Array.isArray(i))\n      throw new Error(\"InstancedUniformsMesh does not support multiple materials\");\n    for (; i && i.isInstancedUniformsMaterial; )\n      i = i.baseMaterial;\n    this._baseMaterial = i;\n  }\n  get customDepthMaterial() {\n    return this.material.getDepthMaterial();\n  }\n  set customDepthMaterial(i) {\n  }\n  get customDistanceMaterial() {\n    return this.material.getDistanceMaterial();\n  }\n  set customDistanceMaterial(i) {\n  }\n  /**\n   * Set the value of a shader uniform for a single instance.\n   * @param {string} name - the name of the shader uniform\n   * @param {number} index - the index of the instance to set the value for\n   * @param {number|Vector2|Vector3|Vector4|Color|Array|Matrix3|Matrix4|Quaternion} value - the uniform value for this instance\n   */\n  setUniformAt(i, e, n) {\n    const r = this.geometry.attributes, s = `troika_attr_${i}`;\n    let a = r[s];\n    if (!a) {\n      const l = We(this._baseMaterial, i), u = Ye(l);\n      if (a = r[s] = new Se(new Float32Array(u * this._maxCount), u), l !== null)\n        for (let o = 0; o < this._maxCount; o++)\n          fe(a, o, l);\n      this._instancedUniformNames = [...this._instancedUniformNames, i];\n    }\n    fe(a, e, n), a.needsUpdate = !0;\n  }\n  /**\n   * Unset all instance-specific values for a given uniform, reverting back to the original\n   * uniform value for all.\n   * @param {string} name\n   */\n  unsetUniform(i) {\n    this.geometry.deleteAttribute(`troika_attr_${i}`), this._instancedUniformNames = this._instancedUniformNames.filter((e) => e !== i);\n  }\n}\nfunction fe(t, i, e) {\n  let n = t.itemSize;\n  n === 1 ? t.setX(i, e) : n === 2 ? t.setXY(i, e.x, e.y) : n === 3 ? e.isColor ? t.setXYZ(i, e.r, e.g, e.b) : t.setXYZ(i, e.x, e.y, e.z) : n === 4 ? t.setXYZW(i, e.x, e.y, e.z, e.w) : e.toArray ? e.toArray(t.array, i * n) : t.set(e, i * n);\n}\nfunction We(t, i) {\n  let e = t.uniforms;\n  return e && e[i] || (e = Be(t).uniforms, e && e[i]) ? e[i].value : null;\n}\nfunction Ye(t) {\n  return t == null ? 0 : typeof t == \"number\" ? 1 : t.isVector2 ? 2 : t.isVector3 || t.isColor ? 3 : t.isVector4 || t.isQuaternion ? 4 : t.elements ? t.elements.length : Array.isArray(t) ? t.length : 0;\n}\nconst Xe = (t, i) => {\n  const e = t.split(`\n`), n = /vMapUv|vAlphaMapUv|vNormalMapUv/g;\n  return e.map((s) => !s.includes(\"varying\") && !s.includes(\"uniform\") ? s.replace(n, i) : s).join(`\n`);\n}, Je = (t, i) => {\n  const e = {\n    USE_UV: \"\"\n  };\n  return i && (e.TRI_GEOMETRY = \"\"), N(t, {\n    defines: e,\n    uniforms: {\n      /** GPGPU animation driven data */\n      animationData: { value: null },\n      animationDataSize: { value: 0 },\n      /* Repeat animation in a loop */\n      billboarding: { value: 0 },\n      /** flip uvs on x */\n      flipX: { value: 0 },\n      /** flip uvs on y */\n      flipY: { value: 0 },\n      /**\n       * DataArrayTexture - data stored in columns. Rows are:\n       * 0 - Frames declaration - RGBA[x,y,w,h]\n       * 1 - Animation lengths RGBA[length,0,0,0]\n       * 2 - Animation0 - RGBA [id,duration, 0,0]\n       * 3 - Animation1 - RGBA [id,duration, 0,0]\n       * ....etc\n       */\n      spritesheetData: { value: null },\n      /**util for reading data texture in spritesheetData */\n      dataSize: { value: new $(0, 0) },\n      /**\n       * Tinting - Vector4 (enabled 0/1, H (0-3), S (0-1), V(0-1))\n       */\n      tint: { value: new he(0, 0, 0, 0) }\n    },\n    /**\n     *\n     * VERTEX\n     * - billboarding\n     *\n     * */\n    vertexDefs: (\n      /*glsl*/\n      `\n    uniform float billboarding;\n    flat varying int vId;\n    `\n    ),\n    vertexMainOutro: (\n      /*glsl*/\n      `\n    vId = gl_InstanceID;\n    if(billboarding == 1.){\n      vec3 instancePosition = vec3(instanceMatrix[3]);\n      vec3 instanceScale = vec3(length(instanceMatrix[0]), length(instanceMatrix[1]), length(instanceMatrix[2]));\n\n      vec3 cameraRight_worldspace = vec3(modelViewMatrix[0][0], modelViewMatrix[1][0], modelViewMatrix[2][0]);\n      vec3 cameraUp_worldspace = vec3(modelViewMatrix[0][1], modelViewMatrix[1][1], modelViewMatrix[2][1]);\n\n      vec3 vertexPosition_worldspace = instancePosition\n        + cameraRight_worldspace * position.x * instanceScale.x\n        + cameraUp_worldspace * position.y * instanceScale.y;\n\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(vertexPosition_worldspace, 1.0);\n    }\n    `\n    ),\n    /**\n     *\n     * FRAGMENT REWRITER\n     *\n     * */\n    customRewriter: ({ vertexShader: r, fragmentShader: s }) => {\n      const a = (\n        /*glsl*/\n        `\n\t\t\tuniform sampler2D animationData;\n      uniform int animationDataSize;\n\t\t\tuniform sampler2D spritesheetData;\n      uniform float startTime;\n\t\t\tuniform float time;\n\t\t\tuniform float flipX;\n\t\t\tuniform float flipY;\n\t\t\tuniform vec2 dataSize;\n      uniform vec4 tint;\n\n      flat varying int vId;\n\t\t\t`\n      ), l = (\n        /*glsl*/\n        `\n\t\t\tvec4 readData(float col, float row) {\n\t\t\t\tfloat wStep = 1.f / dataSize.x;\n\t\t\t\tfloat wHalfStep = wStep * 0.5f;\n\t\t\t\tfloat hStep = 1.f / dataSize.y;\n\t\t\t\tfloat hHalfStep = 1.f / dataSize.y * 0.5f;\n\t\t\t\treturn texture2D(spritesheetData, vec2(col * wStep + wHalfStep, row * hStep + hHalfStep));\n\t\t\t}\n\n      vec2 zoomUV(vec2 uv, vec2 zoomCenter, float zoomFactor) {\n        // Shift UVs so that the zoom center is the origin\n        vec2 shiftedUV = uv - zoomCenter;\n\n        // Scale (zoom) the UV coordinates\n        shiftedUV *= zoomFactor;\n\n        // Shift back\n        shiftedUV += zoomCenter;\n\n        return shiftedUV;\n    }\n\t\t\t`\n      ), u = (\n        /*glsl*/\n        `\n      float y = float(vId / animationDataSize) / float(animationDataSize);\n      float x = mod(float(vId),float(animationDataSize)) / float(animationDataSize);\n\n      float spritesheetFrameId = texture2D(animationData, vec2(x,y)).r;\n\n\t\t\t// x,y,w,h\n\t\t\tvec4 frameMeta = readData(spritesheetFrameId, 0.f);\n\n\t\t\tvec2 fSize = frameMeta.zw;\n\t\t\tvec2 fOffset = vec2(frameMeta.xy);\n\n      vec2 transformedPlaneUv = vUv + vec2(0.,0.);\n\n      // todo  == 1. caused a flickering bug. look into Precision/interpolation?\n      if(flipX > 0.){\n        transformedPlaneUv.x = 1. - transformedPlaneUv.x;\n      }\n      if(flipY > 0.){\n        transformedPlaneUv.y = 1. - transformedPlaneUv.y;\n      }\n\n\t\t\tvec2 spriteUv = fSize * transformedPlaneUv + fOffset ;\n\n      #ifdef TRI_GEOMETRY\n        // Shift UVs if mesh uses triangle geometry\n        // TODO optimize ugly math\n        if(vUv.y>0.5 || vUv.x<0.25 || vUv.x>0.75){\n          discard;\n        }\n\n        vec2 zoomCenter = vec2(fSize.x * 0.5,0.) + fOffset;\n        float zoomFactor = 2.;\n        vec2 shiftedUV = spriteUv - zoomCenter;\n        shiftedUV *= zoomFactor;\n        shiftedUV += zoomCenter;\n        spriteUv = shiftedUV;\n      #endif\n\n\n\n\t\t\t`\n      );\n      return s = s.replace(\n        \"void main() {\",\n        `void main() {${u}`\n      ), s = `\n\t\t\t${a}\n\t\t\t${l}\n\t\t\t${s}\n\t\t\t`, s = s.replace(\n        \"vec4 sampledDiffuseColor = texture2D( map, vMapUv );\",\n        /*glsl*/\n        `\n        vec4 sampledDiffuseColor = texture2D( map, vMapUv );\n        if(tint.w == 1.){\n          vec3 hue_term = 1.0 - min(abs(vec3(tint.x) - vec3(0,2.0,1.0)), 1.0);\n          hue_term.x = 1.0 - dot(hue_term.yz, vec2(1));\n          vec3 res = vec3(dot(sampledDiffuseColor.xyz, hue_term.xyz), dot(sampledDiffuseColor.xyz, hue_term.zxy), dot(sampledDiffuseColor.xyz, hue_term.yzx));\n          res = mix(vec3(dot(res, vec3(0.2, 0.5, 0.3))), res, tint.y);\n          res = res * tint.z;\n\n          sampledDiffuseColor = vec4(res, sampledDiffuseColor.a);\n        }\n\n        // sampledDiffuseColor = vec4(texture2D(animationData, vUv).rgb, 1.);\n      `\n      ), s = Xe(s, \"spriteUv\"), { vertexShader: r, fragmentShader: s };\n    }\n  });\n}, Yt = (t) => {\n  const i = [], e = [], n = {}, r = [], s = t.meta.size.w, a = t.meta.size.h, l = [\n    t.meta.size.w,\n    t.meta.size.h\n  ];\n  for (const u in t.frames) {\n    const o = t.frames[u];\n    i.push([o.frame.x / s, o.frame.y / a, o.frame.w / s, o.frame.h / a]), e.push(o.duration);\n  }\n  for (const u of t.meta.frameTags) {\n    n[u.name] = [];\n    for (let o = u.from; o <= u.to; o++)\n      n[u.name].push([o, e[o]]);\n    r.push(n[u.name].length);\n  }\n  return { frames: i, animations: n, sheetSize: l, animationLengths: r };\n}, Qe = (t) => {\n  const { frames: i, animationLengths: e, animations: n } = t, r = Math.max(\n    i.length,\n    e.length,\n    ...Object.values(n).map((f) => f.length)\n  ), s = 2 + Object.values(n).length, a = i.flat().concat(new Array((r - i.length) * 4).fill(0)), l = e.map((f) => [f, 0, 0, 0]).flat().concat(new Array((r - e.length) * 4).fill(0)), u = [], o = /* @__PURE__ */ new Map();\n  for (let f = 0; f < Object.keys(n).length; f++) {\n    const m = Object.keys(n)[f];\n    o.set(m, f);\n    const p = n[m].map((d) => [...d, 0, 0]).flat().concat(new Array((r - n[m].length) * 4).fill(0));\n    u.push(...p);\n  }\n  const h = [\n    ...a,\n    ...l,\n    ...u\n  ], g = new Float32Array(h);\n  g.set(h);\n  const c = new Q(\n    g,\n    r,\n    s,\n    L,\n    C\n  );\n  return c.type = C, c.minFilter = b, c.magFilter = b, c.wrapS = k, c.wrapT = q, c.needsUpdate = !0, { dataTexture: c, dataWidth: r, dataHeight: s, animMap: o };\n}, qe = () => {\n  const t = new ee(), i = new Float32Array([\n    // top\n    0,\n    1,\n    0,\n    // bot-left\n    -1,\n    -1,\n    0,\n    // bot-right\n    1,\n    -1,\n    0\n  ]);\n  t.setAttribute(\"position\", new R(i, 3));\n  const e = new Float32Array([\n    // top\n    0.5,\n    1,\n    // bot-left\n    0,\n    0,\n    // bot-right\n    1,\n    0\n  ]);\n  return t.setAttribute(\"uv\", new R(e, 2)), t.computeVertexNormals(), t;\n}, et = new Pe(-1, 1, 1, -1, 0, 1);\nclass tt extends ee {\n  constructor() {\n    super(), this.setAttribute(\"position\", new ie([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), this.setAttribute(\"uv\", new ie([0, 2, 0, 0, 2, 0], 2));\n  }\n}\nconst it = new tt();\nclass nt {\n  constructor(i) {\n    this._mesh = new Re(it, i);\n  }\n  dispose() {\n    this._mesh.geometry.dispose();\n  }\n  render(i) {\n    i.render(this._mesh, et);\n  }\n  get material() {\n    return this._mesh.material;\n  }\n  set material(i) {\n    this._mesh.material = i;\n  }\n}\nclass rt {\n  constructor(i, e, n) {\n    this.variables = [], this.currentTextureIndex = 0;\n    let r = C;\n    const s = {\n      passThruTexture: { value: null }\n    }, a = o(g(), s), l = new nt(a);\n    this.setDataType = function(c) {\n      return r = c, this;\n    }, this.addVariable = function(c, f, m) {\n      const p = this.createShaderMaterial(f), d = {\n        name: c,\n        initialValueTexture: m,\n        material: p,\n        dependencies: null,\n        renderTargets: [],\n        wrapS: null,\n        wrapT: null,\n        minFilter: b,\n        magFilter: b\n      };\n      return this.variables.push(d), d;\n    }, this.setVariableDependencies = function(c, f) {\n      c.dependencies = f;\n    }, this.init = function() {\n      if (n.capabilities.maxVertexTextures === 0)\n        return \"No support for vertex shader textures.\";\n      for (let c = 0; c < this.variables.length; c++) {\n        const f = this.variables[c];\n        f.renderTargets[0] = this.createRenderTarget(i, e, f.wrapS, f.wrapT, f.minFilter, f.magFilter), f.renderTargets[1] = this.createRenderTarget(i, e, f.wrapS, f.wrapT, f.minFilter, f.magFilter), this.renderTexture(f.initialValueTexture, f.renderTargets[0]), this.renderTexture(f.initialValueTexture, f.renderTargets[1]);\n        const m = f.material, p = m.uniforms;\n        if (f.dependencies !== null)\n          for (let d = 0; d < f.dependencies.length; d++) {\n            const w = f.dependencies[d];\n            if (w.name !== f.name) {\n              let _ = !1;\n              for (let x = 0; x < this.variables.length; x++)\n                if (w.name === this.variables[x].name) {\n                  _ = !0;\n                  break;\n                }\n              if (!_)\n                return \"Variable dependency not found. Variable=\" + f.name + \", dependency=\" + w.name;\n            }\n            p[w.name] = { value: null }, m.fragmentShader = `\nuniform sampler2D ` + w.name + `;\n` + m.fragmentShader;\n          }\n      }\n      return this.currentTextureIndex = 0, null;\n    }, this.compute = function() {\n      const c = this.currentTextureIndex, f = this.currentTextureIndex === 0 ? 1 : 0;\n      for (let m = 0, p = this.variables.length; m < p; m++) {\n        const d = this.variables[m];\n        if (d.dependencies !== null) {\n          const w = d.material.uniforms;\n          for (let _ = 0, x = d.dependencies.length; _ < x; _++) {\n            const v = d.dependencies[_];\n            w[v.name].value = v.renderTargets[c].texture;\n          }\n        }\n        this.doRenderTarget(d.material, d.renderTargets[f]);\n      }\n      this.currentTextureIndex = f;\n    }, this.getCurrentRenderTarget = function(c) {\n      return c.renderTargets[this.currentTextureIndex];\n    }, this.getAlternateRenderTarget = function(c) {\n      return c.renderTargets[this.currentTextureIndex === 0 ? 1 : 0];\n    }, this.dispose = function() {\n      l.dispose();\n      const c = this.variables;\n      for (let f = 0; f < c.length; f++) {\n        const m = c[f];\n        m.initialValueTexture && m.initialValueTexture.dispose();\n        const p = m.renderTargets;\n        for (let d = 0; d < p.length; d++)\n          p[d].dispose();\n      }\n    };\n    function u(c) {\n      c.defines.resolution = \"vec2( \" + i.toFixed(1) + \", \" + e.toFixed(1) + \" )\";\n    }\n    this.addResolutionDefine = u;\n    function o(c, f) {\n      f = f || {};\n      const m = new Ve({\n        name: \"GPUComputationShader\",\n        uniforms: f,\n        vertexShader: h(),\n        fragmentShader: c\n      });\n      return u(m), m;\n    }\n    this.createShaderMaterial = o, this.createRenderTarget = function(c, f, m, p, d, w) {\n      return c = c || i, f = f || e, m = m || k, p = p || k, d = d || b, w = w || b, new Ce(c, f, {\n        wrapS: m,\n        wrapT: p,\n        minFilter: d,\n        magFilter: w,\n        format: L,\n        type: r,\n        depthBuffer: !1\n      });\n    }, this.createTexture = function() {\n      const c = new Float32Array(i * e * 4), f = new Q(c, i, e, L, C);\n      return f.needsUpdate = !0, f;\n    }, this.renderTexture = function(c, f) {\n      s.passThruTexture.value = c, this.doRenderTarget(a, f), s.passThruTexture.value = null;\n    }, this.doRenderTarget = function(c, f) {\n      const m = n.getRenderTarget(), p = n.xr.enabled, d = n.shadowMap.autoUpdate;\n      n.xr.enabled = !1, n.shadowMap.autoUpdate = !1, l.material = c, n.setRenderTarget(f), l.render(n), l.material = a, n.xr.enabled = p, n.shadowMap.autoUpdate = d, n.setRenderTarget(m);\n    };\n    function h() {\n      return `void main()\t{\n\n\tgl_Position = vec4( position, 1.0 );\n\n}\n`;\n    }\n    function g() {\n      return `uniform sampler2D passThruTexture;\n\nvoid main() {\n\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\n\n\tgl_FragColor = texture2D( passThruTexture, uv );\n\n}\n`;\n    }\n  }\n}\nconst st = (\n  /*glsl*/\n  `\n  #include <common>\n  uniform sampler2D instructionsTexture;\n\n  uniform sampler2D spritesheetData;\n  uniform vec2 dataSize;\n  uniform float fps;\n  uniform float deltaTime;\n\n  // read spritesheet metadata\n  vec4 readData(float col, float row, sampler2D tex) {\n    float wStep = 1.f / dataSize.x;\n    float wHalfStep = wStep * 0.5f;\n    float hStep = 1.f / dataSize.y;\n    float hHalfStep = 1.f / dataSize.y * 0.5f;\n    return texture2D(spritesheetData, vec2(col * wStep + wHalfStep, row * hStep + hHalfStep));\n  }\n\n\n\n  void main()\t{\n\n    // OUTPUT FROM THIS SHADER\n    // progressValue.r - picked animation frame\n    // progressValue.g - previous progress state (for pause, reverse & pingpong consistency)\n    // progressValue.b - not used yet\n    // progressValue.a - previous animationID\n\n    vec2 cellSize = 1.0 / resolution.xy;\n    vec2 uv = gl_FragCoord.xy * cellSize;\n\n\n    vec4 progressValue = texture2D( progress, uv );\n\n    vec4 instructions = texture2D( instructionsTexture, uv);\n\n    // FREEZE FRAME - return to save calculations?\n    if(instructions.a >=10.){\n      progressValue.r = instructions.a - 10.;\n      progressValue.a = instructions.x;\n      progressValue.g = progressValue.g;\n      gl_FragColor = progressValue;\n      return;\n    }\n\n\n    progressValue.b = 0.;\n\n    // todo shouldn't be rounding here, pick\n    float animationId = round(instructions.x);\n\n    float offset = instructions.g;\n\n    float animLength = readData(animationId, 1.f, spritesheetData).r;\n    float totalTime = animLength / fps;\n\n    // new delta is % of animation\n    float newProgress = deltaTime / totalTime;\n    // add new delta to saved progress\n    float frameTimedId = mod(progressValue.g + newProgress, 1.);\n    // frameTimedId = 0.;\n    // float frameTimedId = progressValue.g;\n    // save for use in next frame\n\n\n\n    float playMode = mod(instructions.b, 10.);\n\n    // forward\n    if(playMode == 0.){\n      frameTimedId = progressValue.g + newProgress;\n    }\n    // reverse\n    if(playMode == 1.){\n      frameTimedId = progressValue.g - newProgress;\n    }\n    // 2 - pause - do nothing\n    if(playMode == 2.){\n      frameTimedId = progressValue.g;\n    }\n\n    // //todo pingpong\n    // if(playMode == 3.){\n    // }\n\n    // loop (play once over 10.)\n    if(instructions.b < 10.){\n      frameTimedId = mod(frameTimedId, 1.);\n    }\n\n    // todo This could be optional and user would reset manually,\n    // todo allowing for consistent movement across multiple animations\n    // todo for example - running steps being syncec\n    // start anim from beginning if animationID changes\n    if(progressValue.a != instructions.x){\n      frameTimedId = 0.;\n    }\n\n    float frameId = floor(animLength * frameTimedId);\n    float spritesheetFrameId = readData(frameId, 2.f + animationId, spritesheetData).r;\n\n\n\n    // Picked sprite frame that goes to material\n    progressValue.r = spritesheetFrameId;\n\n    progressValue.a = instructions.x;\n    progressValue.g = frameTimedId;\n\n    gl_FragColor = progressValue;\n  }\n`\n), at = (t = 512) => {\n  const i = new Float32Array(t ** 2 * 4);\n  for (let n = 0; n < t ** 2 * 4; n++)\n    i[n] = 0;\n  const e = new Q(\n    i,\n    t,\n    t,\n    L,\n    C\n  );\n  return e.minFilter = b, e.magFilter = b, e.wrapS = k, e.wrapT = q, e.needsUpdate = !0, e;\n}, ot = (t) => {\n  if (t <= 0)\n    return 1;\n  let i = 1;\n  for (; i < t; )\n    i <<= 1;\n  return i;\n}, lt = (t, i) => {\n  const e = ot(Math.sqrt(i)), n = new rt(\n    e,\n    e,\n    t\n  ), r = n.createTexture(), s = n.addVariable(\n    \"progress\",\n    st,\n    r\n  ), a = at(e);\n  s.material.uniforms.instructionsTexture = {\n    value: a\n  }, s.material.uniforms.spritesheetData = { value: null }, s.material.uniforms.fps = { value: 0 }, s.material.uniforms.deltaTime = { value: 0 }, s.material.uniforms.dataSize = { value: new $() }, n.setVariableDependencies(s, [s]);\n  const l = n.init();\n  l !== null && console.error(l);\n  let u = !1;\n  return {\n    gpuCompute: n,\n    animationRunner: s,\n    progressDataTexture: a,\n    utils: {\n      updateAnimationAt: (m, p) => {\n        const d = m * 4;\n        a.image.data[d] = p, u = !0;\n      },\n      updateOffsetAt: (m, p) => {\n        const d = m * 4;\n        a.image.data[d + 1] = p, u = !0;\n      },\n      updatePlaymodeAt: (m, p) => {\n        const d = m * 4;\n        a.image.data[d + 2] = p, u = !0;\n      },\n      updateFrameAt: (m, p) => {\n        const d = m * 4;\n        a.image.data[d + 3] = p + 10, u = !0;\n      }\n    },\n    update: () => {\n      u && (a.needsUpdate = !0, u = !1), n.compute();\n    }\n  };\n};\nclass ut {\n  constructor() {\n    y(this, \"_previousTime\");\n    y(this, \"_currentTime\");\n    y(this, \"_startTime\");\n    y(this, \"_delta\");\n    y(this, \"_elapsed\");\n    y(this, \"_timescale\");\n    y(this, \"_useFixedDelta\");\n    y(this, \"_fixedDelta\");\n    y(this, \"_usePageVisibilityAPI\");\n    y(this, \"_pageVisibilityHandler\");\n    this._previousTime = 0, this._currentTime = 0, this._startTime = B(), this._delta = 0, this._elapsed = 0, this._timescale = 1, this._useFixedDelta = !1, this._fixedDelta = 16.67, this._usePageVisibilityAPI = typeof document < \"u\" && document.hidden !== void 0, this._usePageVisibilityAPI === !0 && (this._pageVisibilityHandler = ct.bind(this), document.addEventListener(\n      \"visibilitychange\",\n      this._pageVisibilityHandler,\n      !1\n    ));\n  }\n  disableFixedDelta() {\n    return this._useFixedDelta = !1, this;\n  }\n  dispose() {\n    return this._usePageVisibilityAPI === !0 && document.removeEventListener(\n      \"visibilitychange\",\n      this._pageVisibilityHandler\n    ), this;\n  }\n  enableFixedDelta() {\n    return this._useFixedDelta = !0, this;\n  }\n  getDelta() {\n    return this._delta / 1e3;\n  }\n  getElapsed() {\n    return this._elapsed / 1e3;\n  }\n  getFixedDelta() {\n    return this._fixedDelta / 1e3;\n  }\n  getTimescale() {\n    return this._timescale;\n  }\n  reset() {\n    return this._currentTime = B() - this._startTime, this;\n  }\n  setFixedDelta(i) {\n    return this._fixedDelta = i * 1e3, this;\n  }\n  setTimescale(i) {\n    return this._timescale = i, this;\n  }\n  update() {\n    return this._useFixedDelta === !0 ? this._delta = this._fixedDelta : (this._previousTime = this._currentTime, this._currentTime = B() - this._startTime, this._delta = this._currentTime - this._previousTime), this._delta *= this._timescale, this._elapsed += this._delta, this;\n  }\n}\nfunction B() {\n  return (typeof performance > \"u\" ? Date : performance).now();\n}\nfunction ct() {\n  document.hidden === !1 && this.reset();\n}\nconst K = {\n  FORWARD: 0,\n  REVERSE: 1,\n  PAUSE: 2,\n  PINGPONG: 3\n};\nclass Xt extends je {\n  constructor(e, n, r, s = {\n    geometry: \"quad\"\n  }) {\n    let a;\n    s.geometry || (s.geometry = \"quad\"), s.geometry === \"tri\" && (a = qe()), s.geometry === \"quad\" && (a = new Ie(1, 1)), s.geometry && typeof s.geometry != \"string\" && (a = s.geometry);\n    const l = Je(\n      e,\n      (s == null ? void 0 : s.geometry) === \"tri\"\n    );\n    super(a, l, n);\n    y(this, \"_spriteMaterial\");\n    y(this, \"_spritesheet\");\n    y(this, \"_animationMap\");\n    y(this, \"_fps\", 15);\n    y(this, \"_timer\");\n    y(this, \"compute\");\n    ne >= 159 ? (this.instanceMatrix.clearUpdateRanges(), this.instanceMatrix.addUpdateRange(0, n * 16)) : this.instanceMatrix.updateRange.count = n * 16, this.instanceColor && (ne >= 159 ? (this.instanceColor.clearUpdateRanges(), this.instanceColor.addUpdateRange(0, n * 3)) : this.instanceColor.updateRange.count = n * 3), this.compute = lt(r, n), this._spriteMaterial = l, s.spritesheet && this.updateSpritesheet(s.spritesheet), this._timer = new ut(), this._animationMap = /* @__PURE__ */ new Map(), this._spriteMaterial.uniforms.animationData.value = this.compute.gpuCompute.getCurrentRenderTarget(\n      this.compute.animationRunner\n    ).texture, this._spriteMaterial.uniforms.animationDataSize.value = this.compute.progressDataTexture.image.width;\n  }\n  updateSpritesheet(e) {\n    const { dataTexture: n, dataWidth: r, dataHeight: s, animMap: a } = Qe(e);\n    this._spriteMaterial.uniforms.spritesheetData.value = n, this._spriteMaterial.uniforms.dataSize.value.x = r, this._spriteMaterial.uniforms.dataSize.value.y = s, this.compute.animationRunner.material.uniforms.dataSize.value = new $(r, s), this.compute.animationRunner.material.uniforms.spritesheetData.value = n, this._animationMap = a;\n  }\n  get spritesheet() {\n    return this._spritesheet;\n  }\n  set spritesheet(e) {\n    this.updateSpritesheet(e), this._spritesheet = e;\n  }\n  get animationMap() {\n    return this._animationMap;\n  }\n  get animation() {\n    return {\n      setAt: (e, n) => {\n        this.compute.utils.updateAnimationAt(\n          e,\n          this._animationMap.get(n) || 0\n        );\n      }\n    };\n  }\n  get frame() {\n    return {\n      setAt: (e, n, r) => {\n        var a;\n        let s = n;\n        r && (s = (a = this.spritesheet) == null ? void 0 : a.animations[r][n][0]), this.compute.utils.updateFrameAt(e, s);\n      },\n      unsetAt: (e) => {\n        this.compute.utils.updateFrameAt(e, -10);\n      },\n      unsetAll: () => {\n        for (let e = 0; e < this.count; e++)\n          this.compute.utils.updateFrameAt(e, -10);\n      }\n    };\n  }\n  get playmode() {\n    return {\n      setAt: (e, n) => {\n        this.compute.utils.updatePlaymodeAt(e, K[n]);\n      },\n      setAll: (e) => {\n        for (let n = 0; n < this.count; n++) {\n          const r = this.compute.progressDataTexture.image.data[n * 4 + 2] >= 10 ? 10 : 0;\n          this.compute.utils.updatePlaymodeAt(n, r + K[e]);\n        }\n      }\n    };\n  }\n  get billboarding() {\n    return {\n      setAt: (e, n) => {\n        this.setUniformAt(\"billboarding\", e, n ? 1 : 0);\n      },\n      setAll: (e) => {\n        this._spriteMaterial.uniforms.billboarding.value = e ? 1 : 0;\n      },\n      unsetAll: () => {\n        this.unsetUniform(\"billboarding\");\n      }\n    };\n  }\n  get offset() {\n    return {\n      setAt: (e, n) => {\n        this.compute.utils.updateOffsetAt(e, n);\n      },\n      randomizeAll: (e = 1) => {\n        for (let n = 0; n < this.count; n++)\n          this.compute.utils.updateOffsetAt(n, Math.random() * e);\n      }\n    };\n  }\n  get loop() {\n    return {\n      setAt: (e, n) => {\n        const r = this.compute.progressDataTexture.image.data[e * 4 + 2] % 10;\n        this.compute.utils.updatePlaymodeAt(\n          e,\n          r + (n ? 0 : 10)\n        );\n      },\n      setAll: (e) => {\n        for (let n = 0; n < this.count; n++) {\n          const r = this.compute.progressDataTexture.image.data[n * 4 + 2] % 10;\n          this.compute.utils.updatePlaymodeAt(n, r + (e ? 0 : 10));\n        }\n      }\n    };\n  }\n  get flipX() {\n    return {\n      setAt: (e, n) => {\n        this.setUniformAt(\"flipX\", e, n ? 1 : 0);\n      },\n      setGlobal: (e) => {\n        this._spriteMaterial.uniforms.flipX.value = e ? 1 : 0;\n      },\n      unsetAll: () => {\n        this.unsetUniform(\"flipX\");\n      }\n    };\n  }\n  get flipY() {\n    return {\n      setAt: (e, n) => {\n        this.setUniformAt(\"flipY\", e, n ? 1 : 0);\n      },\n      setGlobal: (e) => {\n        this._spriteMaterial.uniforms.flipY.value = e ? 1 : 0;\n      },\n      unsetAll: () => {\n        this.unsetUniform(\"flipY\");\n      }\n    };\n  }\n  play(e, n = !0, r = \"FORWARD\") {\n    return {\n      at: (s) => {\n        this.compute.utils.updateAnimationAt(\n          s,\n          this._animationMap.get(e) || 0\n        ), this.compute.utils.updatePlaymodeAt(\n          s,\n          K[r] + (n ? 0 : 10)\n        );\n      }\n    };\n  }\n  /** HSV shift tinting */\n  get hueShift() {\n    const e = new he();\n    return {\n      // TODO - per instance tinting doesnt work - artifacts\n      // setAt: (\n      //   instanceId: number,\n      //   tint?: { h: number; s: number; v: number }\n      // ) => {\n      //   if (tint) {\n      //     tVector.set(tint.h, tint.s, tint.v, 1);\n      //   } else {\n      //     tVector.setW(0);\n      //   }\n      //   this.setUniformAt(\"tint\", instanceId, tVector);\n      // },\n      setGlobal: (n) => {\n        n ? e.set(n.h, n.s, n.v, 1) : e.setW(0), this._spriteMaterial.uniforms.tint.value = e;\n      }\n      // unsetAll: () => {\n      //   this.unsetUniform(\"tint\");\n      // },\n    };\n  }\n  get fps() {\n    return this._fps;\n  }\n  set fps(e) {\n    this._fps = e, this.compute.animationRunner.material.uniforms.fps.value = e;\n  }\n  update() {\n    this._timer.update();\n    const e = this._timer.getDelta();\n    this.compute.animationRunner.material.uniforms.deltaTime.value = e, this.compute.update();\n  }\n}\nfunction ft(t) {\n  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, \"default\") ? t.default : t;\n}\nvar te = { exports: {} };\nte.exports = G;\nte.exports.default = G;\nfunction G(t, i, e) {\n  e = e || 2;\n  var n = i && i.length, r = n ? i[0] * e : t.length, s = de(t, 0, r, e, !0), a = [];\n  if (!s || s.next === s.prev)\n    return a;\n  var l, u, o, h, g, c, f;\n  if (n && (s = gt(t, i, s, e)), t.length > 80 * e) {\n    l = o = t[0], u = h = t[1];\n    for (var m = e; m < r; m += e)\n      g = t[m], c = t[m + 1], g < l && (l = g), c < u && (u = c), g > o && (o = g), c > h && (h = c);\n    f = Math.max(o - l, h - u), f = f !== 0 ? 32767 / f : 0;\n  }\n  return I(s, a, e, l, u, f, 0), a;\n}\nfunction de(t, i, e, n, r) {\n  var s, a;\n  if (r === X(t, i, e, n) > 0)\n    for (s = i; s < e; s += n)\n      a = me(s, t[s], t[s + 1], a);\n  else\n    for (s = e - n; s >= i; s -= n)\n      a = me(s, t[s], t[s + 1], a);\n  return a && Z(a, a.next) && (E(a), a = a.next), a;\n}\nfunction F(t, i) {\n  if (!t)\n    return t;\n  i || (i = t);\n  var e = t, n;\n  do\n    if (n = !1, !e.steiner && (Z(e, e.next) || M(e.prev, e, e.next) === 0)) {\n      if (E(e), e = i = e.prev, e === e.next)\n        break;\n      n = !0;\n    } else\n      e = e.next;\n  while (n || e !== i);\n  return i;\n}\nfunction I(t, i, e, n, r, s, a) {\n  if (t) {\n    !a && s && _t(t, n, r, s);\n    for (var l = t, u, o; t.prev !== t.next; ) {\n      if (u = t.prev, o = t.next, s ? ht(t, n, r, s) : mt(t)) {\n        i.push(u.i / e | 0), i.push(t.i / e | 0), i.push(o.i / e | 0), E(t), t = o.next, l = o.next;\n        continue;\n      }\n      if (t = o, t === l) {\n        a ? a === 1 ? (t = pt(F(t), i, e), I(t, i, e, n, r, s, 2)) : a === 2 && dt(t, i, e, n, r, s) : I(F(t), i, e, n, r, s, 1);\n        break;\n      }\n    }\n  }\n}\nfunction mt(t) {\n  var i = t.prev, e = t, n = t.next;\n  if (M(i, e, n) >= 0)\n    return !1;\n  for (var r = i.x, s = e.x, a = n.x, l = i.y, u = e.y, o = n.y, h = r < s ? r < a ? r : a : s < a ? s : a, g = l < u ? l < o ? l : o : u < o ? u : o, c = r > s ? r > a ? r : a : s > a ? s : a, f = l > u ? l > o ? l : o : u > o ? u : o, m = n.next; m !== i; ) {\n    if (m.x >= h && m.x <= c && m.y >= g && m.y <= f && V(r, l, s, u, a, o, m.x, m.y) && M(m.prev, m, m.next) >= 0)\n      return !1;\n    m = m.next;\n  }\n  return !0;\n}\nfunction ht(t, i, e, n) {\n  var r = t.prev, s = t, a = t.next;\n  if (M(r, s, a) >= 0)\n    return !1;\n  for (var l = r.x, u = s.x, o = a.x, h = r.y, g = s.y, c = a.y, f = l < u ? l < o ? l : o : u < o ? u : o, m = h < g ? h < c ? h : c : g < c ? g : c, p = l > u ? l > o ? l : o : u > o ? u : o, d = h > g ? h > c ? h : c : g > c ? g : c, w = W(f, m, i, e, n), _ = W(p, d, i, e, n), x = t.prevZ, v = t.nextZ; x && x.z >= w && v && v.z <= _; ) {\n    if (x.x >= f && x.x <= p && x.y >= m && x.y <= d && x !== r && x !== a && V(l, h, u, g, o, c, x.x, x.y) && M(x.prev, x, x.next) >= 0 || (x = x.prevZ, v.x >= f && v.x <= p && v.y >= m && v.y <= d && v !== r && v !== a && V(l, h, u, g, o, c, v.x, v.y) && M(v.prev, v, v.next) >= 0))\n      return !1;\n    v = v.nextZ;\n  }\n  for (; x && x.z >= w; ) {\n    if (x.x >= f && x.x <= p && x.y >= m && x.y <= d && x !== r && x !== a && V(l, h, u, g, o, c, x.x, x.y) && M(x.prev, x, x.next) >= 0)\n      return !1;\n    x = x.prevZ;\n  }\n  for (; v && v.z <= _; ) {\n    if (v.x >= f && v.x <= p && v.y >= m && v.y <= d && v !== r && v !== a && V(l, h, u, g, o, c, v.x, v.y) && M(v.prev, v, v.next) >= 0)\n      return !1;\n    v = v.nextZ;\n  }\n  return !0;\n}\nfunction pt(t, i, e) {\n  var n = t;\n  do {\n    var r = n.prev, s = n.next.next;\n    !Z(r, s) && ge(r, n, n.next, s) && O(r, s) && O(s, r) && (i.push(r.i / e | 0), i.push(n.i / e | 0), i.push(s.i / e | 0), E(n), E(n.next), n = t = s), n = n.next;\n  } while (n !== t);\n  return F(n);\n}\nfunction dt(t, i, e, n, r, s) {\n  var a = t;\n  do {\n    for (var l = a.next.next; l !== a.prev; ) {\n      if (a.i !== l.i && Dt(a, l)) {\n        var u = xe(a, l);\n        a = F(a, a.next), u = F(u, u.next), I(a, i, e, n, r, s, 0), I(u, i, e, n, r, s, 0);\n        return;\n      }\n      l = l.next;\n    }\n    a = a.next;\n  } while (a !== t);\n}\nfunction gt(t, i, e, n) {\n  var r = [], s, a, l, u, o;\n  for (s = 0, a = i.length; s < a; s++)\n    l = i[s] * n, u = s < a - 1 ? i[s + 1] * n : t.length, o = de(t, l, u, n, !1), o === o.next && (o.steiner = !0), r.push(Tt(o));\n  for (r.sort(xt), s = 0; s < r.length; s++)\n    e = vt(r[s], e);\n  return e;\n}\nfunction xt(t, i) {\n  return t.x - i.x;\n}\nfunction vt(t, i) {\n  var e = yt(t, i);\n  if (!e)\n    return i;\n  var n = xe(e, t);\n  return F(n, n.next), F(e, e.next);\n}\nfunction yt(t, i) {\n  var e = i, n = t.x, r = t.y, s = -1 / 0, a;\n  do {\n    if (r <= e.y && r >= e.next.y && e.next.y !== e.y) {\n      var l = e.x + (r - e.y) * (e.next.x - e.x) / (e.next.y - e.y);\n      if (l <= n && l > s && (s = l, a = e.x < e.next.x ? e : e.next, l === n))\n        return a;\n    }\n    e = e.next;\n  } while (e !== i);\n  if (!a)\n    return null;\n  var u = a, o = a.x, h = a.y, g = 1 / 0, c;\n  e = a;\n  do\n    n >= e.x && e.x >= o && n !== e.x && V(r < h ? n : s, r, o, h, r < h ? s : n, r, e.x, e.y) && (c = Math.abs(r - e.y) / (n - e.x), O(e, t) && (c < g || c === g && (e.x > a.x || e.x === a.x && wt(a, e))) && (a = e, g = c)), e = e.next;\n  while (e !== u);\n  return a;\n}\nfunction wt(t, i) {\n  return M(t.prev, t, i.prev) < 0 && M(i.next, t, t.next) < 0;\n}\nfunction _t(t, i, e, n) {\n  var r = t;\n  do\n    r.z === 0 && (r.z = W(r.x, r.y, i, e, n)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next;\n  while (r !== t);\n  r.prevZ.nextZ = null, r.prevZ = null, Mt(r);\n}\nfunction Mt(t) {\n  var i, e, n, r, s, a, l, u, o = 1;\n  do {\n    for (e = t, t = null, s = null, a = 0; e; ) {\n      for (a++, n = e, l = 0, i = 0; i < o && (l++, n = n.nextZ, !!n); i++)\n        ;\n      for (u = o; l > 0 || u > 0 && n; )\n        l !== 0 && (u === 0 || !n || e.z <= n.z) ? (r = e, e = e.nextZ, l--) : (r = n, n = n.nextZ, u--), s ? s.nextZ = r : t = r, r.prevZ = s, s = r;\n      e = n;\n    }\n    s.nextZ = null, o *= 2;\n  } while (a > 1);\n  return t;\n}\nfunction W(t, i, e, n, r) {\n  return t = (t - e) * r | 0, i = (i - n) * r | 0, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, i = (i | i << 8) & 16711935, i = (i | i << 4) & 252645135, i = (i | i << 2) & 858993459, i = (i | i << 1) & 1431655765, t | i << 1;\n}\nfunction Tt(t) {\n  var i = t, e = t;\n  do\n    (i.x < e.x || i.x === e.x && i.y < e.y) && (e = i), i = i.next;\n  while (i !== t);\n  return e;\n}\nfunction V(t, i, e, n, r, s, a, l) {\n  return (r - a) * (i - l) >= (t - a) * (s - l) && (t - a) * (n - l) >= (e - a) * (i - l) && (e - a) * (s - l) >= (r - a) * (n - l);\n}\nfunction Dt(t, i) {\n  return t.next.i !== i.i && t.prev.i !== i.i && !At(t, i) && // dones't intersect other edges\n  (O(t, i) && O(i, t) && bt(t, i) && // locally visible\n  (M(t.prev, t, i.prev) || M(t, i.prev, i)) || // does not create opposite-facing sectors\n  Z(t, i) && M(t.prev, t, t.next) > 0 && M(i.prev, i, i.next) > 0);\n}\nfunction M(t, i, e) {\n  return (i.y - t.y) * (e.x - i.x) - (i.x - t.x) * (e.y - i.y);\n}\nfunction Z(t, i) {\n  return t.x === i.x && t.y === i.y;\n}\nfunction ge(t, i, e, n) {\n  var r = H(M(t, i, e)), s = H(M(t, i, n)), a = H(M(e, n, t)), l = H(M(e, n, i));\n  return !!(r !== s && a !== l || r === 0 && z(t, e, i) || s === 0 && z(t, n, i) || a === 0 && z(e, t, n) || l === 0 && z(e, i, n));\n}\nfunction z(t, i, e) {\n  return i.x <= Math.max(t.x, e.x) && i.x >= Math.min(t.x, e.x) && i.y <= Math.max(t.y, e.y) && i.y >= Math.min(t.y, e.y);\n}\nfunction H(t) {\n  return t > 0 ? 1 : t < 0 ? -1 : 0;\n}\nfunction At(t, i) {\n  var e = t;\n  do {\n    if (e.i !== t.i && e.next.i !== t.i && e.i !== i.i && e.next.i !== i.i && ge(e, e.next, t, i))\n      return !0;\n    e = e.next;\n  } while (e !== t);\n  return !1;\n}\nfunction O(t, i) {\n  return M(t.prev, t, t.next) < 0 ? M(t, i, t.next) >= 0 && M(t, t.prev, i) >= 0 : M(t, i, t.prev) < 0 || M(t, t.next, i) < 0;\n}\nfunction bt(t, i) {\n  var e = t, n = !1, r = (t.x + i.x) / 2, s = (t.y + i.y) / 2;\n  do\n    e.y > s != e.next.y > s && e.next.y !== e.y && r < (e.next.x - e.x) * (s - e.y) / (e.next.y - e.y) + e.x && (n = !n), e = e.next;\n  while (e !== t);\n  return n;\n}\nfunction xe(t, i) {\n  var e = new Y(t.i, t.x, t.y), n = new Y(i.i, i.x, i.y), r = t.next, s = i.prev;\n  return t.next = i, i.prev = t, e.next = r, r.prev = e, n.next = e, e.prev = n, s.next = n, n.prev = s, n;\n}\nfunction me(t, i, e, n) {\n  var r = new Y(t, i, e);\n  return n ? (r.next = n.next, r.prev = n, n.next.prev = r, n.next = r) : (r.prev = r, r.next = r), r;\n}\nfunction E(t) {\n  t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ);\n}\nfunction Y(t, i, e) {\n  this.i = t, this.x = i, this.y = e, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;\n}\nG.deviation = function(t, i, e, n) {\n  var r = i && i.length, s = r ? i[0] * e : t.length, a = Math.abs(X(t, 0, s, e));\n  if (r)\n    for (var l = 0, u = i.length; l < u; l++) {\n      var o = i[l] * e, h = l < u - 1 ? i[l + 1] * e : t.length;\n      a -= Math.abs(X(t, o, h, e));\n    }\n  var g = 0;\n  for (l = 0; l < n.length; l += 3) {\n    var c = n[l] * e, f = n[l + 1] * e, m = n[l + 2] * e;\n    g += Math.abs(\n      (t[c] - t[m]) * (t[f + 1] - t[c + 1]) - (t[c] - t[f]) * (t[m + 1] - t[c + 1])\n    );\n  }\n  return a === 0 && g === 0 ? 0 : Math.abs((g - a) / a);\n};\nfunction X(t, i, e, n) {\n  for (var r = 0, s = i, a = e - n; s < e; s += n)\n    r += (t[a] - t[s]) * (t[s + 1] + t[a + 1]), a = s;\n  return r;\n}\nG.flatten = function(t) {\n  for (var i = t[0][0].length, e = { vertices: [], holes: [], dimensions: i }, n = 0, r = 0; r < t.length; r++) {\n    for (var s = 0; s < t[r].length; s++)\n      for (var a = 0; a < i; a++)\n        e.vertices.push(t[r][s][a]);\n    r > 0 && (n += t[r - 1].length, e.holes.push(n));\n  }\n  return e;\n};\nvar Ut = te.exports;\nconst Ft = /* @__PURE__ */ ft(Ut);\nnew $();\nnew $();\nfunction St(t, i) {\n  var e = t % i, n = Math.floor(t / i);\n  return [e, n];\n}\nfunction Pt(t, i, e) {\n  for (var n = 0, r = 0; n < t.length; n += i, r++)\n    if (i === 3) {\n      var s = e([t[n], t[n + 1], t[n + 2]], r);\n      t.set(s, n);\n    } else\n      t.set(e([t[n], t[n + 1]], r), n);\n  return t;\n}\nfunction Rt(t, i, e, n) {\n  var r = e.x - n.x, s = t.x - i.x, a = e.y - n.y, l = t.y - i.y, u = s * a - l * r;\n  if (u == 0)\n    throw new Error(\"Number of intersection points is zero or infinity.\");\n  var o = t.x * i.y - t.y * i.x, h = e.x * n.y - e.y * n.x, g = (o * r - s * h) / u, c = (o * a - l * h) / u, f = { x: g, y: c };\n  return f;\n}\nfunction Vt(t) {\n  for (var i = 0, e = 0, n = t.length; e < n; e++) {\n    var r = t[e].x, s = t[e == t.length - 1 ? 0 : e + 1].y, a = t[e == t.length - 1 ? 0 : e + 1].x, l = t[e].y;\n    i += r * s * 0.5, i -= a * l * 0.5;\n  }\n  return Math.abs(i);\n}\nfunction Ct([t, i, e]) {\n  return Math.abs(\n    (t.x * (i.y - e.y) + i.x * (e.y - t.y) + e.x * (t.y - i.y)) / 2\n  );\n}\nfunction It(t, i = 8) {\n  const e = t.slice();\n  let n = 0;\n  for (; e.length > i && n < 1e3; ) {\n    n++;\n    let r = 1 / 0, s = null;\n    for (let a = 0; a <= e.length - 1; a++) {\n      const l = e.length, u = [a, (a + 1) % l, (a + 2) % l, (a + 3) % l], o = e[u[0]], h = e[u[1]], g = e[u[2]], c = e[u[3]];\n      try {\n        const f = Rt(o, h, g, c), m = Ct([f, h, g]);\n        m < r && (r = m, s = {\n          point: f,\n          area: m,\n          indicesToRemove: [u[1], u[2]]\n        });\n      } catch (f) {\n        console.log(f);\n      }\n    }\n    if (s) {\n      const a = s.indicesToRemove[0], l = s.indicesToRemove[1];\n      l > a ? (e.splice(l, 1), e.splice(a, 1)) : (e.splice(a, 1), e.splice(l, 1)), e.splice(Math.min(a, l), 0, s.point);\n    }\n  }\n  return e;\n}\nvar J;\n((t) => {\n  function i(r) {\n    let s = r.slice();\n    return s.sort(t.POINT_COMPARATOR), t.makeHullPresorted(s);\n  }\n  t.makeHull = i;\n  function e(r) {\n    if (r.length <= 1)\n      return r.slice();\n    let s = [];\n    for (let l = 0; l < r.length; l++) {\n      const u = r[l];\n      for (; s.length >= 2; ) {\n        const o = s[s.length - 1], h = s[s.length - 2];\n        if ((o.x - h.x) * (u.y - h.y) >= (o.y - h.y) * (u.x - h.x))\n          s.pop();\n        else\n          break;\n      }\n      s.push(u);\n    }\n    s.pop();\n    let a = [];\n    for (let l = r.length - 1; l >= 0; l--) {\n      const u = r[l];\n      for (; a.length >= 2; ) {\n        const o = a[a.length - 1], h = a[a.length - 2];\n        if ((o.x - h.x) * (u.y - h.y) >= (o.y - h.y) * (u.x - h.x))\n          a.pop();\n        else\n          break;\n      }\n      a.push(u);\n    }\n    return a.pop(), s.length == 1 && a.length == 1 && s[0].x == a[0].x && s[0].y == a[0].y ? s : s.concat(a);\n  }\n  t.makeHullPresorted = e;\n  function n(r, s) {\n    return r.x < s.x ? -1 : r.x > s.x ? 1 : r.y < s.y ? -1 : r.y > s.y ? 1 : 0;\n  }\n  t.POINT_COMPARATOR = n;\n})(J || (J = {}));\nfunction Ot(t, i) {\n  const e = new Float32Array(t);\n  for (let n = 0; n < t; n++)\n    e[n * 3] = i[0], e[n * 3 + 1] = i[1], e[n * 3 + 2] = i[2];\n  return e;\n}\nfunction Et(t, i, e = () => Math.random()) {\n  const n = i + 1, r = new Float32Array(t.length / i * n);\n  for (let s = 0; s < t.length; s += i) {\n    let a = s / i * n;\n    r[a] = t[s], r[a + 1] = t[s + 1], i === 2 && (r[a + 2] = e(a)), i === 3 && (r[a + 2] = t[s + 2], r[a + 3] = e(a));\n  }\n  return r;\n}\nfunction $t(t) {\n  const i = new Float32Array(t.length * 2);\n  for (let e = 0; e < t.length; e++)\n    i[e * 2] = t[e].x, i[e * 2 + 1] = t[e].y;\n  return i;\n}\nfunction zt(t, i, e) {\n  const n = [], r = t % (i * 4) / 4, s = Math.floor(t / (i * 4)), a = s - 1, l = s + 1, u = r - 1, o = r + 1;\n  return a >= 0 ? n.push(a * i + r) : n.push(null), l < e ? n.push(l * i + r) : n.push(null), u >= 0 ? n.push(s * i + u) : n.push(null), o < i ? n.push(s * i + o) : n.push(null), n;\n}\nconst Ht = (t) => (...i) => i[3] / 255 > 0, Lt = {\n  threshold: 0.01,\n  slices: [1, 1],\n  indices: [0, 0],\n  scale: 1,\n  filter: Ht\n};\nclass kt {\n  constructor(i, e, n) {\n    y(this, \"points\", []);\n    y(this, \"data\", {\n      areaReduction: 0\n    });\n    y(this, \"debug\", !0);\n    y(this, \"index\");\n    y(this, \"positions\");\n    y(this, \"uv\");\n    y(this, \"defaultSettings\", Lt);\n    y(this, \"settings\");\n    this.vertices = n, this.settings = { ...this.defaultSettings, ...e };\n    const { slices: r } = this.settings, s = Nt(\"bvc-image\", i.width, i.height);\n    this.points = this.getPoints(i, s);\n    let a = J.makeHull(this.points);\n    const l = It(a, n), u = l.map((c) => {\n      let f = Gt(c, [i.width, i.height], r);\n      return f.y = -1 * f.y, f;\n    }), { scale: o } = this.settings;\n    this.data.areaReduction = 1 - Vt(l) / (i.width / r[0] * (i.height / r[1])) * o;\n    const h = $t(u), g = Ft(h, null, 2);\n    this.positions = Et(h, 2, () => 0), this.index = Uint32Array.from(g), this.uv = Pt(h.slice(0), 2, (c) => {\n      let f = c[0] + 0.5;\n      f = f / this.settings.slices[0] + 1 / this.settings.slices[0] * this.settings.indices[0];\n      let m = c[1] + 0.5;\n      return m = m / this.settings.slices[1] + 1 - 1 / this.settings.slices[1] * (this.settings.indices[1] + 1), [f, m];\n    });\n  }\n  getImageData(i, e) {\n    const n = e.getContext(\"2d\");\n    n.drawImage(i, 0, 0);\n    const [r, s] = this.settings.indices, [a, l] = this.settings.slices, u = e.width / a, o = e.height / l;\n    return n.getImageData(u * r, o * s, u, o);\n  }\n  /**\n   * Iterates over the image and returns an array of points that are over the alpha threshold.\n   * It reduces the number of returned points by excluding points that are surrounded by solid pixels.\n   *\n   * @param img An image element with the image already loaded\n   * @param canvas A canvas element to draw the image on in order to get the color values\n   * @returns\n   */\n  getPoints(i, e) {\n    const n = this.getImageData(i, e), r = n.data, s = [], a = this.settings.filter(this.settings.threshold), l = (u) => u !== null && a(\n      r[u * 4],\n      r[u * 4 + 1],\n      r[u * 4 + 2],\n      r[u * 4 + 3]\n    );\n    for (let u = 0; u < r.length; u += 4)\n      if (a(\n        r[u + 0],\n        r[u + 1],\n        r[u + 2],\n        r[u + 3]\n      )) {\n        if (zt(u, e.width, e.height).every(l))\n          continue;\n        const [g, c] = St(u / 4, n.width);\n        s.push({ x: g, y: c });\n      }\n    return s;\n  }\n}\nconst Nt = (t = \"debug-canvas\", i, e) => {\n  const n = document.querySelector(`#${t}`) || document.createElement(\"canvas\");\n  return n.id = t, n.width = i, n.height = e, n.id = t, n;\n}, Gt = (t, i, e) => ({\n  x: (t.x - i[0] / (2 * e[0])) / (i[0] / e[0]),\n  y: (t.y - i[1] / (2 * e[1])) / (i[1] / e[1])\n}), Zt = {\n  threshold: 0.01,\n  slices: [1, 1],\n  indices: [1, 1]\n};\nclass Bt extends ee {\n  constructor(e, n = 8, r = 0.01, s = [1, 1], a = [0, 0]) {\n    super();\n    y(this, \"image\");\n    y(this, \"vertices\", 8);\n    y(this, \"settings\", Zt);\n    this.vertices = n, this.settings = {\n      ...this.settings,\n      threshold: r,\n      slices: s,\n      indices: a\n    }, this.image = \"image\" in e ? e.image : e, this.build();\n  }\n  build() {\n    const e = new kt(\n      this.image,\n      this.settings,\n      this.vertices\n    ), n = e.positions.length, r = new R(e.index, 1), s = new R(e.positions, 3), a = new R(Ot(n, [0, 0, 1]), 3), l = new R(e.uv, 2);\n    this.userData.reduction = e.data.areaReduction, this.setIndex(r), this.setAttribute(\"position\", s), this.setAttribute(\"normal\", a), this.setAttribute(\"uv\", l);\n  }\n}\nconst Jt = () => new Kt();\nclass Kt {\n  constructor() {\n    y(this, \"animations\");\n    this.animations = [];\n  }\n  add(i, e, n) {\n    const r = {\n      name: \"\",\n      imageUrl: i\n    };\n    return Array.isArray(n) ? r.multiAnimations = n : r.name = n, e.type == \"rowColumn\" && (r.auto = {\n      type: \"rowColumn\",\n      width: e.width,\n      height: e.height\n    }), e.type == \"frameSize\" && (r.auto = {\n      type: \"frameSize\",\n      width: e.width,\n      height: e.height\n    }), this.animations.push(r), this;\n  }\n  async build(i = {}) {\n    const e = new Oe(), n = {\n      frames: [],\n      animations: {},\n      sheetSize: [0, 0],\n      animationLengths: []\n    };\n    let r = new Ee();\n    const s = [];\n    let a = 0, l = 0;\n    for (const p of this.animations) {\n      const d = await e.loadAsync(p.imageUrl), w = d.width, _ = d.height;\n      a = Math.max(a, w), l += _, s.push({\n        img: d,\n        w,\n        h: _\n      });\n    }\n    const u = document.createElement(\"canvas\");\n    u.width = a, u.height = l;\n    const o = u.getContext(\"2d\");\n    let h = 0;\n    for (const { img: p, h: d } of s)\n      o == null || o.drawImage(p, 0, h, p.width, p.height), h += d;\n    r = new re(u), r.needsUpdate = !0;\n    let g = 0, c = 0, f = 0, m = 64;\n    for (const p of this.animations) {\n      const d = s[g];\n      let w = 0;\n      if (p.auto) {\n        let _ = 0, x = 0;\n        p.auto.type == \"frameSize\" && (x = d.w / p.auto.width, _ = d.h / p.auto.height), p.auto.type == \"rowColumn\" && (x = p.auto.width, _ = p.auto.height);\n        const v = d.w / x, S = d.h / _;\n        w = _ * x, p.multiAnimations || (n.animations[p.name] = []);\n        const P = /* @__PURE__ */ new Map();\n        for (let D = 0; D < _; D++) {\n          f += S;\n          for (let A = 0; A < x; A++) {\n            if (n.frames.push([\n              d.w / x * A / a,\n              1 - f / l,\n              v / a,\n              S / l\n            ]), p.multiAnimations) {\n              const ve = D * x + A;\n              P.set(ve, c);\n            } else\n              n.animations[p.name].push([c, 1]);\n            c++;\n          }\n        }\n        if (p.multiAnimations)\n          for (const D of p.multiAnimations) {\n            n.animations[D.name] = [], n.animationLengths.push(\n              D.frameRange[1] - D.frameRange[0] + 1\n            );\n            for (let A = D.frameRange[0]; A <= D.frameRange[1]; A++)\n              n.animations[D.name].push([P.get(A), 1]);\n          }\n        else\n          n.animationLengths.push(w);\n      }\n      g++;\n    }\n    if (r.matrixAutoUpdate = !1, r.generateMipmaps = !1, r.premultiplyAlpha = !1, r.wrapS = r.wrapT = q, r.magFilter = r.minFilter = b, r.colorSpace = se, n.sheetSize = [a, l], i.makeSlimGeometry) {\n      const p = document.createElement(\"canvas\");\n      p.width = m, p.height = m;\n      const d = p.getContext(\"2d\"), w = a / m, _ = l / m;\n      for (let S = 0; S < w; S++)\n        for (let P = 0; P < _; P++) {\n          const D = S * m, A = P * m;\n          d == null || d.drawImage(u, D, A, m, m, 0, 0, m, m);\n        }\n      const x = new re(p);\n      x.magFilter = r.minFilter = b, x.colorSpace = se;\n      const v = new Bt(\n        x,\n        // an already loaded HTMLImageElement or a ThreeJS texture\n        i.slimOptions ? i.slimOptions.vertices : 8,\n        i.slimOptions ? i.slimOptions.alphaThreshold : 0\n        // alphaThreshold, 0 means only fully transparent pixels will be discarded\n      );\n      return { spritesheet: n, texture: r, geometry: v };\n    }\n    return { spritesheet: n, texture: r };\n  }\n}\nexport {\n  Xt as InstancedSpriteMesh,\n  K as PLAY_MODE,\n  Jt as createSpritesheet,\n  Qe as makeDataTexture,\n  Yt as parseAseprite\n};\n","import { h as bind_props, s as store_get, u as unsubscribe_stores, j as spread_props, k as attr_style, b as spread_attributes, a as attr_class, l as stringify, m as slot, f as ensure_array_like, g as attr } from \"../../../../chunks/index2.js\";\nimport \"clsx\";\nimport { g as get, w as writable, d as derived, r as readable } from \"../../../../chunks/index.js\";\nimport * as THREE from \"three\";\nimport { REVISION, DefaultLoadingManager, Vector3, Sphere, Matrix4, Ray, Object3D, Vector2, TextureLoader, Mesh, ShaderChunk, Box3, MeshBasicMaterial } from \"three\";\nimport mitt from \"mitt\";\nimport { _ as ssr_context, W as getContext, V as setContext, Z as fallback, X as escape_html } from \"../../../../chunks/context.js\";\nimport \"camera-controls\";\nimport \"three-viewport-gizmo\";\nimport { EXRLoader } from \"three/examples/jsm/loaders/EXRLoader.js\";\nimport { RGBELoader } from \"three/examples/jsm/loaders/RGBELoader.js\";\nimport { GroundedSkybox } from \"three/examples/jsm/objects/GroundedSkybox.js\";\nimport { OrbitControls as OrbitControls$1 } from \"three/examples/jsm/controls/OrbitControls.js\";\nimport { shaderStructs, shaderIntersectFunction } from \"three-mesh-bvh\";\nimport \"@threejs-kit/instanced-sprite-mesh\";\nfunction fromStore(store) {\n  if (\"set\" in store) {\n    return {\n      get current() {\n        return get(store);\n      },\n      set current(v) {\n        store.set(v);\n      }\n    };\n  }\n  return {\n    get current() {\n      return get(store);\n    }\n  };\n}\nfunction onDestroy(fn) {\n  /** @type {SSRContext} */\n  ssr_context.r.on_destroy(fn);\n}\nconst useCache = () => {\n  const cache = getContext(\"threlte-cache\");\n  if (!cache) {\n    throw new Error(\"No cache found. The cache can only be used in a child component to <Canvas>.\");\n  }\n  return cache;\n};\nconst signal = Symbol();\nconst isStore = (dep) => {\n  return typeof dep?.subscribe === \"function\";\n};\nconst runObserve = (dependencies, callback, pre) => {\n  const stores = dependencies().map((d) => {\n    if (isStore(d)) {\n      return fromStore(d);\n    }\n    return signal;\n  });\n  dependencies().map((d, i) => {\n    if (stores[i] === signal) return d;\n    return stores[i].current;\n  });\n};\nconst observePost = (dependencies, callback) => {\n  return runObserve(dependencies);\n};\nconst observePre = (dependencies, callback) => {\n  return runObserve(dependencies);\n};\nconst observe = Object.assign(observePost, { pre: observePre });\nconst isInstanceOf = (obj, type) => {\n  return obj?.[`is${type}`] === true;\n};\nconst browser = typeof window !== \"undefined\";\nREVISION.replace(\"dev\", \"\");\nconst currentWritable = (value) => {\n  const store = writable(value);\n  const extendedWritable = {\n    set: (value2) => {\n      extendedWritable.current = value2;\n      store.set(value2);\n    },\n    subscribe: store.subscribe,\n    update: (fn) => {\n      const newValue = fn(extendedWritable.current);\n      extendedWritable.current = newValue;\n      store.set(newValue);\n    },\n    current: value\n  };\n  return extendedWritable;\n};\nconst resolvePropertyPath = (target, propertyPath) => {\n  if (propertyPath.includes(\".\")) {\n    const path = propertyPath.split(\".\");\n    const key = path.pop();\n    for (let i = 0; i < path.length; i += 1) {\n      target = target[path[i]];\n    }\n    return {\n      target,\n      key\n    };\n  } else {\n    return {\n      target,\n      key: propertyPath\n    };\n  }\n};\nconst useDOM = () => {\n  const context = getContext(\"threlte-dom-context\");\n  if (!context) {\n    throw new Error(\"useDOM can only be used in a child component to <Canvas>.\");\n  }\n  return context;\n};\nclass DAG {\n  allVertices = {};\n  /** Nodes that are fully unlinked */\n  isolatedVertices = {};\n  connectedVertices = {};\n  sortedConnectedValues = [];\n  needsSort = false;\n  emitter = mitt();\n  emit = this.emitter.emit.bind(this.emitter);\n  on = this.emitter.on.bind(this.emitter);\n  off = this.emitter.off.bind(this.emitter);\n  get sortedVertices() {\n    return this.mapNodes((value) => value);\n  }\n  moveToIsolated(key) {\n    const vertex = this.connectedVertices[key];\n    if (!vertex)\n      return;\n    this.isolatedVertices[key] = vertex;\n    delete this.connectedVertices[key];\n  }\n  moveToConnected(key) {\n    const vertex = this.isolatedVertices[key];\n    if (!vertex)\n      return;\n    this.connectedVertices[key] = vertex;\n    delete this.isolatedVertices[key];\n  }\n  getKey = (v) => {\n    if (typeof v === \"object\") {\n      return v.key;\n    }\n    return v;\n  };\n  add(key, value, options) {\n    if (this.allVertices[key] && this.allVertices[key].value !== void 0) {\n      throw new Error(`A node with the key ${key.toString()} already exists`);\n    }\n    let vertex = this.allVertices[key];\n    if (!vertex) {\n      vertex = {\n        value,\n        previous: /* @__PURE__ */ new Set(),\n        next: /* @__PURE__ */ new Set()\n      };\n      this.allVertices[key] = vertex;\n    } else if (vertex.value === void 0) {\n      vertex.value = value;\n    }\n    const hasEdges = vertex.next.size > 0 || vertex.previous.size > 0;\n    if (!options?.after && !options?.before && !hasEdges) {\n      this.isolatedVertices[key] = vertex;\n      this.emit(\"node:added\", {\n        key,\n        type: \"isolated\",\n        value\n      });\n      return;\n    } else {\n      this.connectedVertices[key] = vertex;\n    }\n    if (options?.after) {\n      const afterArr = Array.isArray(options.after) ? options.after : [options.after];\n      afterArr.forEach((after) => {\n        vertex.previous.add(this.getKey(after));\n      });\n      afterArr.forEach((after) => {\n        const afterKey = this.getKey(after);\n        const linkedAfter = this.allVertices[afterKey];\n        if (!linkedAfter) {\n          this.allVertices[afterKey] = {\n            value: void 0,\n            // uninitialized\n            previous: /* @__PURE__ */ new Set(),\n            next: /* @__PURE__ */ new Set([key])\n          };\n          this.connectedVertices[afterKey] = this.allVertices[afterKey];\n        } else {\n          linkedAfter.next.add(key);\n          this.moveToConnected(afterKey);\n        }\n      });\n    }\n    if (options?.before) {\n      const beforeArr = Array.isArray(options.before) ? options.before : [options.before];\n      beforeArr.forEach((before) => {\n        vertex.next.add(this.getKey(before));\n      });\n      beforeArr.forEach((before) => {\n        const beforeKey = this.getKey(before);\n        const linkedBefore = this.allVertices[beforeKey];\n        if (!linkedBefore) {\n          this.allVertices[beforeKey] = {\n            value: void 0,\n            // uninitialized\n            previous: /* @__PURE__ */ new Set([key]),\n            next: /* @__PURE__ */ new Set()\n          };\n          this.connectedVertices[beforeKey] = this.allVertices[beforeKey];\n        } else {\n          linkedBefore.previous.add(key);\n          this.moveToConnected(beforeKey);\n        }\n      });\n    }\n    this.emit(\"node:added\", {\n      key,\n      type: \"connected\",\n      value\n    });\n    this.needsSort = true;\n  }\n  remove(key) {\n    const removeKey = this.getKey(key);\n    const unlinkedVertex = this.isolatedVertices[removeKey];\n    if (unlinkedVertex) {\n      delete this.isolatedVertices[removeKey];\n      delete this.allVertices[removeKey];\n      this.emit(\"node:removed\", {\n        key: removeKey,\n        type: \"isolated\"\n      });\n      return;\n    }\n    const linkedVertex = this.connectedVertices[removeKey];\n    if (!linkedVertex) {\n      return;\n    }\n    linkedVertex.next.forEach((nextKey) => {\n      const nextVertex = this.connectedVertices[nextKey];\n      if (nextVertex) {\n        nextVertex.previous.delete(removeKey);\n        if (nextVertex.previous.size === 0 && nextVertex.next.size === 0) {\n          this.moveToIsolated(nextKey);\n        }\n      }\n    });\n    linkedVertex.previous.forEach((prevKey) => {\n      const prevVertex = this.connectedVertices[prevKey];\n      if (prevVertex) {\n        prevVertex.next.delete(removeKey);\n        if (prevVertex.previous.size === 0 && prevVertex.next.size === 0) {\n          this.moveToIsolated(prevKey);\n        }\n      }\n    });\n    delete this.connectedVertices[removeKey];\n    delete this.allVertices[removeKey];\n    this.emit(\"node:removed\", {\n      key: removeKey,\n      type: \"connected\"\n    });\n    this.needsSort = true;\n  }\n  mapNodes(callback) {\n    if (this.needsSort) {\n      this.sort();\n    }\n    const result = [];\n    this.forEachNode((value, index) => {\n      result.push(callback(value, index));\n    });\n    return result;\n  }\n  forEachNode(callback) {\n    if (this.needsSort) {\n      this.sort();\n    }\n    let index = 0;\n    for (; index < this.sortedConnectedValues.length; index++) {\n      callback(this.sortedConnectedValues[index], index);\n    }\n    Reflect.ownKeys(this.isolatedVertices).forEach((key) => {\n      const vertex = this.isolatedVertices[key];\n      if (vertex.value !== void 0)\n        callback(vertex.value, index++);\n    });\n  }\n  getValueByKey(key) {\n    return this.allVertices[key]?.value;\n  }\n  getKeyByValue(value) {\n    return Reflect.ownKeys(this.connectedVertices).find((key) => this.connectedVertices[key].value === value) ?? Reflect.ownKeys(this.isolatedVertices).find((key) => this.isolatedVertices[key].value === value);\n  }\n  sort() {\n    const inDegree = /* @__PURE__ */ new Map();\n    const zeroInDegreeQueue = [];\n    const result = [];\n    const connectedVertexKeysWithValues = Reflect.ownKeys(this.connectedVertices).filter((key) => {\n      const vertex = this.connectedVertices[key];\n      return vertex.value !== void 0;\n    });\n    connectedVertexKeysWithValues.forEach((vertex) => {\n      inDegree.set(vertex, 0);\n    });\n    connectedVertexKeysWithValues.forEach((vertexKey) => {\n      const vertex = this.connectedVertices[vertexKey];\n      vertex.next.forEach((next) => {\n        const nextVertex = this.connectedVertices[next];\n        if (!nextVertex)\n          return;\n        inDegree.set(next, (inDegree.get(next) || 0) + 1);\n      });\n    });\n    inDegree.forEach((degree, value) => {\n      if (degree === 0) {\n        zeroInDegreeQueue.push(value);\n      }\n    });\n    while (zeroInDegreeQueue.length > 0) {\n      const vertexKey = zeroInDegreeQueue.shift();\n      result.push(vertexKey);\n      const v = connectedVertexKeysWithValues.find((key) => key === vertexKey);\n      if (v) {\n        this.connectedVertices[v]?.next.forEach((adjVertex) => {\n          const adjVertexInDegree = (inDegree.get(adjVertex) || 0) - 1;\n          inDegree.set(adjVertex, adjVertexInDegree);\n          if (adjVertexInDegree === 0) {\n            zeroInDegreeQueue.push(adjVertex);\n          }\n        });\n      }\n    }\n    if (result.length !== connectedVertexKeysWithValues.length) {\n      throw new Error(\"The graph contains a cycle, and thus can not be sorted topologically.\");\n    }\n    const filterUndefined = (value) => value !== void 0;\n    this.sortedConnectedValues = result.map((key) => this.connectedVertices[key].value).filter(filterUndefined);\n    this.needsSort = false;\n  }\n  clear() {\n    this.allVertices = {};\n    this.isolatedVertices = {};\n    this.connectedVertices = {};\n    this.sortedConnectedValues = [];\n    this.needsSort = false;\n  }\n  static isKey(value) {\n    return typeof value === \"string\" || typeof value === \"symbol\";\n  }\n  static isValue(value) {\n    return typeof value === \"object\" && \"key\" in value;\n  }\n}\nconst useScheduler = () => {\n  const context = getContext(\"threlte-scheduler-context\");\n  if (!context) {\n    throw new Error(\"useScheduler can only be used in a child component to <Canvas>.\");\n  }\n  return context;\n};\nconst useCamera = () => {\n  const context = getContext(\"threlte-camera-context\");\n  if (!context) {\n    throw new Error(\"useCamera can only be used in a child component to <Canvas>.\");\n  }\n  return context;\n};\nconst parentContextKey = Symbol(\"threlte-parent-context\");\nconst createParentContext = (parent) => {\n  const ctx = currentWritable(parent);\n  setContext(parentContextKey, ctx);\n  return ctx;\n};\nconst useParent = () => {\n  const parent = getContext(parentContextKey);\n  return parent;\n};\nconst parentObject3DContextKey = Symbol(\"threlte-parent-object3d-context\");\nconst createParentObject3DContext = (object) => {\n  const parentObject3D = getContext(parentObject3DContextKey);\n  const object3D = writable(object);\n  const ctx = derived([object3D, parentObject3D], ([object3D2, parentObject3D2]) => {\n    return object3D2 ?? parentObject3D2;\n  });\n  setContext(parentObject3DContextKey, ctx);\n  return object3D;\n};\nconst useParentObject3D = () => {\n  return getContext(parentObject3DContextKey);\n};\nfunction useTask(keyOrFn, fnOrOptions, options) {\n  if (!browser) {\n    return {\n      task: void 0,\n      start: () => void 0,\n      stop: () => void 0,\n      started: readable(false)\n    };\n  }\n  let key;\n  let fn;\n  let opts;\n  if (DAG.isKey(keyOrFn)) {\n    key = keyOrFn;\n    fn = fnOrOptions;\n    opts = options;\n  } else {\n    key = Symbol(\"useTask\");\n    fn = keyOrFn;\n    opts = fnOrOptions;\n  }\n  const schedulerCtx = useScheduler();\n  let stage = schedulerCtx.mainStage;\n  if (opts) {\n    if (opts.stage) {\n      if (DAG.isValue(opts.stage)) {\n        stage = opts.stage;\n      } else {\n        const maybeStage = schedulerCtx.scheduler.getStage(opts.stage);\n        if (!maybeStage) {\n          throw new Error(`No stage found with key ${opts.stage.toString()}`);\n        }\n        stage = maybeStage;\n      }\n    } else if (opts.after) {\n      if (Array.isArray(opts.after)) {\n        for (let index = 0; index < opts.after.length; index++) {\n          const element = opts.after[index];\n          if (DAG.isValue(element)) {\n            stage = element.stage;\n            break;\n          }\n        }\n      } else if (DAG.isValue(opts.after)) {\n        stage = opts.after.stage;\n      }\n    } else if (opts.before) {\n      if (Array.isArray(opts.before)) {\n        for (let index = 0; index < opts.before.length; index++) {\n          const element = opts.before[index];\n          if (DAG.isValue(element)) {\n            stage = element.stage;\n            break;\n          }\n        }\n      } else if (DAG.isValue(opts.before)) {\n        stage = opts.before.stage;\n      }\n    }\n  }\n  const started = writable(false);\n  const task = stage.createTask(key, fn, opts);\n  const start = () => {\n    started.set(true);\n    if (opts?.autoInvalidate ?? true) {\n      schedulerCtx.autoInvalidations.add(fn);\n    }\n    task.start();\n  };\n  const stop = () => {\n    started.set(false);\n    if (opts?.autoInvalidate ?? true) {\n      schedulerCtx.autoInvalidations.delete(fn);\n    }\n    task.stop();\n  };\n  if (opts?.autoStart ?? true) {\n    start();\n  } else {\n    stop();\n  }\n  onDestroy(() => {\n    stop();\n    stage.removeTask(key);\n  });\n  return {\n    task,\n    start,\n    stop,\n    started: {\n      subscribe: started.subscribe\n    }\n  };\n}\nconst useScene = () => {\n  const context = getContext(\"threlte-scene-context\");\n  if (!context) {\n    throw new Error(\"useScene can only be used in a child component to <Canvas>.\");\n  }\n  return context;\n};\nconst useRenderer = () => {\n  const context = getContext(\"threlte-renderer-context\");\n  if (!context) {\n    throw new Error(\"useRenderer can only be used in a child component to <Canvas>.\");\n  }\n  return context;\n};\nconst useUserContext = () => {\n  const context = getContext(\"threlte-user-context\");\n  if (!context) {\n    throw new Error(\"useUserContext can only be used in a child component to <Canvas>.\");\n  }\n  return context;\n};\nfunction Canvas($$renderer, $$props) {\n  let { children, $$slots, $$events, ...rest } = $$props;\n  $$renderer.push(`<div class=\"svelte-clyidt\"><canvas class=\"svelte-clyidt\">`);\n  {\n    $$renderer.push(\"<!--[!-->\");\n  }\n  $$renderer.push(`<!--]--></canvas></div>`);\n}\nconst useThrelte = () => {\n  const schedulerCtx = useScheduler();\n  const rendererCtx = useRenderer();\n  const cameraCtx = useCamera();\n  const sceneCtx = useScene();\n  const domCtx = useDOM();\n  const context = {\n    advance: schedulerCtx.advance,\n    autoRender: schedulerCtx.autoRender,\n    autoRenderTask: rendererCtx.autoRenderTask,\n    camera: cameraCtx.camera,\n    colorManagementEnabled: rendererCtx.colorManagementEnabled,\n    colorSpace: rendererCtx.colorSpace,\n    dpr: rendererCtx.dpr,\n    invalidate: schedulerCtx.invalidate,\n    mainStage: schedulerCtx.mainStage,\n    renderer: rendererCtx.renderer,\n    renderMode: schedulerCtx.renderMode,\n    renderStage: schedulerCtx.renderStage,\n    scheduler: schedulerCtx.scheduler,\n    shadows: rendererCtx.shadows,\n    shouldRender: schedulerCtx.shouldRender,\n    dom: domCtx.dom,\n    canvas: domCtx.canvas,\n    size: domCtx.size,\n    toneMapping: rendererCtx.toneMapping,\n    get scene() {\n      return sceneCtx.scene;\n    },\n    set scene(scene) {\n      sceneCtx.scene = scene;\n    }\n  };\n  return context;\n};\nconst useAttach = (getRef, getAttach) => {\n  const { invalidate } = useThrelte();\n  fromStore(useParent());\n  fromStore(useParentObject3D());\n  createParentContext();\n  createParentObject3DContext();\n};\nconst contextName = Symbol(\"threlte-disposable-object-context\");\nconst useSetDispose = (getDispose) => {\n  const parentDispose = getContext(contextName);\n  const mergedDispose = getDispose() ?? parentDispose?.() ?? true;\n  setContext(contextName, () => mergedDispose);\n};\nconst useEvents = (getRef, propKeys, props) => {\n  for (const key of propKeys) {\n    props[key];\n    if (key.startsWith(\"on\")) ;\n  }\n};\nlet currentIs;\nconst setIs = (is) => {\n  currentIs = is;\n};\nconst useIs = () => {\n  const is = currentIs;\n  currentIs = void 0;\n  return is;\n};\nconst pluginContextKey = \"threlte-plugin-context\";\nconst usePlugins = (args) => {\n  const plugins = getContext(pluginContextKey);\n  if (!plugins)\n    return;\n  const pluginsProps = [];\n  const pluginsArray = Object.values(plugins);\n  if (pluginsArray.length > 0) {\n    const pluginArgs = args();\n    for (let i = 0; i < pluginsArray.length; i++) {\n      const plugin = pluginsArray[i];\n      const p = plugin(pluginArgs);\n      if (p && p.pluginProps) {\n        pluginsProps.push(...p.pluginProps);\n      }\n    }\n  }\n  return {\n    pluginsProps\n  };\n};\nconst ignoredProps = /* @__PURE__ */ new Set([\"$$scope\", \"$$slots\", \"type\", \"args\", \"attach\", \"instance\"]);\nconst updateProjectionMatrixKeys = /* @__PURE__ */ new Set([\n  \"fov\",\n  \"aspect\",\n  \"near\",\n  \"far\",\n  \"left\",\n  \"right\",\n  \"top\",\n  \"bottom\",\n  \"zoom\"\n]);\nconst memoizeProp = (value) => {\n  if (typeof value === \"string\")\n    return true;\n  if (typeof value === \"number\")\n    return true;\n  if (typeof value === \"boolean\")\n    return true;\n  if (typeof value === \"undefined\")\n    return true;\n  if (value === null)\n    return true;\n  return false;\n};\nconst createSetter = (target, key, value) => {\n  if (!Array.isArray(value) && typeof value === \"number\" && typeof target[key] === \"object\" && target[key] !== null && typeof target[key]?.setScalar === \"function\" && // colors do have a setScalar function, but we don't want to use it, because\n  // the hex notation (i.e. 0xff0000) is very popular and matches the number\n  // type. So we exclude colors here.\n  !target[key]?.isColor) {\n    return (target2, key2, value2) => {\n      target2[key2].setScalar(value2);\n    };\n  } else {\n    if (typeof target[key]?.set === \"function\" && typeof target === \"object\" && target !== null) {\n      if (Array.isArray(value)) {\n        return (target2, key2, value2) => {\n          target2[key2].set(...value2);\n        };\n      } else {\n        return (target2, key2, value2) => {\n          target2[key2].set(value2);\n        };\n      }\n    } else {\n      return (target2, key2, value2) => {\n        target2[key2] = value2;\n      };\n    }\n  }\n};\nconst useProps = () => {\n  const { invalidate } = useThrelte();\n  const memoizedProps = /* @__PURE__ */ new Map();\n  const memoizedSetters = /* @__PURE__ */ new Map();\n  const setProp = (instance, propertyPath, value, manualCamera) => {\n    if (memoizeProp(value)) {\n      const memoizedProp = memoizedProps.get(propertyPath);\n      if (memoizedProp && memoizedProp.instance === instance && memoizedProp.value === value) {\n        return;\n      }\n      memoizedProps.set(propertyPath, {\n        instance,\n        value\n      });\n    }\n    const { key, target } = resolvePropertyPath(instance, propertyPath);\n    if (value !== void 0 && value !== null) {\n      const memoizedSetter = memoizedSetters.get(propertyPath);\n      if (memoizedSetter) {\n        memoizedSetter(target, key, value);\n      } else {\n        const setter = createSetter(target, key, value);\n        memoizedSetters.set(propertyPath, setter);\n        setter(target, key, value);\n      }\n    } else {\n      createSetter(target, key, value)(target, key, value);\n    }\n    if (manualCamera)\n      return;\n    if (updateProjectionMatrixKeys.has(key) && (target.isPerspectiveCamera || target.isOrthographicCamera)) {\n      target.updateProjectionMatrix();\n    }\n  };\n  const updateProp = (instance, key, value, pluginsProps, manualCamera) => {\n    if (!ignoredProps.has(key) && !pluginsProps?.includes(key)) {\n      setProp(instance, key, value, manualCamera);\n    }\n    invalidate();\n  };\n  return {\n    updateProp\n  };\n};\nconst isClass = (input) => {\n  return typeof input === \"function\" && Function.prototype.toString.call(input).startsWith(\"class \");\n};\nconst determineRef = (is, args) => {\n  if (isClass(is)) {\n    if (Array.isArray(args)) {\n      return new is(...args);\n    } else {\n      return new is();\n    }\n  }\n  return is;\n};\nfunction T$1($$renderer, $$props) {\n  $$renderer.component(($$renderer2) => {\n    let {\n      is = useIs(),\n      args,\n      attach,\n      manual = false,\n      makeDefault = false,\n      dispose,\n      ref = void 0,\n      oncreate,\n      children,\n      $$slots,\n      $$events,\n      ...props\n    } = $$props;\n    const internalRef = determineRef(is, args);\n    usePlugins(() => ({\n      get ref() {\n        return internalRef;\n      },\n      get args() {\n        return args;\n      },\n      get attach() {\n        return attach;\n      },\n      get manual() {\n        return manual;\n      },\n      get makeDefault() {\n        return makeDefault;\n      },\n      get dispose() {\n        return dispose;\n      },\n      get props() {\n        return props;\n      }\n    }));\n    const propKeys = Object.keys(props);\n    useProps();\n    propKeys.forEach((key) => {\n      props[key];\n    });\n    useAttach();\n    useSetDispose(() => dispose);\n    useEvents(() => internalRef, propKeys, props);\n    children?.($$renderer2, { ref: internalRef });\n    $$renderer2.push(`<!---->`);\n    bind_props($$props, { ref });\n  });\n}\nconst catalogue = {};\nconst T = new Proxy(T$1, {\n  get(_target, is) {\n    if (typeof is !== \"string\") {\n      return T$1;\n    }\n    const module = catalogue[is] || THREE[is];\n    if (module === void 0) {\n      throw new Error(`No Three.js module found for ${is}. Did you forget to extend the catalogue?`);\n    }\n    setIs(module);\n    return T$1;\n  }\n});\nfunction useThrelteUserContext(namespace, value, options) {\n  const userCtxStore = useUserContext();\n  if (!userCtxStore) {\n    throw new Error(\"No user context store found, did you invoke this function outside of your main <Canvas> component?\");\n  }\n  if (!value) {\n    return derived(userCtxStore, (ctx) => ctx[namespace]);\n  }\n  userCtxStore.update((ctx) => {\n    if (namespace in ctx) {\n      return ctx;\n    }\n    const v = typeof value === \"function\" ? value() : value;\n    ctx[namespace] = v;\n    return ctx;\n  });\n  return userCtxStore.current[namespace];\n}\nconst toCurrentReadable = (store) => {\n  return {\n    subscribe: store.subscribe,\n    get current() {\n      return store.current;\n    }\n  };\n};\nlet previousTotalLoaded = 0;\nconst finishedOnce = currentWritable(false);\nconst activeStore = currentWritable(false);\nconst itemStore = currentWritable(void 0);\nconst loadedStore = currentWritable(0);\nconst totalStore = currentWritable(0);\nconst errorsStore = currentWritable([]);\nconst progressStore = currentWritable(0);\nconst { onStart, onLoad, onError } = DefaultLoadingManager;\nDefaultLoadingManager.onStart = (url, loaded, total) => {\n  onStart?.(url, loaded, total);\n  activeStore.set(true);\n  itemStore.set(url);\n  loadedStore.set(loaded);\n  totalStore.set(total);\n  const progress = (loaded - previousTotalLoaded) / (total - previousTotalLoaded);\n  progressStore.set(progress);\n  if (progress === 1)\n    finishedOnce.set(true);\n};\nDefaultLoadingManager.onLoad = () => {\n  onLoad?.();\n  activeStore.set(false);\n};\nDefaultLoadingManager.onError = (url) => {\n  onError?.(url);\n  errorsStore.update((errors) => {\n    return [...errors, url];\n  });\n};\nDefaultLoadingManager.onProgress = (url, loaded, total) => {\n  if (loaded === total) {\n    previousTotalLoaded = total;\n  }\n  activeStore.set(true);\n  itemStore.set(url);\n  loadedStore.set(loaded);\n  totalStore.set(total);\n  const progress = (loaded - previousTotalLoaded) / (total - previousTotalLoaded) || 1;\n  progressStore.set(progress);\n  if (progress === 1)\n    finishedOnce.set(true);\n};\n({\n  active: toCurrentReadable(activeStore),\n  item: toCurrentReadable(itemStore),\n  loaded: toCurrentReadable(loadedStore),\n  total: toCurrentReadable(totalStore),\n  errors: toCurrentReadable(errorsStore),\n  progress: toCurrentReadable(progressStore),\n  finishedOnce: toCurrentReadable(finishedOnce)\n});\nnew Vector3();\nnew Vector3();\nnew Vector3();\nnew Sphere();\nnew Matrix4();\nnew Ray();\nnew Vector3();\nconst suspenseContextIdentifier = Symbol(\"THRELTE_SUSPENSE_CONTEXT_IDENTIFIER\");\nconst useSuspense = () => {\n  const ctx = getContext(suspenseContextIdentifier);\n  const promises = /* @__PURE__ */ new Set();\n  const suspend = (promise) => {\n    if (ctx) {\n      ctx.suspend(promise);\n      promises.add(promise);\n    }\n    return promise;\n  };\n  const state = {\n    suspended: derived(ctx?.suspended ?? readable(false), (suspended) => suspended)\n  };\n  onDestroy(() => {\n    if (!ctx)\n      return;\n    for (const promise of promises) {\n      ctx.onComponentDestroy(promise);\n    }\n    promises.clear();\n  });\n  return Object.assign(suspend, state);\n};\nnew Vector3();\nnew Matrix4();\nnew Vector3();\nnew Vector3();\nnew Object3D();\nnew Vector3();\nnew Vector3();\nnew Vector3();\nnew Vector2();\nconst useEnvironment = (options) => {\n  const { invalidate } = useThrelte();\n  observe(() => [options.scene], ([scene]) => {\n    const { background, environment } = scene;\n    return () => {\n      scene.background = background;\n      scene.environment = environment;\n    };\n  });\n  observe(() => [options.scene], ([scene]) => {\n    scene.background;\n    scene.environment;\n  });\n};\nconst loaders = {};\nfunction Environment($$renderer, $$props) {\n  $$renderer.component(($$renderer2) => {\n    const ctx = useThrelte();\n    let {\n      skybox = void 0,\n      texture = void 0,\n      ground = false,\n      isBackground = false,\n      scene = ctx.scene,\n      url\n    } = $$props;\n    useSuspense();\n    useCache();\n    useEnvironment({\n      get scene() {\n        return scene;\n      }\n    });\n    const isEXR = url?.endsWith(\"exr\") ?? false;\n    const isHDR = url?.endsWith(\"hdr\") ?? false;\n    (() => {\n      if (url === void 0) return;\n      if (isEXR) {\n        loaders.exr ??= new EXRLoader();\n        return loaders.exr;\n      } else if (isHDR) {\n        loaders.hdr ??= new RGBELoader();\n        return loaders.hdr;\n      }\n      loaders.tex ??= new TextureLoader();\n      return loaders.tex;\n    })();\n    let $$settled = true;\n    let $$inner_renderer;\n    function $$render_inner($$renderer3) {\n      if (ground) {\n        $$renderer3.push(\"<!--[-->\");\n        const options = ground === true ? {} : ground;\n        if (texture) {\n          $$renderer3.push(\"<!--[-->\");\n          T($$renderer3, {\n            is: GroundedSkybox,\n            args: [\n              texture,\n              options.height ?? 1,\n              options.radius ?? 1,\n              options.resolution ?? 128\n            ],\n            get ref() {\n              return skybox;\n            },\n            set ref($$value) {\n              skybox = $$value;\n              $$settled = false;\n            }\n          });\n        } else {\n          $$renderer3.push(\"<!--[!-->\");\n        }\n        $$renderer3.push(`<!--]-->`);\n      } else {\n        $$renderer3.push(\"<!--[!-->\");\n      }\n      $$renderer3.push(`<!--]-->`);\n    }\n    do {\n      $$settled = true;\n      $$inner_renderer = $$renderer2.copy();\n      $$render_inner($$inner_renderer);\n    } while (!$$settled);\n    $$renderer2.subsume($$inner_renderer);\n    bind_props($$props, { skybox, texture });\n  });\n}\nconst useControlsContext = () => {\n  return useThrelteUserContext(\"threlte-controls\", {\n    orbitControls: writable(void 0),\n    trackballControls: writable(void 0)\n  });\n};\nfunction OrbitControls($$renderer, $$props) {\n  $$renderer.component(($$renderer2) => {\n    var $$store_subs;\n    let { ref = void 0, children, $$slots, $$events, ...props } = $$props;\n    const parent = useParent();\n    const { dom, invalidate } = useThrelte();\n    if (!isInstanceOf(store_get($$store_subs ??= {}, \"$parent\", parent), \"Camera\")) {\n      throw new Error(\"Parent missing: <OrbitControls> need to be a child of a <Camera>\");\n    }\n    const controls = new OrbitControls$1(store_get($$store_subs ??= {}, \"$parent\", parent), dom);\n    const { orbitControls } = useControlsContext();\n    const { start, stop } = useTask(\n      () => {\n        controls.update();\n      },\n      { autoStart: false, autoInvalidate: false }\n    );\n    let $$settled = true;\n    let $$inner_renderer;\n    function $$render_inner($$renderer3) {\n      T($$renderer3, spread_props([\n        { is: controls },\n        props,\n        {\n          get ref() {\n            return ref;\n          },\n          set ref($$value) {\n            ref = $$value;\n            $$settled = false;\n          },\n          children: ($$renderer4) => {\n            children?.($$renderer4, { ref: controls });\n            $$renderer4.push(`<!---->`);\n          },\n          $$slots: { default: true }\n        }\n      ]));\n    }\n    do {\n      $$settled = true;\n      $$inner_renderer = $$renderer2.copy();\n      $$render_inner($$inner_renderer);\n    } while (!$$settled);\n    $$renderer2.subsume($$inner_renderer);\n    if ($$store_subs) unsubscribe_stores($$store_subs);\n    bind_props($$props, { ref });\n  });\n}\nnew Matrix4();\nnew Matrix4();\nnew Mesh();\n`\n    #include <common>\n    ${ShaderChunk.logdepthbuf_pars_vertex}\n    ${ShaderChunk.fog_pars_vertex}\n\n    attribute vec3 previous;\n    attribute vec3 next;\n    attribute float side;\n    attribute float width;\n    attribute float counters;\n\n    uniform vec2 resolution;\n    uniform float lineWidth;\n    uniform vec3 color;\n    uniform float opacity;\n    uniform float sizeAttenuation;\n    uniform float scaleDown;\n\n    varying vec2 vUV;\n    varying vec4 vColor;\n    varying float vCounters;\n\n    vec2 intoScreen(vec4 i) {\n        return resolution * (0.5 * i.xy / i.w + 0.5);\n    }\n\n    void main() {\n        float aspect = resolution.y / resolution.x;\n\n        mat4 m = projectionMatrix * modelViewMatrix;\n\n        vec4 currentClip = m * vec4( position, 1.0 );\n        vec4 prevClip = m * vec4( previous, 1.0 );\n        vec4 nextClip = m * vec4( next, 1.0 );\n\n        vec4 currentNormed = currentClip / currentClip.w;\n        vec4 prevNormed = prevClip / prevClip.w;\n        vec4 nextNormed = nextClip / nextClip.w;\n\n        vec2 currentScreen = intoScreen(currentNormed);\n        vec2 prevScreen = intoScreen(prevNormed);\n        vec2 nextScreen = intoScreen(nextNormed);\n\n        float actualWidth = lineWidth * width;\n\n        vec2 dir;\n        if(nextScreen == currentScreen) {\n            dir = normalize( currentScreen - prevScreen );\n        } else if(prevScreen == currentScreen) {\n            dir = normalize( nextScreen - currentScreen );\n        } else {\n            vec2 inDir = currentScreen - prevScreen;\n            vec2 outDir = nextScreen - currentScreen;\n            vec2 fullDir = nextScreen - prevScreen;\n\n            if(length(fullDir) > 0.0) {\n                dir = normalize(fullDir);\n            } else if(length(inDir) > 0.0){\n                dir = normalize(inDir);\n            } else {\n                dir = normalize(outDir);\n            }\n        }\n\n        vec2 normal = vec2(-dir.y, dir.x);\n\n        if(sizeAttenuation != 0.0) {\n            normal /= currentClip.w;\n            normal *= min(resolution.x, resolution.y);\n        }\n\n        if (scaleDown > 0.0) {\n            float dist = length(nextNormed - prevNormed);\n            normal *= smoothstep(0.0, scaleDown, dist);\n        }\n\n        vec2 offsetInScreen = actualWidth * normal * side * 0.5;\n\n        vec2 withOffsetScreen = currentScreen + offsetInScreen;\n        vec3 withOffsetNormed = vec3((2.0 * withOffsetScreen/resolution - 1.0), currentNormed.z);\n\n        vCounters = counters;\n        vColor = vec4( color, opacity );\n        vUV = uv;\n\n        gl_Position = currentClip.w * vec4(withOffsetNormed, 1.0);\n\n        ${ShaderChunk.logdepthbuf_vertex}\n        ${ShaderChunk.fog_vertex}\n    }\n`;\n`\nuniform vec3 glowColor;\nuniform float falloffAmount;\nuniform float glowSharpness;\nuniform float glowInternalRadius;\n\nvarying vec3 vPosition;\nvarying vec3 vNormal;\n\nvoid main()\n{\n\t// Normal\n\tvec3 normal = normalize(vNormal);\n\tif(!gl_FrontFacing)\n\t\t\tnormal *= - 1.0;\n\tvec3 viewDirection = normalize(cameraPosition - vPosition);\n\tfloat fresnel = dot(viewDirection, normal);\n\tfresnel = pow(fresnel, glowInternalRadius + 0.1);\n\tfloat falloff = smoothstep(0., falloffAmount, fresnel);\n\tfloat fakeGlow = fresnel;\n\tfakeGlow += fresnel * glowSharpness;\n\tfakeGlow *= falloff;\n\tgl_FragColor = vec4(clamp(glowColor * fresnel, 0., 1.0), clamp(fakeGlow, 0., 1.0));\n\n\t${ShaderChunk.tonemapping_fragment}\n\t${ShaderChunk.colorspace_fragment}\n}`;\n`\nuniform sampler2D pointTexture;\nuniform float fade;\nuniform float opacity;\n\nvarying vec3 vColor;\nvoid main() {\n\tfloat pointOpacity = 1.0;\n\tif (fade == 1.0) {\n\t\tfloat d = distance(gl_PointCoord, vec2(0.5, 0.5));\n\t\tpointOpacity = 1.0 / (1.0 + exp(16.0 * (d - 0.25)));\n\t}\n\tgl_FragColor = vec4(vColor, pointOpacity * opacity);\n\n\t${ShaderChunk.tonemapping_fragment}\n\t${ShaderChunk.colorspace_fragment}\n}`;\n`#define ENVMAP_TYPE_CUBE_UV\nprecision highp isampler2D;\nprecision highp usampler2D;\nvarying vec3 vWorldPosition;\nvarying vec3 vNormal;\nvarying mat4 vModelMatrixInverse;\n\n#ifdef USE_INSTANCING_COLOR\n\tvarying vec3 vInstanceColor;\n#endif\n\n#ifdef ENVMAP_TYPE_CUBEM\n\tuniform samplerCube envMap;\n#else\n\tuniform sampler2D envMap;\n#endif\n\nuniform float bounces;\n${shaderStructs}\n${shaderIntersectFunction}\nuniform BVH bvh;\nuniform float ior;\nuniform bool correctMips;\nuniform vec2 resolution;\nuniform float fresnel;\nuniform mat4 modelMatrix;\nuniform mat4 projectionMatrixInverse;\nuniform mat4 viewMatrixInverse;\nuniform float aberrationStrength;\nuniform vec3 color;\n\nfloat fresnelFunc(vec3 viewDirection, vec3 worldNormal) {\n\treturn pow( 1.0 + dot( viewDirection, worldNormal), 10.0 );\n}\n\nvec3 totalInternalReflection(vec3 ro, vec3 rd, vec3 normal, float ior, mat4 modelMatrixInverse) {\n\tvec3 rayOrigin = ro;\n\tvec3 rayDirection = rd;\n\trayDirection = refract(rayDirection, normal, 1.0 / ior);\n\trayOrigin = vWorldPosition + rayDirection * 0.001;\n\trayOrigin = (modelMatrixInverse * vec4(rayOrigin, 1.0)).xyz;\n\trayDirection = normalize((modelMatrixInverse * vec4(rayDirection, 0.0)).xyz);\n\tfor(float i = 0.0; i < bounces; i++) {\n\t\tuvec4 faceIndices = uvec4( 0u );\n\t\tvec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\n\t\tvec3 barycoord = vec3( 0.0 );\n\t\tfloat side = 1.0;\n\t\tfloat dist = 0.0;\n\t\tbvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );\n\t\tvec3 hitPos = rayOrigin + rayDirection * max(dist - 0.001, 0.0);\n\t\tvec3 tempDir = refract(rayDirection, faceNormal, ior);\n\t\tif (length(tempDir) != 0.0) {\n\t\t\trayDirection = tempDir;\n\t\t\tbreak;\n\t\t}\n\t\trayDirection = reflect(rayDirection, faceNormal);\n\t\trayOrigin = hitPos + rayDirection * 0.01;\n\t}\n\trayDirection = normalize((modelMatrix * vec4(rayDirection, 0.0)).xyz);\n\treturn rayDirection;\n}\n\n#include <common>\n#include <cube_uv_reflection_fragment>\n\n#ifdef ENVMAP_TYPE_CUBEM\n\tvec4 textureGradient(samplerCube envMap, vec3 rayDirection, vec3 directionCamPerfect) {\n\t\treturn textureGrad(envMap, rayDirection, dFdx(correctMips ? directionCamPerfect: rayDirection), dFdy(correctMips ? directionCamPerfect: rayDirection));\n\t}\n#else\n\tvec4 textureGradient(sampler2D envMap, vec3 rayDirection, vec3 directionCamPerfect) {\n\t\tvec2 uvv = equirectUv( rayDirection );\n\t\tvec2 smoothUv = equirectUv( directionCamPerfect );\n\t\treturn textureGrad(envMap, uvv, dFdx(correctMips ? smoothUv : uvv), dFdy(correctMips ? smoothUv : uvv));\n\t}\n#endif\n\nvoid main() {\n\tvec2 uv = gl_FragCoord.xy / resolution;\n\tvec3 directionCamPerfect = (projectionMatrixInverse * vec4(uv * 2.0 - 1.0, 0.0, 1.0)).xyz;\n\tdirectionCamPerfect = (viewMatrixInverse * vec4(directionCamPerfect, 0.0)).xyz;\n\tdirectionCamPerfect = normalize(directionCamPerfect);\n\tvec3 normal = vNormal;\n\tvec3 rayOrigin = cameraPosition;\n\tvec3 rayDirection = normalize(vWorldPosition - cameraPosition);\n\tvec3 finalColor;\n\t#ifdef CHROMATIC_ABERRATIONS\n\t\tvec3 rayDirectionG = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior, 1.0), vModelMatrixInverse);\n\t\t#ifdef FAST_CHROMA\n\t\t\tvec3 rayDirectionR = normalize(rayDirectionG + 1.0 * vec3(aberrationStrength / 2.0));\n\t\t\tvec3 rayDirectionB = normalize(rayDirectionG - 1.0 * vec3(aberrationStrength / 2.0));\n\t\t#else\n\t\t\tvec3 rayDirectionR = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior * (1.0 - aberrationStrength), 1.0), vModelMatrixInverse);\n\t\t\tvec3 rayDirectionB = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior * (1.0 + aberrationStrength), 1.0), vModelMatrixInverse);\n\t\t#endif\n\t\tfloat finalColorR = textureGradient(envMap, rayDirectionR, directionCamPerfect).r;\n\t\tfloat finalColorG = textureGradient(envMap, rayDirectionG, directionCamPerfect).g;\n\t\tfloat finalColorB = textureGradient(envMap, rayDirectionB, directionCamPerfect).b;\n\t\tfinalColor = vec3(finalColorR, finalColorG, finalColorB);\n\t#else\n\t\trayDirection = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior, 1.0), vModelMatrixInverse);\n\t\tfinalColor = textureGradient(envMap, rayDirection, directionCamPerfect).rgb;\n\t#endif\n\n\tfinalColor *= color;\n\t#ifdef USE_INSTANCING_COLOR\n\t\tfinalColor *= vInstanceColor;\n\t#endif\n\n\tvec3 viewDirection = normalize(vWorldPosition - cameraPosition);\n\tfloat nFresnel = fresnelFunc(viewDirection, normal) * fresnel;\n\tgl_FragColor = vec4(mix(finalColor, vec3(1.0), nFresnel), 1.0);\n\t${ShaderChunk.tonemapping_fragment}\n\t${ShaderChunk.colorspace_fragment}\n}`;\nnew Box3();\ntypeof window !== \"undefined\" ? document.createElement(\"div\") : void 0;\nnew MeshBasicMaterial();\nnew Vector3();\nnew Matrix4();\nnew Ray();\nnew Sphere();\nnew Box3();\nnew Vector3();\nnew Vector3();\nfunction writableDerived(origins, derive, reflect, initial) {\n  var childDerivedSetter, originValues, blockNextDerive = false;\n  var reflectOldValues = reflect.length >= 2;\n  var wrappedDerive = (got, set, update3) => {\n    childDerivedSetter = set;\n    if (reflectOldValues) {\n      originValues = got;\n    }\n    if (!blockNextDerive) {\n      let returned = derive(got, set, update3);\n      if (derive.length < 2) {\n        set(returned);\n      } else {\n        return returned;\n      }\n    }\n    blockNextDerive = false;\n  };\n  var childDerived = derived(origins, wrappedDerive, initial);\n  var singleOrigin = !Array.isArray(origins);\n  function doReflect(reflecting) {\n    var setWith = reflect(reflecting, originValues);\n    if (singleOrigin) {\n      blockNextDerive = true;\n      origins.set(setWith);\n    } else {\n      setWith.forEach((value, i) => {\n        blockNextDerive = true;\n        origins[i].set(value);\n      });\n    }\n    blockNextDerive = false;\n  }\n  var tryingSet = false;\n  function update2(fn) {\n    var isUpdated, mutatedBySubscriptions, oldValue, newValue;\n    if (tryingSet) {\n      newValue = fn(get(childDerived));\n      childDerivedSetter(newValue);\n      return;\n    }\n    var unsubscribe = childDerived.subscribe((value) => {\n      if (!tryingSet) {\n        oldValue = value;\n      } else if (!isUpdated) {\n        isUpdated = true;\n      } else {\n        mutatedBySubscriptions = true;\n      }\n    });\n    newValue = fn(oldValue);\n    tryingSet = true;\n    childDerivedSetter(newValue);\n    unsubscribe();\n    tryingSet = false;\n    if (mutatedBySubscriptions) {\n      newValue = get(childDerived);\n    }\n    if (isUpdated) {\n      doReflect(newValue);\n    }\n  }\n  return {\n    subscribe: childDerived.subscribe,\n    set(value) {\n      update2(() => value);\n    },\n    update: update2\n  };\n}\nconst TOAST_LIMIT = 20;\nconst toasts = writable([]);\nconst pausedAt = writable(null);\nconst toastTimeouts = /* @__PURE__ */ new Map();\nconst addToRemoveQueue = (toastId) => {\n  if (toastTimeouts.has(toastId)) {\n    return;\n  }\n  const timeout = setTimeout(() => {\n    toastTimeouts.delete(toastId);\n    remove(toastId);\n  }, 1e3);\n  toastTimeouts.set(toastId, timeout);\n};\nconst clearFromRemoveQueue = (toastId) => {\n  const timeout = toastTimeouts.get(toastId);\n  if (timeout) {\n    clearTimeout(timeout);\n  }\n};\nfunction update(toast2) {\n  if (toast2.id) {\n    clearFromRemoveQueue(toast2.id);\n  }\n  toasts.update(($toasts) => $toasts.map((t) => t.id === toast2.id ? { ...t, ...toast2 } : t));\n}\nfunction add(toast2) {\n  toasts.update(($toasts) => [toast2, ...$toasts].slice(0, TOAST_LIMIT));\n}\nfunction upsert(toast2) {\n  if (get(toasts).find((t) => t.id === toast2.id)) {\n    update(toast2);\n  } else {\n    add(toast2);\n  }\n}\nfunction dismiss(toastId) {\n  toasts.update(($toasts) => {\n    if (toastId) {\n      addToRemoveQueue(toastId);\n    } else {\n      $toasts.forEach((toast2) => {\n        addToRemoveQueue(toast2.id);\n      });\n    }\n    return $toasts.map((t) => t.id === toastId || toastId === void 0 ? { ...t, visible: false } : t);\n  });\n}\nfunction remove(toastId) {\n  toasts.update(($toasts) => {\n    if (toastId === void 0) {\n      return [];\n    }\n    return $toasts.filter((t) => t.id !== toastId);\n  });\n}\nfunction startPause(time) {\n  pausedAt.set(time);\n}\nfunction endPause(time) {\n  let diff;\n  pausedAt.update(($pausedAt) => {\n    diff = time - ($pausedAt || 0);\n    return null;\n  });\n  toasts.update(($toasts) => $toasts.map((t) => ({\n    ...t,\n    pauseDuration: t.pauseDuration + diff\n  })));\n}\nconst defaultTimeouts = {\n  blank: 4e3,\n  error: 4e3,\n  success: 2e3,\n  loading: Infinity,\n  custom: 4e3\n};\nfunction useToasterStore(toastOptions = {}) {\n  const mergedToasts = writableDerived(toasts, ($toasts) => $toasts.map((t) => ({\n    ...toastOptions,\n    ...toastOptions[t.type],\n    ...t,\n    duration: t.duration || toastOptions[t.type]?.duration || toastOptions?.duration || defaultTimeouts[t.type],\n    style: [toastOptions.style, toastOptions[t.type]?.style, t.style].join(\";\")\n  })), ($toasts) => $toasts);\n  return {\n    toasts: mergedToasts,\n    pausedAt\n  };\n}\nconst isFunction = (valOrFunction) => typeof valOrFunction === \"function\";\nconst resolveValue = (valOrFunction, arg) => isFunction(valOrFunction) ? valOrFunction(arg) : valOrFunction;\nconst genId = /* @__PURE__ */ (() => {\n  let count = 0;\n  return () => {\n    count += 1;\n    return count.toString();\n  };\n})();\nconst prefersReducedMotion = /* @__PURE__ */ (() => {\n  let shouldReduceMotion;\n  return () => {\n    if (shouldReduceMotion === void 0 && typeof window !== \"undefined\") {\n      const mediaQuery = matchMedia(\"(prefers-reduced-motion: reduce)\");\n      shouldReduceMotion = !mediaQuery || mediaQuery.matches;\n    }\n    return shouldReduceMotion;\n  };\n})();\nconst createToast = (message, type = \"blank\", opts) => ({\n  createdAt: Date.now(),\n  visible: true,\n  type,\n  ariaProps: {\n    role: \"status\",\n    \"aria-live\": \"polite\"\n  },\n  message,\n  pauseDuration: 0,\n  ...opts,\n  id: opts?.id || genId()\n});\nconst createHandler = (type) => (message, options) => {\n  const toast2 = createToast(message, type, options);\n  upsert(toast2);\n  return toast2.id;\n};\nconst toast = (message, opts) => createHandler(\"blank\")(message, opts);\ntoast.error = createHandler(\"error\");\ntoast.success = createHandler(\"success\");\ntoast.loading = createHandler(\"loading\");\ntoast.custom = createHandler(\"custom\");\ntoast.dismiss = (toastId) => {\n  dismiss(toastId);\n};\ntoast.remove = (toastId) => remove(toastId);\ntoast.promise = (promise, msgs, opts) => {\n  const id = toast.loading(msgs.loading, { ...opts, ...opts?.loading });\n  promise.then((p) => {\n    toast.success(resolveValue(msgs.success, p), {\n      id,\n      ...opts,\n      ...opts?.success\n    });\n    return p;\n  }).catch((e) => {\n    toast.error(resolveValue(msgs.error, e), {\n      id,\n      ...opts,\n      ...opts?.error\n    });\n  });\n  return promise;\n};\nfunction calculateOffset(toast2, $toasts, opts) {\n  const { reverseOrder, gutter = 8, defaultPosition } = opts || {};\n  const relevantToasts = $toasts.filter((t) => (t.position || defaultPosition) === (toast2.position || defaultPosition) && t.height);\n  const toastIndex = relevantToasts.findIndex((t) => t.id === toast2.id);\n  const toastsBefore = relevantToasts.filter((toast3, i) => i < toastIndex && toast3.visible).length;\n  const offset = relevantToasts.filter((t) => t.visible).slice(...reverseOrder ? [toastsBefore + 1] : [0, toastsBefore]).reduce((acc, t) => acc + (t.height || 0) + gutter, 0);\n  return offset;\n}\nconst handlers = {\n  startPause() {\n    startPause(Date.now());\n  },\n  endPause() {\n    endPause(Date.now());\n  },\n  updateHeight: (toastId, height) => {\n    update({ id: toastId, height });\n  },\n  calculateOffset\n};\nfunction useToaster(toastOptions) {\n  const { toasts: toasts2, pausedAt: pausedAt2 } = useToasterStore(toastOptions);\n  const timeouts = /* @__PURE__ */ new Map();\n  let _pausedAt;\n  const unsubscribes = [\n    pausedAt2.subscribe(($pausedAt) => {\n      if ($pausedAt) {\n        for (const [, timeoutId] of timeouts) {\n          clearTimeout(timeoutId);\n        }\n        timeouts.clear();\n      }\n      _pausedAt = $pausedAt;\n    }),\n    toasts2.subscribe(($toasts) => {\n      if (_pausedAt) {\n        return;\n      }\n      const now = Date.now();\n      for (const t of $toasts) {\n        if (timeouts.has(t.id)) {\n          continue;\n        }\n        if (t.duration === Infinity) {\n          continue;\n        }\n        const durationLeft = (t.duration || 0) + t.pauseDuration - (now - t.createdAt);\n        if (durationLeft < 0) {\n          if (t.visible) {\n            toast.dismiss(t.id);\n          }\n          return null;\n        }\n        timeouts.set(t.id, setTimeout(() => toast.dismiss(t.id), durationLeft));\n      }\n    })\n  ];\n  onDestroy(() => {\n    for (const unsubscribe of unsubscribes) {\n      unsubscribe();\n    }\n  });\n  return { toasts: toasts2, handlers };\n}\nfunction CheckmarkIcon($$renderer, $$props) {\n  let primary = fallback($$props[\"primary\"], \"#61d345\");\n  let secondary = fallback($$props[\"secondary\"], \"#fff\");\n  $$renderer.push(`<div class=\"svelte-1did3zw\"${attr_style(\"\", { \"--primary\": primary, \"--secondary\": secondary })}></div>`);\n  bind_props($$props, { primary, secondary });\n}\nfunction ErrorIcon($$renderer, $$props) {\n  let primary = fallback($$props[\"primary\"], \"#ff4b4b\");\n  let secondary = fallback($$props[\"secondary\"], \"#fff\");\n  $$renderer.push(`<div class=\"svelte-1ro2ggf\"${attr_style(\"\", { \"--primary\": primary, \"--secondary\": secondary })}></div>`);\n  bind_props($$props, { primary, secondary });\n}\nfunction LoaderIcon($$renderer, $$props) {\n  let primary = fallback($$props[\"primary\"], \"#616161\");\n  let secondary = fallback($$props[\"secondary\"], \"#e0e0e0\");\n  $$renderer.push(`<div class=\"svelte-tyythq\"${attr_style(\"\", { \"--primary\": primary, \"--secondary\": secondary })}></div>`);\n  bind_props($$props, { primary, secondary });\n}\nfunction ToastIcon($$renderer, $$props) {\n  let type, icon, iconTheme;\n  let toast2 = $$props[\"toast\"];\n  ({ type, icon, iconTheme } = toast2);\n  if (typeof icon === \"string\") {\n    $$renderer.push(\"<!--[-->\");\n    $$renderer.push(`<div class=\"animated svelte-t33qv2\">${escape_html(icon)}</div>`);\n  } else {\n    $$renderer.push(\"<!--[!-->\");\n    if (typeof icon !== \"undefined\") {\n      $$renderer.push(\"<!--[-->\");\n      $$renderer.push(`<!---->`);\n      icon?.($$renderer, {});\n      $$renderer.push(`<!---->`);\n    } else {\n      $$renderer.push(\"<!--[!-->\");\n      if (type !== \"blank\") {\n        $$renderer.push(\"<!--[-->\");\n        $$renderer.push(`<div class=\"indicator svelte-t33qv2\">`);\n        LoaderIcon($$renderer, spread_props([iconTheme]));\n        $$renderer.push(`<!----> `);\n        if (type !== \"loading\") {\n          $$renderer.push(\"<!--[-->\");\n          $$renderer.push(`<div class=\"status svelte-t33qv2\">`);\n          if (type === \"error\") {\n            $$renderer.push(\"<!--[-->\");\n            ErrorIcon($$renderer, spread_props([iconTheme]));\n          } else {\n            $$renderer.push(\"<!--[!-->\");\n            CheckmarkIcon($$renderer, spread_props([iconTheme]));\n          }\n          $$renderer.push(`<!--]--></div>`);\n        } else {\n          $$renderer.push(\"<!--[!-->\");\n        }\n        $$renderer.push(`<!--]--></div>`);\n      } else {\n        $$renderer.push(\"<!--[!-->\");\n      }\n      $$renderer.push(`<!--]-->`);\n    }\n    $$renderer.push(`<!--]-->`);\n  }\n  $$renderer.push(`<!--]-->`);\n  bind_props($$props, { toast: toast2 });\n}\nfunction ToastMessage($$renderer, $$props) {\n  $$renderer.component(($$renderer2) => {\n    let toast2 = $$props[\"toast\"];\n    $$renderer2.push(`<div${spread_attributes({ class: \"message\", ...toast2.ariaProps }, \"svelte-1gudbf6\")}>`);\n    if (typeof toast2.message === \"string\") {\n      $$renderer2.push(\"<!--[-->\");\n      $$renderer2.push(`${escape_html(toast2.message)}`);\n    } else {\n      $$renderer2.push(\"<!--[!-->\");\n      $$renderer2.push(`<!---->`);\n      toast2.message?.($$renderer2, { toast: toast2 });\n      $$renderer2.push(`<!---->`);\n    }\n    $$renderer2.push(`<!--]--></div>`);\n    bind_props($$props, { toast: toast2 });\n  });\n}\nfunction ToastBar($$renderer, $$props) {\n  $$renderer.component(($$renderer2) => {\n    let toast2 = $$props[\"toast\"];\n    let position = fallback($$props[\"position\"], () => void 0, true);\n    let style = fallback($$props[\"style\"], \"\");\n    let Component = fallback($$props[\"Component\"], () => void 0, true);\n    let factor;\n    let animation;\n    {\n      const top = (toast2.position || position || \"top-center\").includes(\"top\");\n      factor = top ? 1 : -1;\n      const [enter, exit] = prefersReducedMotion() ? [\"fadeIn\", \"fadeOut\"] : [\"enter\", \"exit\"];\n      animation = toast2.visible ? enter : exit;\n    }\n    $$renderer2.push(`<div${attr_class(`base ${stringify(toast2.height ? animation : \"transparent\")} ${stringify(toast2.className || \"\")}`, \"svelte-yae3e8\")}${attr_style(`${stringify(style)}; ${stringify(toast2.style)}`, { \"--factor\": factor })}>`);\n    if (Component) {\n      $$renderer2.push(\"<!--[-->\");\n      $$renderer2.push(`<!---->`);\n      Component?.($$renderer2, {\n        $$slots: {\n          icon: ($$renderer3) => {\n            ToastIcon($$renderer3, { toast: toast2, slot: \"icon\" });\n          },\n          message: ($$renderer3) => {\n            ToastMessage($$renderer3, { toast: toast2, slot: \"message\" });\n          }\n        }\n      });\n      $$renderer2.push(`<!---->`);\n    } else {\n      $$renderer2.push(\"<!--[!-->\");\n      $$renderer2.push(`<!---->`);\n      slot($$renderer2, $$props, \"default\", { ToastIcon, ToastMessage, toast: toast2 }, () => {\n        ToastIcon($$renderer2, { toast: toast2 });\n        $$renderer2.push(`<!----> `);\n        ToastMessage($$renderer2, { toast: toast2 });\n        $$renderer2.push(`<!---->`);\n      });\n      $$renderer2.push(`<!---->`);\n    }\n    $$renderer2.push(`<!--]--></div>`);\n    bind_props($$props, { toast: toast2, position, style, Component });\n  });\n}\nfunction ToastWrapper($$renderer, $$props) {\n  $$renderer.component(($$renderer2) => {\n    let top, bottom, factor, justifyContent;\n    let toast2 = $$props[\"toast\"];\n    let setHeight = $$props[\"setHeight\"];\n    top = toast2.position?.includes(\"top\") ? 0 : null;\n    bottom = toast2.position?.includes(\"bottom\") ? 0 : null;\n    factor = toast2.position?.includes(\"top\") ? 1 : -1;\n    justifyContent = toast2.position?.includes(\"center\") && \"center\" || (toast2.position?.includes(\"right\") || toast2.position?.includes(\"end\")) && \"flex-end\" || null;\n    $$renderer2.push(`<div${attr_class(\"wrapper svelte-1pz3gqy\", void 0, {\n      \"active\": toast2.visible,\n      \"transition\": !prefersReducedMotion()\n    })}${attr_style(\"\", {\n      \"--factor\": factor,\n      \"--offset\": toast2.offset,\n      top,\n      bottom,\n      \"justify-content\": justifyContent\n    })}>`);\n    if (toast2.type === \"custom\") {\n      $$renderer2.push(\"<!--[-->\");\n      ToastMessage($$renderer2, { toast: toast2 });\n    } else {\n      $$renderer2.push(\"<!--[!-->\");\n      $$renderer2.push(`<!---->`);\n      slot($$renderer2, $$props, \"default\", { toast: toast2 }, () => {\n        ToastBar($$renderer2, { toast: toast2, position: toast2.position });\n      });\n      $$renderer2.push(`<!---->`);\n    }\n    $$renderer2.push(`<!--]--></div>`);\n    bind_props($$props, { toast: toast2, setHeight });\n  });\n}\nfunction Toaster($$renderer, $$props) {\n  $$renderer.component(($$renderer2) => {\n    var $$store_subs;\n    let reverseOrder = fallback($$props[\"reverseOrder\"], false);\n    let position = fallback($$props[\"position\"], \"top-center\");\n    let toastOptions = fallback($$props[\"toastOptions\"], () => void 0, true);\n    let gutter = fallback($$props[\"gutter\"], 8);\n    let containerStyle = fallback($$props[\"containerStyle\"], () => void 0, true);\n    let containerClassName = fallback($$props[\"containerClassName\"], () => void 0, true);\n    const { toasts: toasts2, handlers: handlers2 } = useToaster(toastOptions);\n    let _toasts;\n    _toasts = store_get($$store_subs ??= {}, \"$toasts\", toasts2).map((toast2) => ({\n      ...toast2,\n      position: toast2.position || position,\n      offset: handlers2.calculateOffset(toast2, store_get($$store_subs ??= {}, \"$toasts\", toasts2), { reverseOrder, gutter, defaultPosition: position })\n    }));\n    $$renderer2.push(`<div${attr_class(`toaster ${stringify(containerClassName || \"\")}`, \"svelte-haq5xk\")}${attr_style(containerStyle)} role=\"alert\"><!--[-->`);\n    const each_array = ensure_array_like(_toasts);\n    for (let $$index = 0, $$length = each_array.length; $$index < $$length; $$index++) {\n      let toast2 = each_array[$$index];\n      ToastWrapper($$renderer2, {\n        toast: toast2,\n        setHeight: (height) => handlers2.updateHeight(toast2.id, height)\n      });\n    }\n    $$renderer2.push(`<!--]--></div>`);\n    if ($$store_subs) unsubscribe_stores($$store_subs);\n    bind_props($$props, {\n      reverseOrder,\n      position,\n      toastOptions,\n      gutter,\n      containerStyle,\n      containerClassName\n    });\n  });\n}\nfunction _page($$renderer, $$props) {\n  $$renderer.component(($$renderer2) => {\n    let carColors = [];\n    let rimColors = [];\n    let caliperColors = [];\n    let selectedCarColor = null;\n    let selectedRimColor = null;\n    let selectedCaliperColor = null;\n    let inputConfigurationCode = \"\";\n    $$renderer2.push(`<div class=\"relative aspect-video bg-gray-100 dark:bg-gray-900 rounded h-[80vh] w-full\">`);\n    Canvas($$renderer2, {\n      class: \"w-full h-full\",\n      children: ($$renderer3) => {\n        T.AmbientLight($$renderer3, { intensity: 0.5 });\n        $$renderer3.push(`<!----> `);\n        T.DirectionalLight($$renderer3, { position: [5, 10, 5], intensity: 1 });\n        $$renderer3.push(`<!----> `);\n        T.DirectionalLight($$renderer3, { position: [-10, 5, 0], intensity: 1 });\n        $$renderer3.push(`<!----> `);\n        T.DirectionalLight($$renderer3, { position: [1, 5, 0], intensity: 1 });\n        $$renderer3.push(`<!----> `);\n        Environment($$renderer3, { preset: \"city\" });\n        $$renderer3.push(`<!----> `);\n        T.PerspectiveCamera($$renderer3, {\n          makeDefault: true,\n          position: [5, 3, 7.5],\n          fov: 80,\n          near: 0.1,\n          far: 1e3,\n          children: ($$renderer4) => {\n            OrbitControls($$renderer4, { enableDamping: true });\n          },\n          $$slots: { default: true }\n        });\n        $$renderer3.push(`<!----> `);\n        T.Group($$renderer3, {\n          position: [0, 0, -0.5],\n          scale: 2,\n          children: ($$renderer4) => {\n            {\n              $$renderer4.push(\"<!--[!-->\");\n            }\n            $$renderer4.push(`<!--]-->`);\n          },\n          $$slots: { default: true }\n        });\n        $$renderer3.push(`<!----> `);\n        T.GridHelper($$renderer3, { args: [10, 10] });\n        $$renderer3.push(`<!---->`);\n      },\n      $$slots: { default: true }\n    });\n    $$renderer2.push(`<!----></div> <div class=\"options-container svelte-xhal46\"><div class=\"option-card svelte-xhal46\"><h3 class=\"svelte-xhal46\">Body Paint</h3> <div class=\"color-grid svelte-xhal46\"><!--[-->`);\n    const each_array = ensure_array_like(carColors);\n    for (let $$index = 0, $$length = each_array.length; $$index < $$length; $$index++) {\n      let color = each_array[$$index];\n      $$renderer2.push(`<button${attr_class(`color-dot ${stringify(selectedCarColor?._id === color._id ? \"selected\" : \"\")}`, \"svelte-xhal46\")}${attr_style(`background-color: ${stringify(color.hex)}`)} aria-label=\"Body Paint Color Selector\"${attr(\"title\", `${stringify(color.name)} (${stringify(color.price)} CHF)`)}></button>`);\n    }\n    $$renderer2.push(`<!--]--></div></div> <div class=\"option-card svelte-xhal46\"><h3 class=\"svelte-xhal46\">Rim Color</h3> <div class=\"color-grid svelte-xhal46\"><!--[-->`);\n    const each_array_1 = ensure_array_like(rimColors);\n    for (let $$index_1 = 0, $$length = each_array_1.length; $$index_1 < $$length; $$index_1++) {\n      let color = each_array_1[$$index_1];\n      $$renderer2.push(`<button${attr_class(`color-dot ${stringify(selectedRimColor?._id === color._id ? \"selected\" : \"\")}`, \"svelte-xhal46\")}${attr_style(`background-color: ${stringify(color.hex)}`)} aria-label=\"Rim Paint Color Selector\"${attr(\"title\", `${stringify(color.name)} (${stringify(color.price)} CHF)`)}></button>`);\n    }\n    $$renderer2.push(`<!--]--></div></div> <div class=\"option-card svelte-xhal46\"><h3 class=\"svelte-xhal46\">Caliper Color</h3> <div class=\"color-grid svelte-xhal46\"><!--[-->`);\n    const each_array_2 = ensure_array_like(caliperColors);\n    for (let $$index_2 = 0, $$length = each_array_2.length; $$index_2 < $$length; $$index_2++) {\n      let color = each_array_2[$$index_2];\n      $$renderer2.push(`<button${attr_class(`color-dot ${stringify(selectedCaliperColor?._id === color._id ? \"selected\" : \"\")}`, \"svelte-xhal46\")}${attr_style(`background-color: ${stringify(color.hex)}`)} aria-label=\"Caliper Paint Color Selector\"${attr(\"title\", `${stringify(color.name)} (${stringify(color.price)} CHF)`)}></button>`);\n    }\n    $$renderer2.push(`<!--]--></div></div></div> <div class=\"api-controls svelte-xhal46\"><div class=\"load-control svelte-xhal46\"><input class=\"dark:text-black text-black svelte-xhal46\" type=\"text\" placeholder=\"6-stelliger Code\" maxlength=\"6\"${attr(\"value\", inputConfigurationCode)}/> <button class=\"load-button svelte-xhal46\">Laden</button></div> <button class=\"save-button svelte-xhal46\">Speichern</button></div> `);\n    Toaster($$renderer2, {});\n    $$renderer2.push(`<!---->`);\n  });\n}\nexport {\n  _page as default\n};\n"],"names":["gt","yt","_t","vt","xt","U","st","Q","it","$t","X","Yt","me","Zt","BVHShaderGLSL.bvh_struct_definitions","BVHShaderGLSL.common_functions","BVHShaderGLSL.bvh_ray_functions","Pe","ee","ie","$"],"mappings":"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,IAAIM,OAAE,EAAE,CAAC,CAAK,IAAIC,KAAE,EAAE,CAAC,CAAM,IAAIP,OAAC,EAAE,CAAC,CAAM,IAAID,IAAE,EAAE,CAAC,CAAM,IAAIS,MAAE,EAAE,CAAC,CAAK,IAAIH,OAAC;;ACtlChL,MAAM,gBAAgB,aAAa;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;;AClFM,MAAM,iBAAiB,aAAa;;AAE3C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;A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;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,QAAQ,EAAE,WAAW,CAAC,kBAAkB;AACxC,QAAQ,EAAE,WAAW,CAAC,UAAU;AAChC;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC,EAAE,WAAW,CAAC,oBAAoB;AACnC,CAAC,EAAE,WAAW,CAAC,mBAAmB;AAClC,CAAC,CAAC;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC,EAAE,WAAW,CAAC,oBAAoB;AACnC,CAAC,EAAE,WAAW,CAAC,mBAAmB;AAClC,CAAC,CAAC;AACF,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE,aAAa;AACf,EAAE,uBAAuB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC,EAAE,WAAW,CAAC,oBAAoB;AACnC,CAAC,EAAE,WAAW,CAAC,m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","x_google_ignoreList":[0,1,2,3,4,5,6,7]}